diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/dissectors/Makefile.common wireshark-1.1.2-hip/epan/dissectors/Makefile.common
--- wireshark-1.1.2-orig/epan/dissectors/Makefile.common	2009-01-15 17:28:20.000000000 +0200
+++ wireshark-1.1.2-hip/epan/dissectors/Makefile.common	2009-02-17 09:34:35.000000000 +0200
@@ -476,6 +476,7 @@
 	packet-hci_h4.c		\
 	packet-hclnfsd.c	\
 	packet-hilscher.c	\
+	packet-hip.c		\
 	packet-homeplug.c 	\
 	packet-hpext.c		\
 	packet-hpsw.c		\
@@ -1000,6 +1001,7 @@
 	packet-hci_h1.h	\
 	packet-hci_h4.h	\
 	packet-hclnfsd.h	\
+	packet-hip.h		\
 	packet-hpext.h	\
 	packet-http.h	\
 	packet-i2c.h	\
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/dissectors/Makefile.common.orig wireshark-1.1.2-hip/epan/dissectors/Makefile.common.orig
--- wireshark-1.1.2-orig/epan/dissectors/Makefile.common.orig	1970-01-01 02:00:00.000000000 +0200
+++ wireshark-1.1.2-hip/epan/dissectors/Makefile.common.orig	2009-01-15 17:28:20.000000000 +0200
@@ -0,0 +1,1217 @@
+# Makefile.common
+#     Contains the stuff from Makefile.am and Makefile.nmake that is
+#     a) common to both files and
+#     b) portable between both files
+#
+# $Id: Makefile.common 27237 2009-01-15 07:36:50Z jake $
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+# "BUILT_SOURCES" are built before any "make all" or "make check" targets.
+BUILT_HEADER_FILES = \
+	x11-declarations.h	\
+	x11-register-info.h
+
+BUILT_C_FILES = \
+	register.c
+
+BUILT_SOURCES =	$(BUILT_C_FILES) $(BUILT_HEADER_FILES)
+
+# Header files generated from source files.
+GENERATED_HEADER_FILES = \
+	$(BUILT_HEADER_FILES)
+
+# C source files generated from source files.
+GENERATED_C_FILES = \
+	$(BUILT_C_FILES)	\
+	packet-ncp2222.c
+
+# All the generated files.
+GENERATED_FILES = $(GENERATED_HEADER_FILES) $(GENERATED_C_FILES)
+
+#
+# PIDL-generated DCE RPC dissectors without warnings.
+#
+PIDL_DISSECTOR_SRC = \
+	packet-dcerpc-atsvc.c \
+	packet-dcerpc-budb.c	\
+	packet-dcerpc-butc.c	\
+	packet-dcerpc-dfs.c \
+	packet-dcerpc-drsuapi.c	\
+	packet-dcerpc-dssetup.c \
+	packet-dcerpc-efs.c \
+	packet-dcerpc-initshutdown.c \
+	packet-dcerpc-nspi.c \
+	packet-dcerpc-wkssvc.c \
+	packet-dcerpc-wzcsvc.c
+
+#
+# PIDL-generated DCE RPC dissectors with warnings.
+#
+DIRTY_PIDL_DISSECTOR_SRC = \
+	packet-dcerpc-dnsserver.c 	\
+	packet-dcerpc-eventlog.c \
+	packet-dcerpc-lsa.c \
+	packet-dcerpc-srvsvc.c \
+	packet-dcerpc-winreg.c
+
+#
+# Headers for PIDL-generated dissectors.
+#
+PIDL_DISSECTOR_INCLUDES = \
+	packet-dcerpc-atsvc.h	\
+	packet-dcerpc-dfs.h	\
+	packet-dcerpc-dssetup.h	\
+	packet-dcerpc-efs.h	\
+	packet-dcerpc-eventlog.h	\
+	packet-dcerpc-initshutdown.h	\
+	packet-dcerpc-lsa.h	\
+	packet-dcerpc-nspi.h	\
+	packet-dcerpc-srvsvc.h	\
+	packet-dcerpc-winreg.h \
+	packet-dcerpc-wkssvc.h	\
+	packet-dcerpc-wzcsvc.h
+
+#
+# asn2wrs-generated ASN.1 dissectors without warnings.
+#
+ASN1_DISSECTOR_SRC = \
+	packet-acp133.c \
+	packet-acse.c \
+	packet-ansi_tcap.c \
+	packet-camel.c \
+	packet-cdt.c \
+	packet-cmip.c \
+	packet-cmp.c \
+	packet-cms.c \
+	packet-crmf.c \
+	packet-dap.c \
+	packet-disp.c \
+	packet-dop.c \
+	packet-dsp.c \
+	packet-ess.c \
+	packet-ftam.c \
+	packet-goose.c \
+	packet-h225.c \
+	packet-h235.c \
+	packet-h245.c \
+	packet-h248.c \
+	packet-h282.c \
+	packet-h283.c \
+	packet-h323.c \
+	packet-h450.c \
+	packet-h450-ros.c \
+	packet-h460.c \
+	packet-h501.c \
+	packet-logotypecertextn.c \
+	packet-mms.c \
+	packet-mpeg-audio.c \
+	packet-mpeg-pes.c \
+	packet-ns_cert_exts.c \
+	packet-ocsp.c \
+	packet-p7.c \
+	packet-pkcs1.c \
+	packet-pkinit.c \
+	packet-pkix1explicit.c \
+	packet-pkix1implicit.c \
+	packet-pkixproxy.c \
+	packet-pkixqualified.c \
+	packet-pkixtsp.c \
+	packet-pres.c \
+	packet-q932.c \
+	packet-q932-ros.c \
+	packet-qsig.c \
+	packet-ranap.c \
+	packet-ros.c \
+	packet-rtse.c \
+	packet-s4406.c \
+	packet-sabp.c \
+	packet-smrse.c \
+	packet-spnego.c \
+	packet-ulp.c \
+	packet-wlancertextn.c \
+	packet-x224.c \
+	packet-x509af.c \
+	packet-x509ce.c \
+	packet-x509if.c \
+	packet-x509sat.c 
+
+#
+# asn2wrs-generated ASN.1 dissectors with warnings.
+#
+DIRTY_ASN1_DISSECTOR_SRC = \
+	packet-ansi_map.c \
+	packet-gnm.c \
+	packet-gsm_map.c \
+	packet-inap.c \
+	packet-ldap.c \
+	packet-lte-rrc.c \
+	packet-nbap.c \
+	packet-pcap.c \
+	packet-pkcs12.c \
+	packet-rnsap.c \
+	packet-rrc.c \
+	packet-rrlp.c \
+	packet-s1ap.c \
+	packet-snmp.c \
+	packet-t125.c \
+	packet-tcap.c \
+	packet-x2ap.c \
+	packet-x411.c \
+	packet-x420.c
+
+#
+# Dissectors without warnings.
+#
+DISSECTOR_SRC = \
+	packet-2dparityfec.c 	\
+	packet-3com-njack.c	\
+	packet-3com-xns.c	\
+	packet-3g-a11.c		\
+	packet-9p.c		\
+	packet-aarp.c		\
+	packet-acap.c		\
+	packet-acn.c		\
+	packet-actrace.c	\
+	packet-afp.c		\
+	packet-afs.c		\
+	packet-aim.c		\
+	packet-aim-adverts.c	\
+	packet-aim-admin.c 	\
+	packet-aim-bos.c 	\
+	packet-aim-buddylist.c	\
+	packet-aim-chat.c	\
+	packet-aim-chatnav.c 	\
+	packet-aim-directory.c	\
+	packet-aim-email.c 	\
+	packet-aim-generic.c	\
+	packet-aim-icq.c 	\
+	packet-aim-invitation.c \
+	packet-aim-location.c 	\
+	packet-aim-messaging.c 	\
+	packet-aim-oft.c 	\
+	packet-aim-popup.c 	\
+	packet-aim-signon.c 	\
+	packet-aim-ssi.c 	\
+	packet-aim-sst.c 	\
+	packet-aim-stats.c 	\
+	packet-aim-translate.c 	\
+	packet-aim-userlookup.c \
+	packet-airopeek.c	\
+	packet-ajp13.c		\
+	packet-alcap.c		\
+	packet-amqp.c		\
+	packet-amr.c		\
+	packet-ans.c		\
+	packet-ansi_637.c	\
+	packet-ansi_683.c	\
+	packet-ansi_801.c	\
+	packet-ansi_a.c		\
+	packet-aodv.c		\
+	packet-aoe.c		\
+	packet-ap1394.c		\
+	packet-app-pkix-cert.c	\
+	packet-arcnet.c		\
+	packet-armagetronad.c 	\
+	packet-arp.c		\
+	packet-aruba-adp.c	\
+	packet-asap.c		\
+	packet-ascend.c		\
+	packet-asf.c		\
+	packet-atalk.c		\
+	packet-atm.c		\
+	packet-auto_rp.c	\
+	packet-ax4000.c		\
+	packet-ayiya.c		\
+	packet-bacapp.c		\
+	packet-bacnet.c		\
+	packet-bat.c		\
+	packet-bctp.c		\
+	packet-beep.c		\
+	packet-ber.c		\
+	packet-bfd.c		\
+	packet-bgp.c		\
+	packet-bittorrent.c 	\
+	packet-bofl.c		\
+	packet-bootp.c		\
+	packet-bootparams.c	\
+	packet-bpdu.c		\
+	packet-brdwlk.c		\
+	packet-bssap.c		\
+	packet-bssgp.c		\
+	packet-bthci_acl.c	\
+	packet-bthci_cmd.c	\
+	packet-bthci_evt.c	\
+	packet-bthci_sco.c	\
+	packet-btl2cap.c	\
+	packet-btrfcomm.c	\
+	packet-btsdp.c		\
+	packet-bvlc.c		\
+	packet-calcappprotocol.c  \
+	packet-cast.c		\
+	packet-catapult-dct2000.c \
+	packet-ccsds.c		\
+	packet-cdp.c		\
+	packet-cfm.c		\
+	packet-cgmp.c		\
+	packet-chdlc.c		\
+	packet-cigi.c   	\
+	packet-cimd.c		\
+	packet-cimetrics.c	\
+	packet-cip.c		\
+	packet-cisco-erspan.c	\
+	packet-cisco-oui.c	\
+	packet-cisco-wids.c	\
+	packet-clearcase.c	\
+	packet-clip.c		\
+	packet-clnp.c		\
+	packet-cmpp.c		\
+	packet-componentstatus.c \
+	packet-cops.c 		\
+	packet-cosine.c		\
+	packet-cpfi.c		\
+	packet-cpha.c		\
+	packet-csm-encaps.c	\
+	packet-ctdb.c		\
+	packet-cups.c		\
+	packet-daap.c		\
+	packet-data.c		\
+	packet-daytime.c 	\
+	packet-dcc.c		\
+	packet-dccp.c		\
+	packet-dcerpc-bossvr.c		\
+	packet-dcerpc-browser.c		\
+	packet-dcerpc-cds_clerkserver.c	\
+	packet-dcerpc-cds_solicit.c 	\
+	packet-dcerpc-conv.c		\
+	packet-dcerpc-cprpc_server.c 	\
+	packet-dcerpc-dce122.c		\
+	packet-dcerpc-dtsprovider.c 	\
+	packet-dcerpc-dtsstime_req.c 	\
+	packet-dcerpc-epm.c		\
+	packet-dcerpc-fileexp.c		\
+	packet-dcerpc-fldb.c		\
+	packet-dcerpc-frsapi.c		\
+	packet-dcerpc-frsrpc.c		\
+	packet-dcerpc-ftserver.c 	\
+	packet-dcerpc-icl_rpc.c		\
+	packet-dcerpc-krb5rpc.c		\
+	packet-dcerpc-llb.c		\
+	packet-dcerpc-mapi.c		\
+	packet-dcerpc-messenger.c 	\
+	packet-dcerpc-mgmt.c		\
+	packet-dcerpc-ndr.c		\
+	packet-dcerpc-netlogon.c 	\
+	packet-dcerpc-pnp.c		\
+	packet-dcerpc-rdaclif.c		\
+	packet-dcerpc-rep_proc.c 	\
+	packet-dcerpc-roverride.c 	\
+	packet-dcerpc-rpriv.c		\
+	packet-dcerpc-rras.c		\
+	packet-dcerpc-rs_acct.c		\
+	packet-dcerpc-rs_attr.c		\
+	packet-dcerpc-rs_attr_schema.c 	\
+	packet-dcerpc-rs_bind.c		\
+	packet-dcerpc-rs_misc.c		\
+	packet-dcerpc-rs_pgo.c		\
+	packet-dcerpc-rs_plcy.c		\
+	packet-dcerpc-rs_prop_acct.c	\
+	packet-dcerpc-rs_prop_acl.c	\
+	packet-dcerpc-rs_prop_attr.c	\
+	packet-dcerpc-rs_prop_pgo.c	\
+	packet-dcerpc-rs_prop_plcy.c	\
+	packet-dcerpc-rs_pwd_mgmt.c	\
+	packet-dcerpc-rs_repadm.c	\
+	packet-dcerpc-rs_replist.c	\
+	packet-dcerpc-rs_repmgr.c	\
+	packet-dcerpc-rs_unix.c		\
+	packet-dcerpc-rsec_login.c	\
+	packet-dcerpc-samr.c		\
+	packet-dcerpc-secidmap.c	\
+	packet-dcerpc-spoolss.c		\
+	packet-dcerpc-svcctl.c		\
+	packet-dcerpc-tapi.c		\
+	packet-dcerpc-tkn4int.c		\
+	packet-dcerpc-trksvr.c		\
+	packet-dcerpc-ubikdisk.c	\
+	packet-dcerpc-ubikvote.c	\
+	packet-dcerpc-update.c		\
+	packet-dcerpc.c			\
+	packet-dcm.c		\
+	packet-dcom.c 		\
+	packet-dcom-dispatch.c 	\
+	packet-dcom-oxid.c 	\
+	packet-dcom-remact.c 	\
+	packet-dcom-remunkn.c 	\
+	packet-dcom-sysact.c 	\
+	packet-dcp-etsi.c	\
+	packet-ddtp.c		\
+	packet-dec-bpdu.c	\
+	packet-dec-dnart.c	\
+	packet-dhcp-failover.c	\
+	packet-dhcpv6.c		\
+	packet-diameter.c	\
+	packet-diameter_3gpp.c	\
+	packet-dis.c		\
+	packet-dis-enums.c	\
+	packet-dis-fields.c	\
+	packet-dis-pdus.c	\
+	packet-diffserv-mpls-common.c	\
+	packet-distcc.c		\
+	packet-dlm3.c		\
+	packet-dlsw.c		\
+	packet-dmp.c		\
+	packet-dnp.c		\
+	packet-dns.c		\
+	packet-dplay.c		\
+	packet-dpnss.c		\
+	packet-drda.c 		\
+	packet-dsi.c		\
+	packet-dtls.c		\
+	packet-dtp.c		\
+	packet-dtpt.c		\
+	packet-dua.c		\
+	packet-dvmrp.c		\
+	packet-e164.c		\
+	packet-e212.c		\
+	packet-eap.c		\
+	packet-eapol.c		\
+	packet-echo.c		\
+	packet-edonkey.c	\
+	packet-egd.c		\
+	packet-eigrp.c		\
+	packet-enc.c		\
+	packet-enip.c		\
+	packet-enrp.c		\
+	packet-epl.c		\
+	packet-epl_v1.c		\
+	packet-epmd.c   	\
+	packet-erf.c		\
+	packet-esis.c		\
+	packet-eth.c		\
+	packet-etheric.c	\
+	packet-etherip.c	\
+	packet-ethertype.c	\
+	packet-evrc.c		\
+	packet-exec.c		\
+	packet-extreme.c	\
+	packet-fc.c		\
+	packet-fcct.c		\
+	packet-fcdns.c		\
+	packet-fcels.c		\
+	packet-fcfcs.c		\
+	packet-fcfzs.c		\
+	packet-fcip.c		\
+	packet-fclctl.c		\
+	packet-fcoe.c		\
+	packet-fcp.c		\
+	packet-fcsb3.c		\
+	packet-fcsp.c		\
+	packet-fcswils.c	\
+	packet-fddi.c		\
+	packet-ff.c		\
+	packet-fip.c		\
+	packet-fix.c		\
+	packet-fmp.c		\
+	packet-fmp_notify.c	\
+	packet-fr.c		\
+	packet-fractalgeneratorprotocol.c \
+	packet-frame.c		\
+	packet-ftp.c		\
+	packet-fw1.c		\
+	packet-g723.c		\
+	packet-gdsdb.c		\
+	packet-gift.c		\
+	packet-giop.c		\
+	packet-gmrp.c		\
+	packet-gnutella.c	\
+	packet-gpef.c		\
+	packet-gprs-llc.c	\
+	packet-gprs-ns.c	\
+	packet-gre.c		\
+	packet-gsm_a_bssmap.c		\
+	packet-gsm_a_common.c		\
+	packet-gsm_a_dtap.c		\
+	packet-gsm_a_gm.c		\
+	packet-gsm_a_rp.c		\
+	packet-gsm_a_rr.c	\
+	packet-gsm_bsslap.c		\
+	packet-gsm_bssmap_le.c	\
+	packet-gsm_sms.c	\
+	packet-gsm_sms_ud.c	\
+	packet-gsm_um.c	\
+	packet-gssapi.c		\
+	packet-gtp.c		\
+	packet-gvrp.c		\
+	packet-h1.c		\
+	packet-h221_nonstd.c	\
+	packet-h223.c		\
+	packet-h248_annex_c.c 	\
+	packet-h248_annex_e.c 	\
+	packet-h248_3gpp.c 	\
+	packet-h248_7.c 	\
+	packet-h248_10.c 	\
+	packet-h248_q1950.c	\
+	packet-h261.c		\
+	packet-h263.c		\
+	packet-h263p.c		\
+	packet-h264.c		\
+	packet-hci_h1.c		\
+	packet-hci_h4.c		\
+	packet-hclnfsd.c	\
+	packet-hilscher.c	\
+	packet-homeplug.c 	\
+	packet-hpext.c		\
+	packet-hpsw.c		\
+	packet-hsrp.c		\
+	packet-http.c		\
+	packet-hyperscsi.c	\
+	packet-i2c.c		\
+	packet-iapp.c		\
+	packet-iax2.c		\
+	packet-icap.c		\
+	packet-icep.c		\
+	packet-icmpv6.c		\
+	packet-icp.c		\
+	packet-icq.c		\
+	packet-idp.c		\
+	packet-iec104.c		\
+	packet-ieee80211.c	\
+	packet-ieee802154.c	\
+	packet-ieee8021ah.c	\
+	packet-ieee8023.c	\
+	packet-ieee802a.c	\
+	packet-ifcp.c		\
+	packet-igap.c		\
+	packet-igmp.c		\
+	packet-igrp.c		\
+	packet-image-gif.c	\
+	packet-image-jfif.c	\
+	packet-image-png.c	\
+	packet-imap.c		\
+	packet-imf.c		\
+	packet-ipars.c		\
+	packet-ip.c		\
+	packet-ipdc.c		\
+	packet-ipfc.c		\
+	packet-ipmi.c		\
+	packet-ipmi-session.c	\
+	packet-ipp.c		\
+	packet-ipsec.c		\
+	packet-ipsec-tcp.c	\
+	packet-ipsec-udp.c	\
+	packet-ipsi-ctl.c	\
+	packet-ipv6.c		\
+	packet-ipvs-syncd.c	\
+	packet-ipx.c		\
+	packet-ipxwan.c		\
+	packet-irc.c		\
+	packet-isakmp.c		\
+	packet-iscsi.c		\
+	packet-isdn.c		\
+	packet-isis-clv.c	\
+	packet-isis-hello.c	\
+	packet-isis-lsp.c	\
+	packet-isis-snp.c	\
+	packet-isis.c 		\
+	packet-isl.c		\
+	packet-ismp.c		\
+	packet-isns.c		\
+	packet-isup.c		\
+	packet-isup_thin.c	\
+	packet-itdm.c		\
+	packet-iua.c		\
+	packet-iuup.c		\
+	packet-iwarp-ddp-rdmap.c\
+	packet-iwarp-mpa.c	\
+	packet-jabber.c		\
+	packet-jpeg.c 		\
+	packet-juniper.c 	\
+	packet-jxta.c		\
+	packet-kadm5.c		\
+	packet-kdp.c		\
+	packet-kerberos.c	\
+	packet-kerberos4.c	\
+	packet-klm.c		\
+	packet-kingfisher.c	\
+	packet-kink.c		\
+	packet-kismet.c		\
+	packet-kpasswd.c	\
+	packet-l2tp.c		\
+	packet-lanforge.c	\
+	packet-lapb.c		\
+	packet-lapbether.c	\
+	packet-lapd.c		\
+	packet-lapdm.c		\
+	packet-laplink.c	\
+	packet-l1-events.c	\
+	packet-ldp.c		\
+	packet-lge_monitor.c	\
+	packet-linx.c		\
+	packet-llc.c		\
+	packet-lldp.c		\
+	packet-llt.c		\
+	packet-lmi.c		\
+	packet-lmp.c		\
+	packet-loop.c		\
+	packet-lpd.c		\
+	packet-lsc.c		\
+	packet-lwapp.c		\
+	packet-m2pa.c		\
+	packet-m2tp.c		\
+	packet-m2ua.c		\
+	packet-m3ua.c		\
+	packet-mac-lte.c		\
+	packet-maccontrol.c	\
+	packet-manolito.c	\
+	packet-mbtcp.c		\
+	packet-mdshdr.c		\
+	packet-media.c		\
+	packet-megaco.c		\
+	packet-mgcp.c		\
+	packet-mikey.c		\
+	packet-mip.c		\
+	packet-mip6.c		\
+	packet-ms-mms.c		\
+	packet-mmse.c		\
+	packet-mount.c		\
+	packet-mp2t.c		\
+	packet-mp4ves.c		\
+	packet-mpeg1.c		\
+	packet-mpls.c		\
+	packet-mpls-echo.c   	\
+	packet-mq.c		\
+	packet-mq-pcf.c		\
+	packet-mrdisc.c		\
+	packet-msdp.c		\
+	packet-msnlb.c		\
+	packet-msn-messenger.c	\
+	packet-msnip.c		\
+	packet-msproxy.c	\
+	packet-msrp.c		\
+	packet-mstp.c		\
+	packet-mtp2.c		\
+	packet-mtp3.c		\
+	packet-mtp3mg.c		\
+	packet-multipart.c	\
+	packet-mysql.c		\
+	packet-nas_eps.c	\
+	packet-nasdaq-itch.c	\
+	packet-nbipx.c		\
+	packet-nbns.c		\
+	packet-ncp.c		\
+	packet-ncp2222.c	\
+	packet-ncp-nmas.c	\
+	packet-ncp-sss.c 	\
+	packet-ncs.c		\
+	packet-ndmp.c		\
+	packet-ndps.c		\
+	packet-netbios.c	\
+	packet-netflow.c	\
+	packet-netsync.c 	\
+	packet-nettl.c		\
+	packet-newmail.c	\
+	packet-nfs.c		\
+	packet-nfsacl.c		\
+	packet-nfsauth.c	\
+	packet-nhrp.c		\
+	packet-nisplus.c	\
+	packet-nlm.c		\
+	packet-nlsp.c		\
+	packet-nntp.c		\
+	packet-nsip.c		\
+	packet-nsrp.c		\
+	packet-nt-oui.c		\
+	packet-nt-sonmp.c	\
+	packet-nt-tpcp.c	\
+	packet-ntlmssp.c	\
+	packet-ntp.c		\
+	packet-null.c		\
+	packet-oicq.c		\
+	packet-olsr.c		\
+	packet-omapi.c		\
+	packet-osi-options.c	\
+	packet-osi.c		\
+	packet-ositp.c		\
+	packet-ospf.c		\
+	packet-pana.c		\
+	packet-p_mul.c		\
+	packet-pagp.c		\
+	packet-pcep.c		\
+	packet-pcnfsd.c		\
+	packet-per.c		\
+	packet-pflog.c		\
+	packet-pgm.c		\
+	packet-pim.c		\
+	packet-pingpongprotocol.c	\
+	packet-pktgen.c		\
+	packet-pktc.c		\
+	packet-pop.c		\
+	packet-portmap.c	\
+	packet-pgsql.c		\
+	packet-ppi.c		\
+	packet-ppp.c		\
+	packet-pppoe.c		\
+	packet-pptp.c		\
+	packet-prp.c		\
+	packet-ptp.c		\
+	packet-pvfs2.c		\
+	packet-pw-eth.c   	\
+	packet-q2931.c		\
+	packet-q931.c		\
+	packet-q933.c		\
+	packet-qllc.c		\
+	packet-quake.c		\
+	packet-quake2.c		\
+	packet-quake3.c		\
+	packet-quakeworld.c	\
+	packet-radius.c		\
+	packet-radius_packetcable.c	\
+	packet-radiotap.c	\
+	packet-raw.c		\
+	packet-rdm.c		\
+	packet-rdt.c		\
+	packet-redback.c 	\
+	packet-redbackli.c 	\
+	packet-retix-bpdu.c 	\
+	packet-rfc2190.c 	\
+	packet-rgmp.c		\
+	packet-rip.c		\
+	packet-ripng.c		\
+	packet-rlc-lte.c		\
+	packet-rlogin.c		\
+	packet-rmcp.c		\
+	packet-rmi.c		\
+	packet-rmp.c		\
+	packet-rmt-alc.c	\
+	packet-rmt-common.c	\
+	packet-rmt-fec.c	\
+	packet-rmt-lct.c	\
+	packet-rmt-norm.c	\
+	packet-roofnet.c 	\
+	packet-rpc.c		\
+	packet-rpcap.c		\
+	packet-rpl.c		\
+	packet-rquota.c		\
+	packet-rsh.c		\
+	packet-rsl.c		\
+	packet-rstat.c		\
+	packet-rsvp.c		\
+	packet-rsync.c		\
+	packet-rtcp.c		\
+	packet-rtmpt.c		\
+	packet-rtp-events.c	\
+	packet-rtp.c		\
+	packet-rtps.c		\
+	packet-rtps2.c		\
+	packet-rtsp.c		\
+	packet-rwall.c		\
+	packet-rx.c		\
+	packet-s5066.c		\
+	packet-sadmind.c	\
+	packet-sap.c		\
+	packet-sccpmg.c		\
+	packet-scsi.c		\
+	packet-scsi-mmc.c	\
+	packet-scsi-sbc.c	\
+	packet-scsi-smc.c	\
+	packet-scsi-ssc.c	\
+	packet-sdlc.c		\
+	packet-sdp.c		\
+	packet-sebek.c		\
+	packet-ses.c		\
+	packet-sflow.c		\
+	packet-simulcrypt.c	\
+	packet-sip.c		\
+	packet-sigcomp.c	\
+	packet-sipfrag.c	\
+	packet-sita.c		\
+	packet-skinny.c		\
+	packet-slimp3.c		\
+	packet-sll.c		\
+	packet-slowprotocols.c	\
+	packet-slsk.c		\
+	packet-smb-browse.c	\
+	packet-smb-common.c	\
+	packet-smb-logon.c	\
+	packet-smb-mailslot.c	\
+	packet-smb-pipe.c	\
+	packet-smb-sidsnooping.c	\
+	packet-smb.c		\
+	packet-smb2.c		\
+	packet-smpp.c		\
+	packet-smtp.c		\
+	packet-sna.c		\
+	packet-snaeth.c		\
+	packet-sndcp.c		\
+	packet-sndcp-xid.c	\
+	packet-socks.c		\
+	packet-nasdaq-soup.c	\
+	packet-spp.c		\
+	packet-spray.c		\
+	packet-srp.c		\
+	packet-sscf-nni.c	\
+	packet-srvloc.c		\
+	packet-sscop.c		\
+	packet-scriptingservice.c \
+	packet-ssh.c		\
+	packet-ssl.c		\
+	packet-ssl-utils.c	\
+	packet-starteam.c	\
+	packet-stat-notify.c	\
+	packet-stat.c		\
+	packet-stun.c		\
+	packet-stun2.c		\
+	packet-sua.c		\
+	packet-symantec.c	\
+	packet-synergy.c 	\
+	packet-syslog.c		\
+	packet-t30.c		\
+	packet-t38.c		\
+	packet-tacacs.c		\
+	packet-tali.c		\
+	packet-tapa.c		\
+	packet-tcp.c		\
+	packet-tds.c		\
+	packet-teamspeak2.c	\
+	packet-teimanagement.c	\
+	packet-telnet.c		\
+	packet-teredo.c		\
+	packet-text-media.c	\
+	packet-telkonet.c	\
+	packet-tftp.c		\
+	packet-time.c		\
+	packet-tipc.c		\
+	packet-tivoconnect.c	\
+	packet-tnef.c		\
+	packet-tns.c		\
+	packet-tpkt.c		\
+	packet-tpncp.c	\
+	packet-tr.c		\
+	packet-trmac.c		\
+	packet-tsp.c		\
+	packet-tte.c		\
+	packet-tte-pcf.c	\
+	packet-turbocell.c	\
+	packet-turnchannel.c	\
+	packet-tuxedo.c		\
+	packet-tzsp.c		\
+	packet-ucp.c		\
+	packet-udld.c		\
+	packet-uma.c		\
+	packet-udp.c		\
+	packet-usb.c		\
+	packet-usb-masstorage.c	\
+	packet-umts_fp.c	\
+	packet-uts.c		\
+	packet-v120.c		\
+	packet-vicp.c		\
+	packet-vines.c		\
+	packet-vj.c		\
+	packet-vlan.c		\
+	packet-vnc.c		\
+	packet-vrrp.c		\
+	packet-vtp.c		\
+	packet-wap.c		\
+	packet-wbxml.c		\
+	packet-wccp.c		\
+	packet-wcp.c		\
+	packet-wfleet-hdlc.c	\
+	packet-who.c		\
+	packet-windows-common.c	\
+	packet-winsrepl.c	\
+	packet-wlccp.c		\
+	packet-wol.c		\
+	packet-wps.c		\
+	packet-wsmp.c		\
+	packet-wsp.c		\
+	packet-wtls.c		\
+	packet-wtp.c		\
+	packet-x11.c		\
+	packet-x25.c		\
+	packet-x29.c		\
+	packet-xcsl.c		\
+	packet-xdmcp.c		\
+	packet-xml.c		\
+	packet-xot.c		\
+	packet-xtp.c		\
+	packet-xyplex.c		\
+	packet-yhoo.c		\
+	packet-ymsg.c		\
+	packet-ypbind.c		\
+	packet-yppasswd.c	\
+	packet-ypserv.c		\
+	packet-ypxfr.c		\
+	packet-zebra.c		\
+	packet-zrtp.c
+
+#
+# Dissectors with warnings.
+#
+DIRTY_DISSECTOR_SRC =	\
+	packet-k12.c 		\
+	packet-nbd.c		\
+	packet-sccp.c		\
+	packet-scsi-osd.c	\
+	packet-sctp.c		\
+	packet-user_encap.c
+
+#
+# Headers for dissectors.
+#
+DISSECTOR_INCLUDES =	\
+	$(PIDL_DISSECTOR_INCLUDES) 	\
+	packet-acn.h	\
+	packet-acp133.h	\
+	packet-acse.h	\
+	packet-actrace.h	\
+	packet-afp.h	\
+	packet-afs.h	\
+	packet-aim.h	\
+	packet-alcap.h	\
+	packet-ansi_a.h	\
+	packet-ansi_map.h	\
+	packet-ansi_tcap.h \
+	packet-ap1394.h	\
+	packet-arcnet.h	\
+	packet-arp.h	\
+	packet-atalk.h	\
+	packet-atm.h	\
+	packet-bacapp.h	\
+	packet-bat.h	\
+	packet-ber.h	\
+	packet-bgp.h	\
+	packet-bootparams.h	\
+	packet-bssap.h	\
+	packet-bssgp.h	\
+	packet-bthci_acl.h	\
+	packet-btl2cap.h	\
+	packet-camel.h	\
+	packet-chdlc.h	\
+	packet-cdt.h	\
+	packet-cfm.h	\
+	packet-cimd.h	\
+	packet-cip.h	\
+	packet-clearcase.h	\
+	packet-clip.h	\
+	packet-cmip.h \
+	packet-cmp.h	\
+	packet-cms.h	\
+	packet-crmf.h	\
+	packet-dap.h	\
+	packet-data.h	\
+	packet-dcc.h	\
+	packet-dccp.h	\
+	packet-dcerpc-browser.h	\
+	packet-dcerpc-budb.h	\
+	packet-dcerpc-butc.h	\
+	packet-dcerpc-dce122.h	\
+	packet-dcerpc-dcom.h	\
+	packet-dcerpc-dnsserver.h	\
+	packet-dcerpc-drsuapi.h	\
+	packet-dcerpc-frsapi.h	\
+	packet-dcerpc-frsrpc.h	\
+	packet-dcerpc-mapi.h	\
+	packet-dcerpc-netlogon.h	\
+	packet-dcerpc-nt.h	\
+	packet-dcerpc-pnp.h	\
+	packet-dcerpc-rras.h	\
+	packet-dcerpc-samr.h	\
+	packet-dcerpc-spoolss.h	\
+	packet-dcerpc-svcctl.h	\
+	packet-dcerpc-tapi.h	\
+	packet-dcerpc.h	\
+	packet-dcom.h	\
+	packet-dcom-dispatch.h	\
+	packet-dcm.h	\
+	packet-ddtp.h	\
+	packet-diameter.h \
+	packet-diffserv-mpls-common.h	\
+	packet-disp.h	\
+	packet-dis-enums.h	\
+	packet-dis-fields.h	\
+	packet-dis-pdus.h	\
+	packet-dns.h	\
+	packet-dop.h	\
+	packet-dsp.h	\
+	packet-erf.h	\
+	packet-dvmrp.h	\
+	packet-e164.h   \
+	packet-e212.h   \
+	packet-edonkey.h	\
+	packet-enc.h	\
+	packet-epl.h	\
+	packet-epl_v1.h	\
+	packet-esis.h	\
+	packet-ess.h	\
+	packet-eth.h	\
+	packet-fc.h	\
+	packet-fcbls.h	\
+	packet-fcct.h	\
+	packet-fcdns.h	\
+	packet-fcels.h	\
+	packet-fcfcs.h	\
+	packet-fcfzs.h	\
+	packet-fclctl.h	\
+	packet-fcp.h	\
+	packet-fcsb3.h	\
+	packet-fcswils.h	\
+	packet-fddi.h	\
+	packet-ff.h	\
+	packet-fmp.h	\
+	packet-fmp_notify.h	\
+	packet-fr.h	\
+	packet-frame.h	\
+	packet-ftam.h	\
+	packet-giop.h	\
+	packet-gnm.h	\
+	packet-gnutella.h	\
+	packet-gre.h	\
+	packet-gsm_a_common.h	\
+	packet-gsm_map.h	\
+	packet-gsm_sms.h	\
+	packet-gssapi.h	\
+	packet-gtp.h	\
+	packet-h223.h	\
+	packet-h225.h	\
+	packet-h235.h	\
+	packet-h245.h	\
+	packet-h248.h	\
+	packet-h263.h	\
+	packet-h264.h	\
+	packet-h323.h	\
+	packet-h450-ros.h	\
+	packet-hci_h1.h	\
+	packet-hci_h4.h	\
+	packet-hclnfsd.h	\
+	packet-hpext.h	\
+	packet-http.h	\
+	packet-i2c.h	\
+	packet-iax2.h	\
+	packet-idp.h	\
+	packet-ieee80211.h	\
+	packet-ieee802154.h	\
+	packet-ieee8021ah.h	\
+	packet-ieee8023.h	\
+	packet-ieee802a.h	\
+	packet-igap.h	\
+	packet-igmp.h	\
+	packet-imf.h    \
+	packet-inap.h	\
+	packet-ip.h	\
+	packet-ipdc.h	\
+	packet-ipfc.h	\
+	packet-ipmi.h	\
+	packet-ipsec.h	\
+	packet-ipv6.h	\
+	packet-ipx.h	\
+	packet-isakmp.h	\
+	packet-isis-clv.h	\
+	packet-isis-hello.h	\
+	packet-isis-lsp.h	\
+	packet-isis-snp.h	\
+	packet-isis.h	\
+	packet-isl.h	\
+	packet-isup.h	\
+	packet-jxta.h	\
+	packet-kerberos.h	\
+	packet-klm.h	\
+	packet-ldap.h	\
+	packet-ldp.h	\
+	packet-llc.h	\
+	packet-logotypecertextn.h	\
+	packet-mac-lte.h		\
+	packet-mgcp.h		\
+	packet-mikey.h	\
+	packet-mip6.h	\
+	packet-mms.h	\
+	packet-mount.h	\
+	packet-mp4ves.h		\
+	packet-mpls.h	\
+	packet-mq.h	\
+	packet-mrdisc.h	\
+	packet-msnip.h	\
+	packet-msrp.h	\
+	packet-mstp.h	\
+	packet-mtp3.h	\
+	packet-ncp-int.h	\
+	packet-ncp-nmas.h	\
+	packet-ncp-sss.h \
+	packet-ndmp.h	\
+	packet-ndps.h	\
+	packet-netbios.h	\
+	packet-nfs.h	\
+	packet-nhrp.h	\
+	packet-nisplus.h	\
+	packet-nlm.h	\
+	packet-ntlmssp.h	\
+	packet-ntp.h	\
+	packet-null.h	\
+	packet-ocsp.h	\
+	packet-osi-options.h	\
+	packet-osi.h	\
+	packet-p7.h \
+	packet-pcnfsd.h	\
+	packet-pdcp.h	\
+	packet-per.h	\
+	packet-pflog.h	\
+	packet-pim.h	\
+	packet-pkcs1.h	\
+	packet-pkcs12.h	\
+	packet-pkix1explicit.h	\
+	packet-pkix1implicit.h	\
+	packet-pkixproxy.h	\
+	packet-pkixqualified.h	\
+	packet-pkixtsp.h	\
+	packet-pkinit.h	\
+	packet-pktc.h	\
+	packet-portmap.h	\
+	packet-ppi.h		\
+	packet-ppp.h	\
+	packet-pres.h	\
+	packet-q931.h	\
+	packet-q932.h	\
+	packet-qsig.h	\
+	packet-radiotap.h	\
+	packet-radius.h	\
+	packet-ranap.h	\
+	packet-raw.h	\
+	packet-rdt.h	\
+	packet-rgmp.h	\
+	packet-ripng.h	\
+	packet-rlc-lte.h		\
+	packet-rmi.h	\
+	packet-rmt-alc.h	\
+	packet-rmt-common.h	\
+	packet-rmt-fec.h	\
+	packet-rmt-lct.h	\
+	packet-rmt-norm.h	\
+	packet-ros.h	\
+	packet-rpc.h	\
+	packet-rquota.h	\
+	packet-rsvp.h	\
+	packet-rtcp.h	\
+	packet-rtp.h	\
+	packet-rtps.h   \
+	packet-rtps2.h		\
+	packet-rtp-events.h	\
+	packet-rtse.h	\
+	packet-rwall.h	\
+	packet-rx.h		\
+	packet-s4406.h	\
+	packet-sccp.h \
+	packet-scsi.h	\
+	packet-scsi-mmc.h	\
+	packet-scsi-osd.h	\
+	packet-scsi-sbc.h	\
+	packet-scsi-smc.h	\
+	packet-scsi-ssc.h	\
+	packet-sctp.h	\
+	packet-sdp.h	\
+	packet-ses.h	\
+	packet-sip.h	\
+	packet-sll.h	\
+	packet-smb.h	\
+	packet-smb2.h	\
+	packet-smb-browse.h	\
+	packet-smb-common.h	\
+	packet-smb-mailslot.h	\
+	packet-smb-pipe.h	\
+	packet-smb-sidsnooping.h	\
+	packet-smpp.h	\
+	packet-smrse.h	\
+	packet-snmp.h	\
+	packet-spray.h	\
+	packet-sscop.h \
+	packet-ssl.h	\
+	packet-ssl-utils.h	\
+	packet-stat-notify.h	\
+	packet-stat.h	\
+	packet-t30.h	\
+	packet-t38.h	\
+	packet-tacacs.h	\
+	packet-tcap.h	\
+	packet-tcp.h	\
+	packet-tns.h	\
+	packet-tpkt.h	\
+	packet-tr.h	\
+	packet-tte.h \
+	packet-udp.h	\
+	packet-umts_fp.h	\
+	packet-usb.h	\
+	packet-vines.h	\
+	packet-vlan.h	\
+	packet-wap.h	\
+	packet-wccp.h	\
+	packet-windows-common.h	\
+	packet-wlancertextn.h	\
+	packet-wps.h	\
+	packet-wsp.h	\
+	packet-wtls.h	\
+	packet-wtp.h	\
+	packet-x11-keysym.h	\
+	packet-x11-keysymdef.h	\
+	packet-x411.h	\
+	packet-x420.h	\
+	packet-x509af.h	\
+	packet-x509ce.h	\
+	packet-x509if.h	\
+	packet-x509sat.h	\
+	packet-xml.h	\
+	packet-xtp.h	\
+	packet-ypbind.h	\
+	packet-yppasswd.h	\
+	packet-ypserv.h	\
+	packet-ypxfr.h	\
+	rpc_defrag.h	\
+	$(GENERATED_HEADER_FILES) \
+	$(CUSTOM_HEADER_FILES)
+
+# IPMI sub-parsers for each network function code
+IPMI_SUBPARSERS = \
+	packet-ipmi-app.c	\
+	packet-ipmi-bridge.c	\
+	packet-ipmi-chassis.c	\
+	packet-ipmi-picmg.c	\
+	packet-ipmi-se.c	\
+	packet-ipmi-storage.c	\
+	packet-ipmi-transport.c \
+	packet-ipmi-pps.c	\
+	packet-ipmi-update.c
+
+# Dissector helpers.  They're included in the source files in this
+# directory, but they're not dissectors themselves, i.e. they're not
+# used to generate "register.c").
+DISSECTOR_SUPPORT_SRC =	\
+	$(IPMI_SUBPARSERS) \
+	packet-dcerpc-nt.c \
+	register.c
+
+# this target needed for distribution only
+noinst_HEADERS =	\
+	$(DISSECTOR_INCLUDES)
+
+ALL_DISSECTORS_SRC = \
+	$(DISSECTOR_SRC) \
+	$(DIRTY_DISSECTOR_SRC) \
+	$(PIDL_DISSECTOR_SRC) \
+	$(DIRTY_PIDL_DISSECTOR_SRC) \
+	$(ASN1_DISSECTOR_SRC) \
+	$(DIRTY_ASN1_DISSECTOR_SRC) \
+	$(CUSTOM_DISSECTOR_SRC)
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/dissectors/packet-hip.c wireshark-1.1.2-hip/epan/dissectors/packet-hip.c
--- wireshark-1.1.2-orig/epan/dissectors/packet-hip.c	1970-01-01 02:00:00.000000000 +0200
+++ wireshark-1.1.2-hip/epan/dissectors/packet-hip.c	2009-02-17 09:34:35.000000000 +0200
@@ -0,0 +1,1341 @@
+/* packet-hip.c
+ * Routines for HIP packet disassembly
+ *
+ * 07/2008 Type 2 locator and CERT parameter upto date also added some NAT/RELAY stuff
+ * 03/2006 draft-ietf-hip-base-05, -esp-02, -mm-03, -registration-01, -rvs-04
+ * 07/2005 draft-ietf-hip-base-03, -esp-00, and -mm-02
+ * 03/2005 draft-ietf-hip-base-01
+ * 11/2004 RSA and draft-ietf-hip-mm-00
+ * 09/2004 draft-nikander-hip-mm-02
+ * 07/2004 draft-ietf-hip-base-00
+ * 02/2004
+ * 03/2003
+ *
+ * Jeff Ahrenholz <jeffrey.m.ahrenholz@boeing.com>
+ * Thomas Henderson <thomas.r.henderson@boeing.com>
+ * Samu Varjonen <samu.varjonen@hiit.fi>
+ * Thomas Jansen <mithi@mithi.net>
+ * 
+ * Packet dissector for Host Identity Protocol (HIP) packets.
+ * This tool displays the TLV structure, verifies checksums,
+ * and shows NULL encrypted parameters, but will not verify 
+ * signatures or decode encrypted parameters.
+ *
+ * $Id: ethereal-0.99.0-hip-base05.patch,v 1.1 2006/05/16 21:37:14 tom_henderson Exp $
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+ 
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+#include <epan/packet.h>
+#include <epan/addr_resolv.h>
+#include <epan/conversation.h>
+
+#include "ipproto.h"
+#include "in_cksum.h"
+#include "prefs.h"
+
+#include "packet-ip.h"
+#include "packet-hip.h"
+
+static int proto_hip = -1;
+static int hf_hip_proto = -1;
+static int hf_hip_hdr_len = -1;
+static int hf_hip_packet_type = -1;
+static int hf_hip_version = -1;
+static int hf_hip_res = -1;
+static int hf_hip_controls = -1;
+static int hf_hip_controls_cert = -1;
+static int hf_hip_controls_anon = -1;
+static int hf_hip_checksum = -1;
+static int hf_hip_hit_sndr = -1;
+static int hf_hip_hit_rcvr = -1;
+
+static int hf_hip_type = -1;
+static int hf_hip_tlv_ei_res = -1;
+static int hf_hip_tlv_ei_keyidx = -1;
+static int hf_hip_tlv_ei_oldspi = -1;
+static int hf_hip_tlv_ei_newspi = -1;
+static int hf_hip_tlv_r1_res = -1;
+static int hf_hip_tlv_r1count = -1;
+static int hf_hip_tlv_puzzle_k = -1;
+static int hf_hip_tlv_puzzle_life = -1;
+static int hf_hip_tlv_puzzle_o = -1;
+static int hf_hip_tlv_puzzle_i = -1;
+static int hf_hip_tlv_puzzle_j = -1;
+static int hf_hip_tlv_seq_updid = -1;
+static int hf_hip_tlv_ack_updid = -1;
+static int hf_hip_tlv_dh_group_id = -1;
+static int hf_hip_tlv_dh_pub = -1;
+static int hf_hip_tlv_trans_id = -1;
+static int hf_hip_tlv_esp_reserved = -1;
+static int hf_hip_tlv_host_id_len = -1;
+static int hf_hip_tlv_host_di_type = -1;
+static int hf_hip_tlv_host_di_len = -1;
+static int hf_hip_tlv_host_id_hdr = -1;
+static int hf_hip_tlv_host_id_hdr_flags = -1;
+static int hf_hip_tlv_host_id_hdr_proto = -1;
+static int hf_hip_tlv_host_id_hdr_alg = -1;
+static int hf_hip_tlv_host_id_t = -1;
+static int hf_hip_tlv_host_id_q = -1;
+static int hf_hip_tlv_host_id_p = -1;
+static int hf_hip_tlv_host_id_g = -1;
+static int hf_hip_tlv_host_id_y = -1;
+static int hf_hip_tlv_host_id_e_len = -1;
+static int hf_hip_tlv_host_id_e = -1;
+static int hf_hip_tlv_host_id_n = -1;
+static int hf_hip_tlv_cert_group = -1;
+static int hf_hip_tlv_cert_count = -1;
+static int hf_hip_tlv_cert_id = -1;
+static int hf_hip_tlv_cert_type = -1;
+static int hf_hip_tlv_certificate = -1;
+static int hf_hip_tlv_notify_res = -1;
+static int hf_hip_tlv_notify_type = -1;
+static int hf_hip_tlv_notify_data = -1;
+static int hf_hip_tlv_opaque_data = -1;
+static int hf_hip_tlv_reg_ltmin = -1;
+static int hf_hip_tlv_reg_ltmax = -1;
+static int hf_hip_tlv_reg_lt = -1;
+static int hf_hip_tlv_reg_type = -1;
+static int hf_hip_tlv_reg_failtype = -1;
+static int hf_hip_tlv_hmac = -1;
+static int hf_hip_tlv_sig_alg = -1;
+static int hf_hip_tlv_sig = -1;
+static int hf_hip_tlv_id = -1;
+static int hf_hip_tlv_enc_reserved = -1;
+static int hf_hip_tlv_enc_iv = -1;
+static int hf_hip_tlv_locator_traffic_type = -1;
+static int hf_hip_tlv_locator_type = -1;
+static int hf_hip_tlv_locator_len = -1;
+static int hf_hip_tlv_locator_reserved = -1;
+static int hf_hip_tlv_locator_lifetime = -1;
+static int hf_hip_tlv_locator_port = -1;
+static int hf_hip_tlv_locator_transport_protocol = -1;
+static int hf_hip_tlv_locator_kind = -1;
+static int hf_hip_tlv_locator_priority = -1;
+static int hf_hip_tlv_locator_spi = -1;
+static int hip_transform = 0;
+static int hf_hip_tlv_nat_transform = -1;
+static int hf_hip_tlv_relay_from_port = -1;
+static int hf_hip_tlv_relay_from_transport = -1;
+static int hf_hip_tlv_relay_to_port = -1;
+static int hf_hip_tlv_relay_to_transport = -1;
+static int hf_hip_tlv_reg_from_port = -1;
+static int hf_hip_tlv_reg_from_transport = -1;
+
+static gint ett_hip = -1;
+static gint ett_hip_controls = -1;
+static gint ett_hip_tlv = -1;
+static gint ett_hip_tlv_data = -1;
+static gint ett_hip_tlv_host_id_hdr = -1;
+
+/* Place HIP summary in protocol tree */
+static gboolean hip_summary_in_tree = TRUE;
+
+/*
+ * Dissect the HIP packet 
+ */
+static void
+dissect_hip(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+    proto_tree *hip_tree, *hip_tlv_tree=NULL;
+    proto_item *ti, *ti_tlv;
+    hiphdr hiph;
+    tlv_head tlv;
+    int length, offset = 0;
+    guint16 control_h, checksum_h, computed_checksum;
+    guint16 tlv_type_h, tlv_length_h; /* For storing in host order */
+    vec_t cksum_vec[4];
+    guint32 phdr[2];
+ 
+    /*
+     * load the top pane info. This should be overwritten by
+     * the next protocol in the stack
+     */
+    if (check_col(pinfo->cinfo, COL_PROTOCOL))
+        col_set_str(pinfo->cinfo, COL_PROTOCOL, "HIP");
+    if (check_col(pinfo->cinfo, COL_INFO))
+        col_clear(pinfo->cinfo, COL_INFO);
+
+    /* Convert control and checksum to host order */
+
+    tvb_memcpy(tvb, (guint8 *)&hiph, 0, sizeof(hiphdr));
+    control_h = g_ntohs(hiph.control);
+    checksum_h = g_ntohs(hiph.checksum);
+
+    if (check_col(pinfo->cinfo, COL_INFO)) {
+        switch (hiph.packet_type) {
+            case HIP_I1:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP I1 (HIP Initiator Packet)");
+                break;
+            case HIP_R1:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP R1 (HIP Responder Packet)");
+                break;
+            case HIP_I2:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP I2 (Second HIP Initiator Packet)");
+                break;
+            case HIP_R2:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP R2 (Second HIP Responder Packet)");
+                break;
+            case UPDATE:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP UPDATE (HIP Update Packet)");
+                break;
+            // Removed from RFC a long time ago
+            case CER:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP CER (HIP Certificate Packet (NOT IN RFC))");
+                break;
+            case BOS:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP BOS (HIP Bootstrap Packet)");
+                break;
+            case NOTIFY:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP NOTIFY (HIP Notification Packet)");
+                break;
+            case CLOSE:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP CLOSE (HIP Close Packet)");
+                break;
+            case CLOSE_ACK:
+                col_add_fstr(pinfo->cinfo, COL_INFO,
+			"HIP CLOSE_ACK (HIP Close Acknowledgement Packet)");
+                break;
+            default:
+                col_add_fstr(pinfo->cinfo, COL_INFO, "HIP Unknown type");
+                break;
+        }
+    }
+
+    /*
+     * populate a tree in the second pane with the status of the link layer
+     * (ie none)
+     */
+    if(tree) {
+	if (hip_summary_in_tree) {
+            ti = proto_tree_add_protocol_format(tree, proto_hip, tvb, 0, -1, 
+                                                "Host Identity Protocol");
+	} else {
+            ti = proto_tree_add_item(tree, proto_hip, tvb, 0, -1, FALSE);
+        }
+
+        hip_tree = proto_item_add_subtree(ti, ett_hip);
+	proto_tree_add_uint(hip_tree, hf_hip_proto, tvb, offset, 1, hiph.proto);
+	proto_tree_add_uint(hip_tree, hf_hip_hdr_len, tvb, offset+1, 1, hiph.hdr_len);
+	proto_tree_add_uint(hip_tree, hf_hip_packet_type, tvb, offset+2, 1, 
+                            hiph.packet_type);
+	proto_tree_add_uint_format(hip_tree, hf_hip_version, tvb, offset+3, 1, hiph.version,
+		"Version: %u, Reserved: %u", hiph.version, hiph.res);
+	ti = proto_tree_add_uint(hip_tree, hf_hip_controls, tvb, offset+4, 2, control_h);
+	if (ti) { /* HIP Controls subtree*/
+		ti = proto_item_add_subtree(ti, ett_hip_controls);
+		proto_tree_add_boolean(ti, hf_hip_controls_cert, tvb, 
+                                       offset+5,1, control_h);
+		proto_tree_add_boolean(ti, hf_hip_controls_anon, tvb, 
+                                       offset+5,1, control_h);
+	}
+	
+	
+	/* Checksum - this is the same algorithm from UDP, ICMPv6 */
+	if (!pinfo->fragmented) {
+	    /* IPv4 or IPv6 addresses */
+	    cksum_vec[0].ptr = pinfo->src.data;
+	    cksum_vec[0].len = pinfo->src.len;
+	    cksum_vec[1].ptr = pinfo->dst.data;
+	    cksum_vec[1].len = pinfo->dst.len;
+	    /* the rest of the pseudo-header */
+	    if (pinfo->src.type == AT_IPv6) {
+		cksum_vec[2].ptr = (const guint8 *)&phdr;
+		phdr[0] = g_htonl(tvb_reported_length(tvb));
+		phdr[1] = g_htonl(IP_PROTO_HIP);
+		cksum_vec[2].len = 8;
+	    } else {
+		cksum_vec[2].ptr = (const guint8 *)&phdr;
+		phdr[0] = g_htonl((IP_PROTO_HIP<<16)+tvb_reported_length(tvb));
+		cksum_vec[2].len = 4;
+	    }
+	    /* pointer to the HIP header (packet data) */
+	    cksum_vec[3].len = tvb_reported_length(tvb);
+	    cksum_vec[3].ptr = tvb_get_ptr(tvb, 0, cksum_vec[3].len);
+	    computed_checksum = in_cksum(cksum_vec, 4);
+	    if (computed_checksum == 0) {
+		proto_tree_add_uint_format(hip_tree, hf_hip_checksum, tvb, 
+			offset+6, 2, checksum_h, "Checksum: 0x%04x (correct)",
+			checksum_h);
+	    } else {
+		proto_tree_add_uint_format(hip_tree, hf_hip_checksum, tvb,
+			offset+6, 2, checksum_h,
+			"Checksum: 0x%04x (incorrect, should be 0x%04x)",
+			checksum_h,
+			in_cksum_shouldbe(checksum_h, computed_checksum));
+	    }
+	} else {
+		proto_tree_add_uint_format(hip_tree, hf_hip_checksum, tvb,
+			offset+6, 2, checksum_h,"Checksum: 0x%04x (unverified)",
+			checksum_h);
+	}
+	offset += 8;
+	proto_tree_add_bytes(hip_tree, hf_hip_hit_sndr, tvb, offset, 
+                             sizeof(hip_hit), hiph.hit_sndr);
+	offset += sizeof(hip_hit);
+	proto_tree_add_bytes(hip_tree, hf_hip_hit_rcvr, tvb, offset, 
+                             sizeof(hip_hit), hiph.hit_rcvr);
+	offset += sizeof(hip_hit);
+	
+	length = (hiph.hdr_len+1)*8;
+	/* Begin TLV parsing */
+	if (offset < length) {
+	    ti_tlv = proto_tree_add_text(hip_tree, tvb, offset, 
+                                         tvb_length(tvb), "HIP Parameters");
+	    hip_tlv_tree = proto_item_add_subtree(ti_tlv, ett_hip_tlv);
+	}
+	/* Parse type and length in TLV */
+	while (offset < length)
+	{
+            tvb_memcpy(tvb, (guint8 *)&tlv, offset, sizeof(tlv_head));
+	    tlv_type_h = g_ntohs(tlv.type);
+	    tlv_length_h = g_ntohs(tlv.length);
+	    ti_tlv = proto_tree_add_uint_format(hip_tlv_tree, hf_hip_type, tvb,
+		offset, 4+tlv_length_h, tlv.type, "%s (type=%u, length=%u)",
+		hip_param(tlv_type_h), tlv_type_h, tlv_length_h);
+	    
+	    /* Parse value */
+	    dissect_hip_tlv(tvb, offset, ti_tlv, tlv_type_h, tlv_length_h);
+
+	    offset += 11 + tlv_length_h - (tlv_length_h + 3) % 8;
+	}
+	
+    }
+}
+
+static void
+dissect_hip_in_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	guint32 nullbytes;
+	nullbytes = tvb_get_ntohl(tvb, 0);
+	if (nullbytes == 0)
+	{
+		tvbuff_t *newtvb = tvb_new_subset(tvb, 4, -1, -1);
+		dissect_hip(newtvb, pinfo, tree);
+	}
+}
+
+void
+proto_register_hip(void)
+{
+/* Most of this stuff is unused */
+	module_t *hip_module;
+	static hf_register_info hf[] = {
+	        { &hf_hip_proto,
+		{ "Payload Protocol", "hip.proto", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_hdr_len,
+		{ "Header Length", "hip.hdr_len", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_packet_type,
+		{ "Packet Type", "hip.packet_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_version,
+		{ "Version", "hip.version", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_res,
+		{ "Reserved", "hip.res", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_controls,
+                { "HIP Controls", "hip.controls", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_controls_cert,
+		{ "Certificate (One or more CER packets follows)", "hip.controls.c", 
+                  FT_BOOLEAN, 16, NULL, HIP_CONTROL_C_MASK, "", HFILL }},
+		
+	        { &hf_hip_controls_anon,
+		{ "Anonymous (Sender's HI is anonymous)", "hip.controls.a", 
+                  FT_BOOLEAN, 16, NULL, HIP_CONTROL_A_MASK, "", HFILL }},
+		
+	        { &hf_hip_checksum,
+		{ "Checksum", "hip.checksum", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_hit_sndr,
+		{ "Sender's HIT", "hip.hit_sndr", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_hit_rcvr,
+		{ "Receiver's HIT", "hip.hit_rcvr", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+		{ &hf_hip_type,
+		{ "Type", "hip.type", 
+                  FT_UINT16, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_r1_res,
+		{ "Reserved", "hip.tlv.r1_res", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_r1count,
+		{ "R1 Counter", "hip.tlv.r1count", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_puzzle_k,
+		{ "Puzzle Difficulty K", "hip.tlv_puzzle_k", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_puzzle_life,
+		{ "Puzzle Lifetime", "hip.tlv_puzzle_life", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_puzzle_o,
+		{ "Opaque Data", "hip.tlv_puzzle_o", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_puzzle_i,
+		{ "Puzzle Random I", "hip.tlv.puzzle_i", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_puzzle_j,
+		{ "Puzzle Solution J", "hip.tlv_puzzle_j", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+				
+	        { &hf_hip_tlv_ei_res,
+		{ "Reserved", "hip.tlv_ei_res", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_ei_keyidx,
+		{ "Keymat Index", "hip.tlv_ei_keyidx", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_ei_oldspi,
+		{ "Old SPI", "hip.tlv_ei_oldspi", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_ei_newspi,
+                { "New SPI", "hip.tlv_ei_newspi", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_seq_updid,
+		{ "Update ID", "hip.tlv_seq_updid", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+	        { &hf_hip_tlv_ack_updid,
+		{ "ACKed Peer Update ID", "hip.tlv_ack_updid", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_dh_group_id,
+		{ "Group ID", "hip.tlv.dh_group_id", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_dh_pub,
+		{ "Public Value", "hip.tlv.dh_pub", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_trans_id,
+		{ "Transform ID", "hip.tlv.trans_id", 
+                  FT_UINT16, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_esp_reserved,
+		{ "Reserved", "hip.tlv.esp_reserved", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_len,
+		{ "Host Identity Length", "hip.tlv.host_id_len", 
+                  FT_UINT16, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_di_type,
+		{ "Domain Identifier Type", "hip.tlv.host_di_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_di_len,
+		{ "Domain Identifier Length", "hip.tlv.host_di_len", 
+                  FT_UINT16, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_hdr,
+		{ "Host Identity flags", "hip.tlv.host_id_hdr", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_hdr_flags,
+		{ "Flags", "hip.tlv.host_id_hdr_flags", 
+                  FT_UINT32, BASE_HEX, VALS(hi_hdr_flags_vals), 
+                  HI_HDR_FLAGS_MASK, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_hdr_proto,
+		{ "Protocol", "hip.tlv.host_id_hdr_flags", 
+                  FT_UINT32, BASE_HEX, VALS(hi_hdr_proto_vals), 
+                  HI_HDR_PROTO_MASK, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_hdr_alg,
+		{ "Algorithm", "hip.tlv.host_id_hdr_alg", 
+                  FT_UINT32, BASE_HEX, VALS(hi_hdr_alg_vals), 
+                  HI_HDR_ALG_MASK, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_t,
+		{ "Host Identity T", "hip.tlv.host_id_t", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_q,
+		{ "Host Identity Q", "hip.tlv.host_id_q", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_p,
+		{ "Host Identity P", "hip.tlv.host_id_p", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_host_id_g,
+		{ "Host Identity G", "hip.tlv.host_id_g", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_host_id_y,
+		{ "Host Identity Y (public value)", "hip.tlv.host_id_y", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_e_len,
+		{ "RSA Host Identity e_len (exponent length)", "hip.tlv.host_id_e_len",
+                  FT_UINT16, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_e,
+		{ "RSA Host Identity e (exponent)", "hip.tlv.host_id_e", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_host_id_n,
+		{ "RSA Host Identity n (public modulus)", "hip.tlv.host_id_n", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_cert_group,
+		{ "Cert group", "hip.tlv.cert_group", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+
+		{ &hf_hip_tlv_cert_count,
+		{ "Cert count", "hip.tlv.cert_count", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_cert_id,
+		{ "Cert ID", "hip.tlv.cert_id", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_cert_type,
+		{ "Cert type", "hip.tlv.cert_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_certificate,
+		{ "Certificate", "hip.tlv.certificate", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_notify_res,
+		{ "Reserved", "hip.tlv.notify_res", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_notify_type,
+		{ "Notify Message Type", "hip.tlv.notify_type", 
+                  FT_UINT16, BASE_DEC, VALS(notify_vals), 0xFFFF, "", HFILL }},
+		
+		{ &hf_hip_tlv_notify_data,
+		{ "Notification Data", "hip.tlv.notify_data", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_opaque_data,
+		{ "Opaque Data", "hip.tlv.opaque_data", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_reg_ltmin,
+		{ "Minimum Registration Lifetime", "hip.tlv.reg_ltmin", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_reg_ltmax,
+		{ "Maximum Registration Lifetime", "hip.tlv.reg_ltmax", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_reg_lt,
+		{ "Registration Lifetime", "hip.tlv.reg_lt", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_reg_type,
+		{ "Registration Type", "hip.tlv.reg_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_reg_failtype,
+		{ "Registration Failure Type", "hip.tlv.reg_failtype", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+		{ &hf_hip_tlv_hmac,
+		{ "HMAC", "hip.tlv.hmac", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_sig_alg,
+		{ "Signature Algorithm", "hip.tlv.sig_alg", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_sig,
+		{ "Signature", "hip.tlv.sig", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_id,
+		{ "ID", "hip.tlv.id", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+		
+                { &hf_hip_tlv_enc_reserved,
+		{ "Reserved", "hip.tlv.enc_reserved", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_enc_iv,
+		{ "IV", "hip.tlv.enc_iv", 
+                  FT_BYTES, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_traffic_type,
+		{ "Traffic Type", "hip.tlv.locator_traffic_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_type,
+		{ "Locator Type", "hip.tlv.locator_type", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_len,
+		{ "Locator Length", "hip.tlv.locator_len", 
+                  FT_UINT8, BASE_DEC, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_reserved,
+		{ "Reserved | P bit", "hip.tlv.locator_reserved", 
+                  FT_UINT8, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_lifetime,
+		{ "Locator Lifetime", "hip.tlv.locator_lifetime", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_port,
+                { "Locator port", "hip.tlv.locator_port", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_transport_protocol,
+                { "Locator transport protocol", "hip.tlv.locator_transport_protocol", 
+                  FT_UINT8, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_kind,
+                { "Locator kind", "hip.tlv.locator_kind", 
+                  FT_UINT8, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_priority,
+                { "Locator priority", "hip.tlv.locator_priority", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_locator_spi,
+                { "Locator spi", "hip.tlv.locator_spi", 
+                  FT_UINT32, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_nat_transform,
+                { "Nat transform", "hip.tlv.nat_transform", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_relay_from_port,
+                { "Port", "hip.tlv.relay_from_port", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_relay_from_transport,
+                { "Transport", "hip.tlv.relay_from_port", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_relay_to_port,
+                { "Port", "hip.tlv.relay_to_port", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_relay_to_transport,
+                { "Transport", "hip.tlv.relay_to_transport", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_reg_from_port,
+                { "Port", "hip.tlv.reg_from_port", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+                { &hf_hip_tlv_reg_from_transport,
+                { "Transport", "hip.tlv.reg_from_transport", 
+                  FT_UINT16, BASE_HEX, NULL, 0x0, "", HFILL }},
+
+	};
+	static gint *ett[] = {
+		&ett_hip,
+		&ett_hip_controls,
+		&ett_hip_tlv,
+		&ett_hip_tlv_data,
+		&ett_hip_tlv_host_id_hdr,
+	};
+
+	proto_hip = proto_register_protocol("Host Identity Protocol",
+	    "HIP", "hip");
+
+	proto_register_field_array(proto_hip, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+
+	/* Register configuration preferences */
+        hip_module = prefs_register_protocol(proto_hip, NULL);
+        prefs_register_bool_preference(hip_module, "summary_in_tree",
+        "Show HIP summary in protocol tree",
+        "Whether the HIP summary line should be shown in the protocol tree",
+        &hip_summary_in_tree);
+}
+
+void
+proto_reg_handoff_hip(void)
+{
+	dissector_handle_t hip_handle;
+	dissector_handle_t hip_handle2;
+
+	hip_handle = create_dissector_handle(dissect_hip, proto_hip);
+	dissector_add("ip.proto", IP_PROTO_HIP, hip_handle);
+
+	hip_handle2 = create_dissector_handle(dissect_hip_in_udp, proto_hip);
+	dissector_add("udp.port", 50500, hip_handle2);
+	data_handle = find_dissector("data");
+}
+
+char * hip_param(int n)
+{
+    static char s[24];
+    
+    switch (n)
+    {
+	//case 0: /* sometimes extra padding */
+	//    return NULL;
+	//    break;
+	case PARAM_ESP_INFO:
+	    sprintf(s, "ESP INFO");
+	    break;
+	case PARAM_R1_COUNTER:
+	    sprintf(s, "R1 COUNTER");
+	    break;
+	case PARAM_LOCATOR:
+	    sprintf(s, "LOCATOR");
+	    break;
+	case PARAM_PUZZLE:
+	    sprintf(s, "PUZZLE");
+	    break;
+	case PARAM_SOLUTION:
+	    sprintf(s, "SOLUTION");
+	    break;
+	case PARAM_SEQ:
+	    sprintf(s, "SEQ");
+	    break;
+	case PARAM_ACK:
+	    sprintf(s, "ACK");
+	    break;
+	case PARAM_DIFFIE_HELLMAN:
+	    sprintf(s, "DIFFIE_HELLMAN");
+	    break;
+	case PARAM_HIP_TRANSFORM:
+	    sprintf(s, "HIP_TRANSFORM");
+	    break;
+	case PARAM_ENCRYPTED:
+	    sprintf(s, "ENCRYPTED");
+	    break;
+	case PARAM_HOST_ID:
+	    sprintf(s, "HOST_ID");
+	    break;
+	case PARAM_CERT:
+	    sprintf(s, "CERT");
+	    break;
+	case PARAM_NOTIFY:
+	    sprintf(s, "NOTIFY");
+	    break;
+	case PARAM_ECHO_REQUEST:
+	    sprintf(s, "ECHO_REQUEST");
+	    break;
+	case PARAM_ECHO_RESPONSE:
+	    sprintf(s, "ECHO_RESPONSE");
+	    break;
+	case PARAM_ESP_TRANSFORM:
+	    sprintf(s, "ESP_TRANSFORM");
+	    break;
+	case PARAM_HMAC:
+	    sprintf(s, "HMAC");
+	    break;
+	case PARAM_HMAC_2:
+	    sprintf(s, "HMAC_2");
+	    break;
+	case PARAM_HIP_SIGNATURE_2:
+	    sprintf(s, "HIP_SIGNATURE_2");
+	    break;
+	case PARAM_HIP_SIGNATURE:
+	    sprintf(s, "HIP_SIGNATURE");
+	    break;
+	case PARAM_ECHO_REQUEST_NOSIG:
+	    sprintf(s, "ECHO_REQUEST (No sig.)");
+	    break;
+	case PARAM_ECHO_RESPONSE_NOSIG:
+	    sprintf(s, "ECHO_RESPONSE (No sig.)");
+	    break;
+        case PARAM_NAT_TRANSFORM:
+            sprintf(s, "NAT_TRANSFORM");
+            break;
+        case PARAM_RELAY_FROM:
+            sprintf(s, "RELAY_FROM");
+            break;    
+        case PARAM_RELAY_TO:
+            sprintf(s, "RELAY_TO");
+            break;
+        case PARAM_REG_FROM:
+            sprintf(s, "REG_FROM");
+            break;
+	default: 
+	    sprintf(s, "?UNKNOWN?");
+	    break;
+    }
+
+    return s;
+}
+
+char *dh_group_id_label(int groupid)
+{
+    static char s[26];
+    switch(groupid)
+    {
+	case 0:
+	    sprintf(s, "Reserved");
+	    break;
+	case 1:
+	    sprintf(s, "384-bit group");
+	    break;
+	case 2:
+	    sprintf(s, "OAKLEY well-known group 1");
+	    break;
+	case 3:
+	    sprintf(s, "1536-bit MODP group");
+	    break;
+	case 4:
+	    sprintf(s, "3072-bit MODP group");
+	    break;
+	case 5:
+	    sprintf(s, "6144-bit MODP group");
+	    break;
+	case 6:
+	    sprintf(s, "8192-bit MODP group");
+	    break;
+	default:
+	    sprintf(s, "UNKNOWN?");
+	    break;
+    }
+    return s;
+	
+}
+	    
+char *transform_id_label(int transform)
+{
+    static char s[32];
+    switch (transform)
+    {
+	case 0:
+	    sprintf(s, "Reserved");
+	    break;
+	case 1:
+	    sprintf(s, "AES-CBC with HMAC-SHA1");
+	    break;
+	case 2:
+	    sprintf(s, "3DES-CBC with HMAC-SHA1");
+	    break;
+	case 3:
+	    sprintf(s, "3DES-CBC with HMAC-MD5");
+	    break;
+	case 4:
+	    sprintf(s, "BLOWFISH-CBC with HMAC-SHA1");
+	    break;
+	case 5:
+	    sprintf(s, "NULL with HMAC-SHA1");
+	    break;
+	case 6:
+	    sprintf(s, "NULL with HMAC-MD5");
+	    break;
+	default:
+	    sprintf(s, "UNKNOWN?");
+	    break;
+
+    }
+    return s;
+}
+
+char *sig_alg_label(int alg)
+{
+    static char s[10];
+    switch (alg)
+    {
+	case 0:
+	    sprintf(s, "Reserved");
+	    break;
+	case HI_ALG_DSA:
+	    sprintf(s, "DSA");
+	    break;
+	case HI_ALG_RSA:
+	    sprintf(s, "RSA");
+	    break;
+	default:
+	    sprintf(s, "UNKNOWN?");
+	    break;
+
+    }
+    return s;
+}
+
+	    
+int dissect_hip_tlv(tvbuff_t *tvb, int offset, proto_item *ti, int type, int tlv_len)
+{
+    proto_tree *t=NULL;
+    proto_item *ti_tlv;
+    guint8 data[512];
+    guint8 n, algorithm, reg_type;
+    guint16 trans, hi_len, di_len, di_type, e_len;
+    guint32 reserved, hi_hdr;
+    guint8 transport_proto;
+    guint8 locator_type;
+    int newoffset, newlen, hi_t;
+    
+    switch (type)
+    {
+	case PARAM_ESP_INFO:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_ei_res, tvb, offset+4, 2,
+				tvb_get_ntohs(tvb, offset+4));
+	    proto_tree_add_uint(t, hf_hip_tlv_ei_keyidx, tvb, offset+6, 2,
+				tvb_get_ntohs(tvb, offset+6));
+	    proto_tree_add_uint(t, hf_hip_tlv_ei_oldspi, tvb, offset+8, 4,
+				tvb_get_ntohl(tvb, offset+8));
+	    proto_tree_add_uint(t, hf_hip_tlv_ei_newspi, tvb, offset+12, 4,
+				tvb_get_ntohl(tvb, offset+12));
+	    break;
+	case PARAM_R1_COUNTER:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_r1_res, tvb, offset+4, 4,
+				tvb_get_ntohl(tvb, offset+4));
+	    tvb_memcpy(tvb, (guint8*)data, offset+8, 8);
+	    proto_tree_add_bytes(t, hf_hip_tlv_r1count, tvb, offset+8, 8, data);
+	    break;
+	case PARAM_LOCATOR:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    tlv_len -= 4;
+	    newoffset = offset + 4;
+	    while (tlv_len > 0) {
+	    	proto_tree_add_uint(t, hf_hip_tlv_locator_traffic_type, tvb, 
+				newoffset, 1, tvb_get_guint8(tvb, newoffset));
+		newoffset++; 
+                locator_type = tvb_get_guint8(tvb, newoffset);
+	    	proto_tree_add_uint(t, hf_hip_tlv_locator_type, tvb, 
+				newoffset, 1, locator_type);
+		newoffset++;
+	    	proto_tree_add_uint(t, hf_hip_tlv_locator_len, tvb, 
+				newoffset, 1, tvb_get_guint8(tvb, newoffset));
+                newoffset++;
+                reserved = tvb_get_guint8(tvb, newoffset);
+                proto_tree_add_uint_format(t, hf_hip_tlv_locator_reserved, tvb, 
+                                           newoffset, 1, reserved,	
+                                           "Reserved: 0x%x %s", reserved,
+                                           (reserved >> 31) ? "(Preferred)" : "");
+                newoffset++;
+                proto_tree_add_uint(t, hf_hip_tlv_locator_lifetime, tvb,
+                                    newoffset, 4, tvb_get_ntohl(tvb, newoffset));
+                newoffset += 4;
+                if (locator_type == 1 || locator_type == 0) {
+                        proto_tree_add_text(t, tvb, newoffset, 16, "Address: %s",
+                                            ip6_to_str((const struct e_in6_addr*)
+                                                       tvb_get_ptr(tvb, newoffset, 16)));
+                        newoffset += 16;
+                        tlv_len -= 24;
+                } else if (locator_type == 2) {
+                        proto_tree_add_uint(t, hf_hip_tlv_locator_port, tvb, 
+                                            newoffset, 2, tvb_get_ntohs(tvb, newoffset));
+                        newoffset += 2; 
+                        transport_proto = tvb_get_guint8(tvb, newoffset);
+                        proto_tree_add_uint_format(t, hf_hip_tlv_locator_transport_protocol,
+                                                   tvb, newoffset, 1, transport_proto,	
+                                                   "Transport protocol: 0x%x %s", 
+                                                   transport_proto,
+                                                   (transport_proto == 0) ? 
+                                                   "(UDP)" : "");
+                        newoffset++;
+                        proto_tree_add_uint(t, hf_hip_tlv_locator_kind, tvb, 
+                                            newoffset, 1, tvb_get_guint8(tvb, newoffset));
+                        newoffset++;
+                        proto_tree_add_uint(t, hf_hip_tlv_locator_priority, tvb,
+                                            newoffset, 4, tvb_get_ntohl(tvb, newoffset));
+                        newoffset += 4;                         
+                        proto_tree_add_uint(t, hf_hip_tlv_locator_spi, tvb,
+                                            newoffset, 4, tvb_get_ntohl(tvb, newoffset));
+                        newoffset += 4; 
+                        proto_tree_add_text(t, tvb, newoffset, 16, "Address: %s",
+                                            ip6_to_str((const struct e_in6_addr*)
+                                                       tvb_get_ptr(tvb, newoffset, 16)));
+                        newoffset += 16;
+                        tlv_len -= 36;                        
+                }       
+            }
+	    break;
+            case PARAM_RELAY_FROM:
+                newoffset = offset + 4;
+                proto_tree_add_text(t, tvb, newoffset, 16, "Address: %s",
+                                    ip6_to_str((const struct e_in6_addr*)
+                                               tvb_get_ptr(tvb, newoffset, 16)));
+                newoffset += 16;
+                proto_tree_add_uint(t, hf_hip_tlv_relay_from_port, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+                newoffset += 2;
+                proto_tree_add_uint(t, hf_hip_tlv_relay_from_transport, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+            break;
+            case PARAM_RELAY_TO:
+                newoffset = offset + 4;
+                proto_tree_add_text(t, tvb, newoffset, 16, "Address: %s",
+                                    ip6_to_str((const struct e_in6_addr*)
+                                               tvb_get_ptr(tvb, newoffset, 16)));
+                newoffset += 16;
+                proto_tree_add_uint(t, hf_hip_tlv_relay_to_port, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+                newoffset += 2;
+                proto_tree_add_uint(t, hf_hip_tlv_relay_to_transport, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+            break;
+            case PARAM_REG_FROM:
+                newoffset = offset + 4;
+                proto_tree_add_text(t, tvb, newoffset, 16, "Address: %s",
+                                    ip6_to_str((const struct e_in6_addr*)
+                                               tvb_get_ptr(tvb, newoffset, 16)));
+                newoffset += 16;
+                proto_tree_add_uint(t, hf_hip_tlv_reg_from_port, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+                newoffset += 2;
+                proto_tree_add_uint(t, hf_hip_tlv_reg_from_transport, tvb, offset+4, 2,
+                                    tvb_get_ntohs(tvb, newoffset));
+            break;
+	case PARAM_PUZZLE:
+	case PARAM_SOLUTION:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_puzzle_k, tvb, offset+4, 1,
+				tvb_get_guint8(tvb, offset+4));
+	    proto_tree_add_uint(t, hf_hip_tlv_puzzle_life, tvb, offset+5, 1,
+				tvb_get_guint8(tvb, offset+5));
+	    proto_tree_add_uint(t, hf_hip_tlv_puzzle_o, tvb,offset+6, 2,
+			    tvb_get_ntohs(tvb, offset+6));
+	    tvb_memcpy(tvb, (guint8*)data, offset+8, 8);
+	    proto_tree_add_bytes(t, hf_hip_tlv_puzzle_i, tvb,offset+8, 8, data);
+	    if (type == PARAM_SOLUTION) { /* solution also contains J */
+		tvb_memcpy(tvb, (guint8*)data, offset+16, 8);
+		proto_tree_add_bytes(t, hf_hip_tlv_puzzle_j, tvb, offset+16, 8,
+			data);
+	    }
+	    break;
+	case PARAM_SEQ: /* SEQ */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_seq_updid, tvb, offset+4, 4,
+				tvb_get_ntohl(tvb, offset+4));
+	    break;
+	case PARAM_ACK: /* ACK */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    newoffset = offset + 4;
+	    while (tlv_len > 0) {
+		    proto_tree_add_uint(t, hf_hip_tlv_ack_updid, tvb, newoffset,
+                                        4, tvb_get_ntohl(tvb, newoffset));
+		    newoffset += 4;
+		    tlv_len -= 4;
+	    }
+	    break;
+	case PARAM_DIFFIE_HELLMAN: /* DIFFIE_HELLMAN */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    n = tvb_get_guint8(tvb, offset+4);
+	    proto_tree_add_uint_format(t, hf_hip_tlv_dh_group_id, tvb, offset+4,
+			1, n, "%u (%s)", n, dh_group_id_label(n));
+	    tvb_memcpy(tvb, (guint8*)data, offset+5, tlv_len-1);
+	    proto_tree_add_bytes(t, hf_hip_tlv_dh_pub, tvb, offset+5, tlv_len-1,
+				data);
+	    break;
+	case PARAM_ESP_TRANSFORM: /* ESP_TRANSFORM */
+	case PARAM_HIP_TRANSFORM: /* HIP_TRANSFORM */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    /* ESP transform may have E bit*/
+	    if (type == PARAM_ESP_TRANSFORM) {
+		proto_tree_add_uint(t, hf_hip_tlv_esp_reserved, tvb,
+			offset+4, 2, tvb_get_ntohs(tvb, offset+4));
+		newoffset = offset + 6;
+		tlv_len -= 2;
+	    } else {
+	    	newoffset = offset + 4;
+		/* check for NULL as only HIP transform */
+		if (tlv_len == 2)
+			hip_transform = tvb_get_ntohs(tvb, newoffset);
+		else
+			hip_transform = 0;
+	    }
+	    while (tlv_len > 0) {
+		trans = tvb_get_ntohs(tvb, newoffset);
+	        proto_tree_add_uint_format(t, hf_hip_tlv_trans_id, tvb, 
+			newoffset, 2, trans, "%u (%s)", trans,
+			transform_id_label(trans));
+		tlv_len -= 2; /* two bytes per transform id */
+		newoffset += 2;
+            }
+	    break;
+        case PARAM_NAT_TRANSFORM:
+            t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+            proto_tree_add_uint(t, hf_hip_tlv_nat_transform, tvb, offset+4, 2,
+                                tvb_get_ntohs(tvb, offset + 4));
+            break;
+	case PARAM_ENCRYPTED: /* ENCRYPTED */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_enc_reserved, tvb, offset+4, 4,
+				tvb_get_ntohl(tvb, offset+4));
+	    if (hip_transform == 5) { /* null encryption, no IV */
+		offset += 8;
+		t = proto_item_add_subtree(t, ett_hip_tlv_data);
+	    } else { /* encrypted data */
+		tvb_memcpy(tvb, (guint8*)data, offset+8, 8);
+		proto_tree_add_bytes(t, hf_hip_tlv_enc_iv,tvb,offset+8,8,data);
+		proto_tree_add_text(t, tvb, offset+16, tlv_len-12, 
+			"Encrypted Data (%u bytes)", tlv_len-12);
+		break;
+	    }
+	case PARAM_HOST_ID: /* HOST_ID */
+	    if (type != PARAM_ENCRYPTED)
+	    	t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    /* hi_length, fqdn_length */
+	    hi_len = tvb_get_ntohs(tvb, offset+4);
+	    di_len = tvb_get_ntohs(tvb, offset+6);
+	    di_type = (di_len >> 12) & 0x000F;	/* get 4 bits for DI type */
+	    di_len = di_len & 0x0FFF;		/* 12 bits for DI length */
+	    proto_tree_add_uint(t, hf_hip_tlv_host_id_len, tvb, offset+4, 2,
+				hi_len);
+	    proto_tree_add_uint(t, hf_hip_tlv_host_di_type, tvb, offset+6, 1,
+				di_type);
+	    proto_tree_add_uint(t, hf_hip_tlv_host_di_len, tvb, offset+6, 2,
+				di_len);
+	    /* hi_hdr - first 4 bytes are 0200ff03 (RFC 2535)
+	     *   flags     2  octets
+	     *   protocol  1  octet
+	     *   algorithm 1  octet (DSA or RSA)
+	     */
+	    hi_hdr = tvb_get_ntohl(tvb, offset+8);
+	    ti_tlv = proto_tree_add_uint(t, hf_hip_tlv_host_id_hdr, tvb, offset+8, 4, hi_hdr);
+	    if (ti_tlv) {
+		ti_tlv = proto_item_add_subtree(ti_tlv,ett_hip_tlv_host_id_hdr);
+		proto_tree_add_uint(ti_tlv, hf_hip_tlv_host_id_hdr_flags, tvb, offset+8,2, hi_hdr);
+		proto_tree_add_uint(ti_tlv, hf_hip_tlv_host_id_hdr_proto, tvb, offset+10,1, hi_hdr);
+		proto_tree_add_uint(ti_tlv, hf_hip_tlv_host_id_hdr_alg, tvb, offset+11,1, hi_hdr);
+	    }
+	    algorithm = tvb_get_guint8(tvb, offset+11);
+	    switch (algorithm) {
+	    case HI_ALG_DSA:
+	    /* DSA
+	     *   T         1  octet
+	     *   Q         20  octets
+	     *   P         64 + T*8  octets
+	     *   G         64 + T*8  octets
+	     *   Y         64 + T*8  octets
+	     */
+	    	/* hi_t */
+		proto_tree_add_uint(t, hf_hip_tlv_host_id_t, tvb, offset+12, 1,
+				    tvb_get_guint8(tvb, offset+12));
+		hi_t = tvb_get_guint8(tvb, offset+12);
+		tvb_memcpy(tvb, (guint8*)data, offset+13, 20);
+		proto_tree_add_bytes(t, hf_hip_tlv_host_id_q, tvb, offset+13, 
+				     20, data);
+		newoffset = offset + 33;
+		if (hi_t > 56) /* max 4096 bits */
+		    break;
+		newlen = 64 + (hi_t * 8);
+		tvb_memcpy(tvb, (guint8*)data, newoffset, newlen);
+		proto_tree_add_bytes(t, hf_hip_tlv_host_id_p, tvb, newoffset,
+				newlen, data);
+		newoffset += newlen;
+		tvb_memcpy(tvb, (guint8*)data, newoffset, newlen);
+		proto_tree_add_bytes(t, hf_hip_tlv_host_id_g, tvb, newoffset,
+				newlen, data);
+		newoffset += newlen;
+		tvb_memcpy(tvb, (guint8*)data, newoffset, newlen);
+		proto_tree_add_bytes(t, hf_hip_tlv_host_id_y, tvb, newoffset,
+				newlen, data);
+		break;
+	    case HI_ALG_RSA:
+	    /* RSA
+	     * e_len	1 or 3 octets
+	     * e 	specified by e_len
+	     * n	variable length public modulus
+	     */
+		e_len = tvb_get_guint8(tvb, offset+12);
+		newoffset = offset+13;
+		hi_len -= 5; /* subtract RDATA + e_len */
+		if (e_len == 0) { /* e_len is 0 followed by 16-bit value */
+			e_len = tvb_get_ntohs(tvb, offset+13);
+			newoffset += 2;
+			hi_len -= 2;
+		}
+		if (e_len > 512) { /* per, RFC 3110 < 4096 bits */
+			proto_tree_add_text(t, tvb, offset+13, 2,
+					"<< e_len too large >>");
+			break;
+		}
+	    	proto_tree_add_uint(t, hf_hip_tlv_host_id_e_len, tvb, offset+12,
+				    (e_len > 255) ? 3:1, e_len);
+		proto_tree_add_bytes(t, hf_hip_tlv_host_id_e, tvb, newoffset,
+				     e_len, tvb_get_ptr(tvb, newoffset, e_len));
+		newoffset += e_len;
+		hi_len -= e_len;
+
+		if (hi_len > 512) {
+			proto_tree_add_text(t, tvb, newoffset, 1,
+					"<< Invalid HI length >>");
+			break;
+		}
+
+		/* RSA public modulus n */
+	    	proto_tree_add_bytes(t, hf_hip_tlv_host_id_n, tvb, newoffset,
+				     hi_len, tvb_get_ptr(tvb,newoffset,hi_len));
+	    break;
+	    default:
+	        proto_tree_add_text(t, tvb, offset+11, 1,
+				"Unknown algorithm type (%d).\n", algorithm);
+
+	        break;
+	    }
+	    /* FQDN */
+	    if (di_type == 0)
+		break;
+	    if (di_len > sizeof(data))
+		di_len = sizeof(data) - 1;
+	    memset(data,0,sizeof(data)); /* this null-terminates the string */
+	    tvb_memcpy(tvb, (guint8*)data, offset+16+hi_len, di_len);
+	    if (di_type == 1) {
+	    	proto_tree_add_text(t, tvb, offset+16+hi_len, di_len,
+					"FQDN: %s", data);
+	    } else if (di_type == 2) {
+	    	proto_tree_add_text(t, tvb, offset+16+hi_len, di_len,
+					"NAI: %s", data);
+	    }
+	    break;
+	case PARAM_CERT: /* CERT */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_cert_group, tvb, offset+4, 1,
+				tvb_get_guint8(tvb, offset+4));
+	    proto_tree_add_uint(t, hf_hip_tlv_cert_count, tvb, offset+5, 1,
+				tvb_get_guint8(tvb, offset+5));
+	    proto_tree_add_uint(t, hf_hip_tlv_cert_id, tvb, offset+6, 1,
+				tvb_get_guint8(tvb, offset+6));
+            proto_tree_add_uint(t, hf_hip_tlv_cert_type, tvb, offset+6, 1,
+				tvb_get_guint8(tvb, offset+6));
+	    tvb_memcpy(tvb, (guint8*)data, offset+7, tlv_len-3);
+	    proto_tree_add_bytes(t, hf_hip_tlv_certificate, tvb, offset+7,
+				tlv_len-3, data);
+	    break;
+	case PARAM_NOTIFY: /* NOTIFY */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_uint(t, hf_hip_tlv_notify_res, tvb, offset+4, 2,
+				tvb_get_ntohs(tvb, offset+4));
+	    proto_tree_add_uint(t, hf_hip_tlv_notify_type, tvb, offset+6, 2,
+				tvb_get_ntohs(tvb, offset+6));
+	    tvb_memcpy(tvb, (guint8*)data, offset+8, tlv_len-4);
+	    proto_tree_add_bytes(t, hf_hip_tlv_notify_data, tvb, offset+8,
+				tlv_len-4, data);
+	    
+	    break;
+	case PARAM_ECHO_REQUEST: /* ECHO REQUEST */
+	case PARAM_ECHO_RESPONSE: /* ECHO RESPONSE */
+	case PARAM_ECHO_REQUEST_NOSIG: /* ECHO REQUEST */
+	case PARAM_ECHO_RESPONSE_NOSIG: /* ECHO RESPONSE */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    tvb_memcpy(tvb, (guint8*)data, offset+4, tlv_len);
+	    proto_tree_add_bytes(t, hf_hip_tlv_opaque_data, tvb, offset+4,
+				tlv_len, data);
+	    break;
+	case PARAM_REG_INFO:
+	case PARAM_REG_REQUEST:
+	case PARAM_REG_RESPONSE:
+	case PARAM_REG_FAILED:
+	    /* min lt, max lt | lifetime | failuretype */
+	    if (type == PARAM_REG_INFO) { /* min lt, max lt */
+		proto_tree_add_uint(t, hf_hip_tlv_reg_ltmin, tvb, offset+4,
+				1, tvb_get_guint8(tvb, offset+4));
+		proto_tree_add_uint(t, hf_hip_tlv_reg_ltmax, tvb, offset+5,
+				1, tvb_get_guint8(tvb, offset+5));
+		newoffset = 6;
+	    } else if (type == PARAM_REG_FAILED) { /* failure type */
+		proto_tree_add_uint(t, hf_hip_tlv_reg_failtype, tvb, offset+4,
+				1, tvb_get_guint8(tvb, offset+4));
+		newoffset = 5;
+	    } else { /* lifetime */
+		proto_tree_add_uint(t, hf_hip_tlv_reg_lt, tvb, offset+4,
+				1, tvb_get_guint8(tvb, offset+4));
+		newoffset = 5;
+	    }
+	    /* reg type 1 ... n, padding */
+	    while (tlv_len > 0) {
+		reg_type = tvb_get_guint8(tvb, newoffset);
+		proto_tree_add_uint(t, hf_hip_tlv_reg_type, tvb, newoffset, 1, 
+				reg_type);
+		tlv_len--; /* one byte per registration type */
+		newoffset++;
+	    }
+	    break;
+	case PARAM_RVS_HMAC: /* RVS HMAC */
+	case PARAM_HMAC: /* HMAC */
+	case PARAM_HMAC_2: /* HMAC */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    tvb_memcpy(tvb, (guint8*)data, offset+4, tlv_len);
+	    proto_tree_add_bytes(t, hf_hip_tlv_hmac, tvb, offset+4,
+				tlv_len,data);
+	    break;
+	case PARAM_HIP_SIGNATURE_2: /* HIP_SIGNATURE_2 */
+	case PARAM_HIP_SIGNATURE: /* HIP_SIGNATURE */
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    n = tvb_get_guint8(tvb, offset+4);
+	    proto_tree_add_uint_format(t, hf_hip_tlv_sig_alg, tvb, offset+4, 1,
+				n, "%u (%s)", n, sig_alg_label(n));
+	    tvb_memcpy(tvb, (guint8*)data, offset+5, tlv_len-1);
+	    proto_tree_add_bytes(t, hf_hip_tlv_sig, tvb, offset+5, tlv_len-1,
+				data);
+	    break;
+	case PARAM_FROM:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    proto_tree_add_text(t, tvb, offset+4, 16, "Address: %s",
+			ip6_to_str((const struct e_in6_addr*)
+				tvb_get_ptr(tvb, offset+4, 16)));
+	    break;
+	case PARAM_VIA_RVS:
+	    t = proto_item_add_subtree(ti, ett_hip_tlv_data);
+	    newoffset = offset + 4;
+	    while (tlv_len > 0) {
+		proto_tree_add_text(t, tvb, newoffset, 16, "RVS Address: %s",
+			ip6_to_str((const struct e_in6_addr*)
+				tvb_get_ptr(tvb, newoffset, 16)));
+		tlv_len -= 16;
+		newoffset += 16;
+            }
+	    break;
+	default:
+	    break;
+    }
+    return (0);
+}
+
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/dissectors/packet-hip.h wireshark-1.1.2-hip/epan/dissectors/packet-hip.h
--- wireshark-1.1.2-orig/epan/dissectors/packet-hip.h	1970-01-01 02:00:00.000000000 +0200
+++ wireshark-1.1.2-hip/epan/dissectors/packet-hip.h	2009-02-17 09:34:35.000000000 +0200
@@ -0,0 +1,188 @@
+/* packet-hip.h
+ * Definitions for packet disassembly structures and routines used both by HIP.
+ *
+ * $Id: packet-hip.h 25632 2008-07-01 10:59:26Z sklvarjo $
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PACKET_HIP_H__
+#define __PACKET_HIP_H__
+
+/* This minimal structure used to get at the Type field*/
+struct newhip {
+        guint16 nextpluslen;        /* Next header, plus length */
+        guint8 hiptype;        /* Type (what we are after) */
+        guint8 hipreserved;        /* Reserved (what we are after) */
+        /*variable size*/               /* (IV and) Payload data */
+};
+ 
+/* 128-bit Host Identity Tag */
+#define HIT_BITSIZE 128
+typedef unsigned char hip_hit [HIT_BITSIZE/8];
+
+#define HI_ALG_DSA 3
+#define HI_ALG_RSA 5
+
+/* HIP packet types */
+typedef enum {
+	HIP_I1=1,
+	HIP_R1,
+	HIP_I2,
+	HIP_R2,
+	CER,	/* 5 - removed from draft-ietf-hip-base-03 */
+	BOS=11,	/* 11 - removed from draft-ietf-hip-base-01 */
+	UPDATE=16, /* 16 */
+	NOTIFY=17, /* 17 */
+	CLOSE=18,  /* 18 */
+	CLOSE_ACK=19, /* 19 */
+} HIP_PACKETS;
+
+/* HIP TLV parameters */
+/* 03/2006 draft-ietf-hip-base-05, -esp-02, -mm-03, -registration-01, -rvs-04 */
+#define PARAM_ESP_INFO			65
+#define PARAM_R1_COUNTER		128
+#define PARAM_LOCATOR			193
+
+/*
+  TBD by IANA 
+*/
+#define PARAM_NAT_TRANSFORM             194
+
+#define PARAM_PUZZLE			257
+#define PARAM_SOLUTION			321
+#define PARAM_SEQ			385
+#define PARAM_ACK			449
+#define PARAM_DIFFIE_HELLMAN		513
+#define PARAM_HIP_TRANSFORM		577
+#define PARAM_ENCRYPTED			641
+#define PARAM_HOST_ID			705
+#define PARAM_CERT			768
+#define PARAM_NOTIFY			832
+#define PARAM_ECHO_REQUEST		897
+#define PARAM_REG_INFO			930
+#define PARAM_REG_REQUEST		932
+#define PARAM_REG_RESPONSE		934
+#define PARAM_REG_FAILED		936
+#define PARAM_ECHO_RESPONSE		961
+#define PARAM_ESP_TRANSFORM		4095
+#define PARAM_TRANSFORM_LOW		2048 /* defines range for transforms */
+#define PARAM_TRANSFORM_HIGH		4095
+#define PARAM_HMAC			61505
+#define PARAM_HMAC_2			61569
+#define PARAM_HIP_SIGNATURE_2		61633
+#define PARAM_HIP_SIGNATURE		61697
+#define PARAM_ECHO_REQUEST_NOSIG	63661
+#define PARAM_ECHO_RESPONSE_NOSIG	63425
+
+/* 
+   TBD by IANA these are the numbers used by 
+   the draft-ietf-hip-nat-raversal-04.txt 
+*/
+#define PARAM_RELAY_FROM                63998
+#define PARAM_RELAY_TO                  64002
+#define PARAM_REG_FROM                  64010
+
+#define PARAM_FROM			65498
+#define PARAM_RVS_HMAC			65500
+#define PARAM_VIA_RVS			65502
+#define PARAM_CRITICAL_BIT		0x0001
+
+#define HIP_CONTROL_C_MASK	0x0002
+#define HIP_CONTROL_A_MASK	0x0001
+
+#define HI_HDR_FLAGS_MASK	0xFFFF0000
+#define HI_HDR_PROTO_MASK	0x0000FF00
+#define HI_HDR_ALG_MASK		0x000000FF
+
+const value_string hi_hdr_flags_vals[] = {
+	{ 0x0200, "key is associated with a user" },
+	{ 0x0201, "zone key" },
+	{ 0x0202, "key is associated with non-zone entity" },
+	{ 0x0, "Other" },
+};
+
+const value_string hi_hdr_proto_vals[] = {
+	{ 0x01, "key is used for TLS" },
+	{ 0x02, "key is used for email" },
+	{ 0x03, "key is used for DNS security" },
+	{ 0x04, "key is used for Oakley/IPSEC" },
+	{ 0xFF, "key is valid for any protocol" },
+	{ 0x0, NULL },
+};
+
+const value_string hi_hdr_alg_vals[] = {
+	{ 0x00, "reserved" },
+	{ 0x01, "RSA/MD5" },
+	{ 0x02, "Diffie-Hellman" },
+	{ 0x03, "DSA" },
+	{ 0x04, "elliptic curve crypto" },
+	{ 0x05, "RSA" },
+	{ 0xFF, "reserved" },
+};
+
+const value_string notify_vals[] = {
+	{ 1, "Unsupported critical parameter type" },
+	{ 7, "Invalid syntax" },
+	{ 14, "No Diffie-Hellman proposal chosen" },
+	{ 15, "Invalid Diffie-Hellman chosen" },
+	{ 16, "No HIP proposal chosen" },
+	{ 17, "Invalid HIP transform chosen" },
+	{ 18, "No ESP proposal chosen" },
+	{ 19, "Invalid ESP transform chosen" },
+	{ 24, "Authentication failed" },
+	{ 26, "Checksum failed" },
+	{ 28, "HMAC failed" },
+	{ 32, "Encryption failed" },
+	{ 40, "Invalid HIT" },
+	{ 42, "Blocked by policy" },
+	{ 44, "Server busy please retry" },
+	{ 46, "I2 acknowledgement" },
+	{ 0x0, NULL },
+};
+
+typedef struct _hiphdr {
+    guint8 proto;        /* payload protocol            */
+    guint8 hdr_len;      /* header length               */
+    guint8 packet_type;  /* packet type                 */
+    guint8 res:4,version:4; /* version, reserved        */
+    guint16 checksum;    /* checksum                    */
+    guint16 control;     /* control                     */
+    hip_hit hit_sndr;    /* Sender's Host Identity Tag  */
+    hip_hit hit_rcvr;    /* Receiver's Host Identity Tag*/
+    /* HIP parameters ...  */
+} hiphdr;
+
+typedef struct _tlv_head
+{
+    guint16 type;
+    guint16 length;
+} tlv_head;
+
+
+/* functions */
+char * hip_param(int n);
+char *dh_group_id_label(int groupid);
+char *transform_id_label(int transform);
+char *sig_alg_label(int alg);
+int dissect_hip_tlv(tvbuff_t *tvb, int offset, proto_item *ti, int type, int tlv_len);
+
+static dissector_handle_t data_handle;
+
+#endif /* packet-hip.h */
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/ipproto.h wireshark-1.1.2-hip/epan/ipproto.h
--- wireshark-1.1.2-orig/epan/ipproto.h	2009-01-15 17:28:23.000000000 +0200
+++ wireshark-1.1.2-hip/epan/ipproto.h	2009-02-17 09:34:35.000000000 +0200
@@ -185,6 +185,7 @@
 #define IP_PROTO_MIPV6          135             /* Mobile IPv6  */
 #define IP_PROTO_UDPLITE        136             /* Lightweight user datagram protocol - RFC3828 */
 #define IP_PROTO_MPLS_IN_IP     137             /* MPLS in IP - RFC4023 */
+#define IP_PROTO_HIP            139             /* Host Identity Protocol */
 #define IP_PROTO_AX4000		173		/* AX/4000 Testblock - non IANA */
 #define IP_PROTO_NCS_HEARTBEAT  224             /* Novell NCS Heartbeat - http://support.novell.com/cgi-bin/search/searchtid.cgi?/10071158.htm */
 
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/prefs.c wireshark-1.1.2-hip/epan/prefs.c
--- wireshark-1.1.2-orig/epan/prefs.c	2009-01-15 17:28:23.000000000 +0200
+++ wireshark-1.1.2-hip/epan/prefs.c	2009-02-17 09:36:06.000000000 +0200
@@ -2327,6 +2327,10 @@
         /* Handle old names for UDP preferences. */
         if (strcmp(dotp, "udp_summary_in_tree") == 0)
           pref = prefs_find_preference(module, "summary_in_tree");
+       } else if (strcmp(module->name, "hip") == 0) {
+         /* Handle old names for HIP preferences. */
+         if (strcmp(dotp, "hip_summary_in_tree") == 0)
+           pref = find_preference(module, "summary_in_tree");
       } else if (strcmp(module->name, "ndps") == 0) {
         /* Handle old names for NDPS preferences. */
         if (strcmp(dotp, "desegment_ndps") == 0)
diff -N -r -u --strip-trailing-cr wireshark-1.1.2-orig/epan/prefs.c.orig wireshark-1.1.2-hip/epan/prefs.c.orig
--- wireshark-1.1.2-orig/epan/prefs.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ wireshark-1.1.2-hip/epan/prefs.c.orig	2009-01-15 17:28:23.000000000 +0200
@@ -0,0 +1,3140 @@
+/* prefs.c
+ * Routines for handling preferences
+ *
+ * $Id: prefs.c 27166 2009-01-06 14:34:18Z rbalint $
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <glib.h>
+
+#include <epan/filesystem.h>
+#include <epan/address.h>
+#include <epan/addr_resolv.h>
+#include <epan/packet.h>
+#include <epan/prefs.h>
+#include <epan/proto.h>
+#include "cfile.h"
+#include <epan/column.h>
+#include "print.h"
+#include <wsutil/file_util.h>
+
+#include <epan/prefs-int.h>
+#include <epan/uat-int.h>
+
+/* Internal functions */
+static module_t *find_subtree(module_t *parent, const char *tilte);
+static module_t *prefs_register_module_or_subtree(module_t *parent,
+    const char *name, const char *title, const char *description, gboolean is_subtree,
+    void (*apply_cb)(void));
+static prefs_set_pref_e set_pref(gchar*, gchar*, void *);
+static gchar *put_string_list(GList *);
+static void   free_col_info(e_prefs *);
+
+#define PF_NAME		"preferences"
+#define OLD_GPF_NAME	"wireshark.conf"	/* old name for global preferences file */
+
+static gboolean prefs_initialized = FALSE;
+static gchar *gpf_path = NULL;
+
+/*
+ * XXX - variables to allow us to attempt to interpret the first
+ * "mgcp.{tcp,udp}.port" in a preferences file as
+ * "mgcp.{tcp,udp}.gateway_port" and the second as
+ * "mgcp.{tcp,udp}.callagent_port".
+ */
+static int mgcp_tcp_port_count;
+static int mgcp_udp_port_count;
+
+e_prefs prefs;
+
+static const gchar	*gui_ptree_line_style_text[] =
+	{ "NONE", "SOLID", "DOTTED", "TABBED", NULL };
+
+static const gchar	*gui_ptree_expander_style_text[] =
+	{ "NONE", "SQUARE", "TRIANGLE", "CIRCULAR", NULL };
+
+static const gchar	*gui_hex_dump_highlight_style_text[] =
+	{ "BOLD", "INVERSE", NULL };
+
+static const gchar	*gui_console_open_text[] =
+	{ "NEVER", "AUTOMATIC", "ALWAYS", NULL };
+
+static const gchar	*gui_fileopen_style_text[] =
+	{ "LAST_OPENED", "SPECIFIED", NULL };
+
+/* GTK knows of two ways representing "both", vertical and horizontal aligned.
+ * as this may not work on other guis, we use only "both" in general here */
+static const gchar	*gui_toolbar_style_text[] =
+	{ "ICONS", "TEXT", "BOTH", NULL };
+
+static const gchar	*gui_layout_content_text[] =
+	{ "NONE", "PLIST", "PDETAILS", "PBYTES", NULL };
+
+/*
+ * List of all modules with preference settings.
+ */
+static emem_tree_t *prefs_modules = NULL;
+
+/*
+ * List of all modules that should show up at the top level of the
+ * tree in the preference dialog box.
+ */
+static emem_tree_t *prefs_top_level_modules = NULL;
+
+/** Sets up memory used by proto routines. Called at program startup */
+void prefs_init(void)
+{
+  prefs_modules = pe_tree_create(EMEM_TREE_TYPE_RED_BLACK, "prefs_modules");
+  prefs_top_level_modules = pe_tree_create(EMEM_TREE_TYPE_RED_BLACK, "prefs_top_level_modules");
+}
+
+/** Frees memory used by proto routines. Called at program shutdown */
+void prefs_cleanup(void)
+{
+}
+
+/*
+ * Register a module that will have preferences.
+ * Specify the module under which to register it or NULL to register it
+ * at the top level, the name used for the module in the preferences file,
+ * the title used in the tab for it in a preferences dialog box, and a
+ * routine to call back when we apply the preferences.
+ */
+module_t *
+prefs_register_module(module_t *parent, const char *name, const char *title,
+    const char *description, void (*apply_cb)(void))
+{
+	return prefs_register_module_or_subtree(parent, name, title, description,
+	    FALSE, apply_cb);
+}
+
+/*
+ * Register a subtree that will have modules under it.
+ * Specify the module under which to register it or NULL to register it
+ * at the top level and the title used in the tab for it in a preferences
+ * dialog box.
+ */
+module_t *
+prefs_register_subtree(module_t *parent, const char *title, const char *description)
+{
+	return prefs_register_module_or_subtree(parent, NULL, title, description, TRUE,
+	    NULL);
+}
+
+static module_t *
+prefs_register_module_or_subtree(module_t *parent, const char *name,
+    const char *title, const char *description, gboolean is_subtree, void (*apply_cb)(void))
+{
+	module_t *module;
+	const char *p;
+	guchar c;
+
+	/* this module may have been created as a subtree item previously */
+	if((module = find_subtree(parent, title))) {
+	  /* the module is currently a subtree */
+	  module->name = name;
+	  module->apply_cb = apply_cb;
+	  module->description = description;
+
+	  if (prefs_find_module(name) == NULL) {
+		pe_tree_insert_string(prefs_modules, name, module, EMEM_TREE_STRING_NOCASE);
+	  }
+
+	  return module;
+	}
+
+	module = g_malloc(sizeof (module_t));
+	module->name = name;
+	module->title = title;
+	module->description = description;
+	module->apply_cb = apply_cb;
+	module->prefs = NULL;	/* no preferences, to start */
+	module->submodules = pe_tree_create(EMEM_TREE_TYPE_RED_BLACK, "prefs_submodules");
+	module->numprefs = 0;
+	module->prefs_changed = FALSE;
+	module->obsolete = FALSE;
+
+	/*
+	 * Do we have a module name?
+	 */
+	if (name != NULL) {
+		/*
+		 * Yes.
+		 * Make sure that only lower-case ASCII letters, numbers,
+		 * underscores, hyphens, and dots appear in the name.
+		 *
+		 * Crash if there is, as that's an error in the code;
+		 * you can make the title a nice string with capitalization,
+		 * white space, punctuation, etc., but the name can be used
+		 * on the command line, and shouldn't require quoting,
+		 * shifting, etc.
+		 */
+		for (p = name; (c = *p) != '\0'; p++)
+			g_assert(isascii(c) &&
+			    (islower(c) || isdigit(c) || c == '_' ||
+			     c == '-' || c == '.'));
+
+		/*
+		 * Make sure there's not already a module with that
+		 * name.  Crash if there is, as that's an error in the
+		 * code, and the code has to be fixed not to register
+		 * more than one module with the same name.
+		 *
+		 * We search the list of all modules; the subtree stuff
+		 * doesn't require preferences in subtrees to have names
+		 * that reflect the subtree they're in (that would require
+		 * protocol preferences to have a bogus "protocol.", or
+		 * something such as that, to be added to all their names).
+		 */
+		g_assert(prefs_find_module(name) == NULL);
+
+		/*
+		 * Insert this module in the list of all modules.
+		 */
+		pe_tree_insert_string(prefs_modules, name, module, EMEM_TREE_STRING_NOCASE);
+	} else {
+		/*
+		 * This has no name, just a title; check to make sure it's a
+		 * subtree, and crash if it's not.
+		 */
+		g_assert(is_subtree);
+	}
+
+	/*
+	 * Insert this module into the appropriate place in the display
+	 * tree.
+	 */
+	if (parent == NULL) {
+		/*
+		 * It goes at the top.
+		 */
+		pe_tree_insert_string(prefs_top_level_modules, title, module, EMEM_TREE_STRING_NOCASE);
+	} else {
+		/*
+		 * It goes into the list for this module.
+		 */
+		pe_tree_insert_string(parent->submodules, title, module, EMEM_TREE_STRING_NOCASE);
+	}
+
+	return module;
+}
+
+/*
+ * Register that a protocol has preferences.
+ */
+module_t *protocols_module;
+
+module_t *
+prefs_register_protocol(int id, void (*apply_cb)(void))
+{
+	protocol_t *protocol;
+
+	/*
+	 * Have we yet created the "Protocols" subtree?
+	 */
+	if (protocols_module == NULL) {
+		/*
+		 * No.  Do so.
+		 */
+		protocols_module = prefs_register_subtree(NULL, "Protocols", NULL);
+	}
+	protocol = find_protocol_by_id(id);
+	return prefs_register_module(protocols_module,
+	    proto_get_protocol_filter_name(id),
+	    proto_get_protocol_short_name(protocol),
+	    proto_get_protocol_name(id), apply_cb);
+}
+
+
+module_t *
+prefs_register_protocol_subtree(const char *subtree, int id, void (*apply_cb)(void))
+{
+	protocol_t *protocol;
+	module_t   *subtree_module;
+	module_t   *new_module;
+	char       *sep = NULL, *ptr = NULL;
+	char       *csubtree = NULL;
+
+	/*
+	 * Have we yet created the "Protocols" subtree?
+	 */
+	if (protocols_module == NULL) {
+		/*
+		 * No.  Do so.
+		 */
+		protocols_module = prefs_register_subtree(NULL, "Protocols", NULL);
+	}
+
+	subtree_module = protocols_module;
+
+	if(subtree) {
+	  /* take a copy of the buffer */
+	  ptr = csubtree = g_strdup(subtree);
+
+	  while(ptr && *ptr) {
+
+	    if((sep = strchr(ptr, '/')))
+	      *sep++ = '\0';
+
+	    if(!(new_module = find_subtree(subtree_module, ptr))) {
+	      /* create it */
+	      new_module = prefs_register_subtree(subtree_module, ptr, NULL);
+	    }
+
+	    subtree_module = new_module;
+	    ptr = sep;
+
+	  }
+
+	  /* g_free(csubtree); */
+
+	}
+
+	protocol = find_protocol_by_id(id);
+	return prefs_register_module(subtree_module,
+	    proto_get_protocol_filter_name(id),
+	    proto_get_protocol_short_name(protocol),
+	    proto_get_protocol_name(id), apply_cb);
+}
+
+
+/*
+ * Register that a protocol used to have preferences but no longer does,
+ * by creating an "obsolete" module for it.
+ */
+module_t *
+prefs_register_protocol_obsolete(int id)
+{
+	module_t *module;
+	protocol_t *protocol;
+
+	/*
+	 * Have we yet created the "Protocols" subtree?
+	 */
+	if (protocols_module == NULL) {
+		/*
+		 * No.  Do so.
+		 */
+		protocols_module = prefs_register_subtree(NULL, "Protocols", NULL);
+	}
+	protocol = find_protocol_by_id(id);
+	module = prefs_register_module(protocols_module,
+	    proto_get_protocol_filter_name(id),
+	    proto_get_protocol_short_name(protocol),
+	    proto_get_protocol_name(id), NULL);
+	module->obsolete = TRUE;
+	return module;
+}
+
+module_t *
+prefs_find_module(const char *name)
+{
+	return pe_tree_lookup_string(prefs_modules, name, EMEM_TREE_STRING_NOCASE);
+}
+
+static module_t *
+find_subtree(module_t *parent, const char *name)
+{
+	return pe_tree_lookup_string(parent ? parent->submodules : prefs_top_level_modules, name, EMEM_TREE_STRING_NOCASE);
+}
+
+/*
+ * Call a callback function, with a specified argument, for each module
+ * in a list of modules.  If the list is NULL, searches the top-level
+ * list in the display tree of modules.  If any callback returns a
+ * non-zero value, we stop and return that value, otherwise we
+ * return 0.
+ *
+ * Ignores "obsolete" modules; their sole purpose is to allow old
+ * preferences for dissectors that no longer have preferences to be
+ * silently ignored in preference files.  Does not ignore subtrees,
+ * as this can be used when walking the display tree of modules.
+ */
+
+typedef struct {
+	module_cb callback;
+	gpointer user_data;
+	guint ret;
+} call_foreach_t;
+
+static gboolean
+call_foreach_cb(void *value, void *data)
+{
+	module_t *module = (module_t*)value;
+	call_foreach_t *call_data = (call_foreach_t*)data;
+
+	if (!module->obsolete) {
+		call_data->ret = (*call_data->callback)(module, call_data->user_data);
+	}
+	return (call_data->ret != 0);
+}
+
+static guint
+prefs_module_list_foreach(emem_tree_t *module_list, module_cb callback,
+    gpointer user_data)
+{
+	call_foreach_t call_data;
+
+	if (module_list == NULL)
+		module_list = prefs_top_level_modules;
+
+	call_data.callback = callback;
+	call_data.user_data = user_data;
+	call_data.ret = 0;
+	pe_tree_foreach(module_list, call_foreach_cb, &call_data);
+	return call_data.ret;
+}
+
+/*
+ * Returns TRUE if module has any submodules
+ */
+gboolean prefs_module_has_submodules(module_t *module)
+{
+	if (module->submodules == NULL) {
+		return FALSE;
+	}
+
+	if (module->submodules->tree == NULL) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Call a callback function, with a specified argument, for each module
+ * in the list of all modules.  (This list does not include subtrees.)
+ *
+ * Ignores "obsolete" modules; their sole purpose is to allow old
+ * preferences for dissectors that no longer have preferences to be
+ * silently ignored in preference files.
+ */
+guint
+prefs_modules_foreach(module_cb callback, gpointer user_data)
+{
+	return prefs_module_list_foreach(prefs_modules, callback, user_data);
+}
+
+/*
+ * Call a callback function, with a specified argument, for each submodule
+ * of specified modules.  If the module is NULL, goes through the top-level
+ * list in the display tree of modules.
+ *
+ * Ignores "obsolete" modules; their sole purpose is to allow old
+ * preferences for dissectors that no longer have preferences to be
+ * silently ignored in preference files.  Does not ignore subtrees,
+ * as this can be used when walking the display tree of modules.
+ */
+guint
+prefs_modules_foreach_submodules(module_t *module, module_cb callback, gpointer user_data)
+{
+	return prefs_module_list_foreach((module)?module->submodules:prefs_top_level_modules, callback, user_data);
+}
+
+static gboolean
+call_apply_cb(void *value, void *data _U_)
+{
+	module_t *module = value;
+
+	if (module->obsolete)
+		return FALSE;
+	if (module->prefs_changed) {
+		if (module->apply_cb != NULL)
+			(*module->apply_cb)();
+		module->prefs_changed = FALSE;
+	}
+	return FALSE;
+}
+
+/*
+ * Call the "apply" callback function for each module if any of its
+ * preferences have changed, and then clear the flag saying its
+ * preferences have changed, as the module has been notified of that
+ * fact.
+ */
+void
+prefs_apply_all(void)
+{
+	pe_tree_foreach(prefs_modules, call_apply_cb, NULL);
+}
+
+/*
+ * Call the "apply" callback function for a specific module if any of
+ * its preferences have changed, and then clear the flag saying its
+ * preferences have changed, as the module has been notified of that
+ * fact.
+ */
+void
+prefs_apply(module_t *module)
+{
+	if (module && module->prefs_changed)
+		call_apply_cb(module, NULL);
+}
+
+/*
+ * Register a preference in a module's list of preferences.
+ * If it has a title, give it an ordinal number; otherwise, it's a
+ * preference that won't show up in the UI, so it shouldn't get an
+ * ordinal number (the ordinal should be the ordinal in the set of
+ * *visible* preferences).
+ */
+static pref_t *
+register_preference(module_t *module, const char *name, const char *title,
+    const char *description, pref_type_t type)
+{
+	pref_t *preference;
+	const gchar *p;
+
+	preference = g_malloc(sizeof (pref_t));
+	preference->name = name;
+	preference->title = title;
+	preference->description = description;
+	preference->type = type;
+	if (title != NULL)
+		preference->ordinal = module->numprefs;
+	else
+		preference->ordinal = -1;	/* no ordinal for you */
+
+	/*
+	 * Make sure that only lower-case ASCII letters, numbers,
+	 * underscores, and dots appear in the preference name.
+	 *
+	 * Crash if there is, as that's an error in the code;
+	 * you can make the title and description nice strings
+	 * with capitalization, white space, punctuation, etc.,
+	 * but the name can be used on the command line,
+	 * and shouldn't require quoting, shifting, etc.
+	 */
+	for (p = name; *p != '\0'; p++)
+		g_assert(isascii((guchar)*p) &&
+		    (islower((guchar)*p) || isdigit((guchar)*p) || *p == '_' || *p == '.'));
+
+	/*
+	 * Make sure there's not already a preference with that
+	 * name.  Crash if there is, as that's an error in the
+	 * code, and the code has to be fixed not to register
+	 * more than one preference with the same name.
+	 */
+	g_assert(prefs_find_preference(module, name) == NULL);
+
+	if (type != PREF_OBSOLETE) {
+		/*
+		 * Make sure the preference name doesn't begin with the
+		 * module name, as that's redundant and Just Silly.
+		 */
+		g_assert((strncmp(name, module->name, strlen(module->name)) != 0) ||
+			(((name[strlen(module->name)]) != '.') && ((name[strlen(module->name)]) != '_')));
+	}
+
+	/*
+	 * There isn't already one with that name, so add the
+	 * preference.
+	 */
+	module->prefs = g_list_append(module->prefs, preference);
+	if (title != NULL)
+		module->numprefs++;
+
+	return preference;
+}
+
+/*
+ * Find a preference in a module's list of preferences, given the module
+ * and the preference's name.
+ */
+static gint
+preference_match(gconstpointer a, gconstpointer b)
+{
+	const pref_t *pref = a;
+	const char *name = b;
+
+	return strcmp(name, pref->name);
+}
+
+struct preference *
+prefs_find_preference(module_t *module, const char *name)
+{
+	GList *list_entry;
+
+	list_entry = g_list_find_custom(module->prefs, name,
+	    preference_match);
+
+	if (list_entry == NULL)
+		return NULL;	/* no such preference */
+	return (struct preference *) list_entry->data;
+}
+
+/*
+ * Returns TRUE if the given protocol has registered preferences
+ */
+gboolean
+prefs_is_registered_protocol(const char *name)
+{
+	module_t *m = prefs_find_module(name);
+
+	return (m != NULL && !m->obsolete);
+}
+
+/*
+ * Returns the module title of a registered protocol
+ */
+const char *
+prefs_get_title_by_name(const char *name)
+{
+	module_t *m = prefs_find_module(name);
+
+	return (m != NULL && !m->obsolete) ? m->title : NULL;
+}
+
+/*
+ * Register a preference with an unsigned integral value.
+ */
+void
+prefs_register_uint_preference(module_t *module, const char *name,
+    const char *title, const char *description, guint base, guint *var)
+{
+	pref_t *preference;
+
+	preference = register_preference(module, name, title, description,
+	    PREF_UINT);
+	preference->varp.uint = var;
+	g_assert(base > 0 && base != 1 && base < 37);
+	preference->info.base = base;
+}
+
+/*
+ * Register a preference with an Boolean value.
+ */
+void
+prefs_register_bool_preference(module_t *module, const char *name,
+    const char *title, const char *description, gboolean *var)
+{
+	pref_t *preference;
+
+	preference = register_preference(module, name, title, description,
+	    PREF_BOOL);
+	preference->varp.boolp = var;
+}
+
+/*
+ * Register a preference with an enumerated value.
+ */
+void
+prefs_register_enum_preference(module_t *module, const char *name,
+    const char *title, const char *description, gint *var,
+    const enum_val_t *enumvals, gboolean radio_buttons)
+{
+	pref_t *preference;
+
+	preference = register_preference(module, name, title, description,
+	    PREF_ENUM);
+	preference->varp.enump = var;
+	preference->info.enum_info.enumvals = enumvals;
+	preference->info.enum_info.radio_buttons = radio_buttons;
+}
+
+/*
+ * Register a preference with a character-string value.
+ */
+void
+prefs_register_string_preference(module_t *module, const char *name,
+    const char *title, const char *description, const char **var)
+{
+	pref_t *preference;
+
+	preference = register_preference(module, name, title, description,
+	    PREF_STRING);
+
+	/*
+	 * String preference values should be non-null (as you can't
+	 * keep them null after using the preferences GUI, you can at best
+	 * have them be null strings) and freeable (as we free them
+	 * if we change them).
+	 *
+	 * If the value is a null pointer, make it a copy of a null
+	 * string, otherwise make it a copy of the value.
+	 */
+	if (*var == NULL)
+		*var = g_strdup("");
+	else
+		*var = g_strdup(*var);
+	preference->varp.string = var;
+	preference->saved_val.string = NULL;
+}
+
+/*
+ * Register a preference with a ranged value.
+ */
+void
+prefs_register_range_preference(module_t *module, const char *name,
+    const char *title, const char *description, range_t **var,
+    guint32 max_value)
+{
+	pref_t *preference;
+
+	preference = register_preference(module, name, title, description,
+					 PREF_RANGE);
+	preference->info.max_value = max_value;
+
+
+	/*
+	 * Range preference values should be non-null (as you can't
+	 * keep them null after using the preferences GUI, you can at best
+	 * have them be empty ranges) and freeable (as we free them
+	 * if we change them).
+	 *
+	 * If the value is a null pointer, make it an empty range.
+	 */
+	if (*var == NULL)
+		*var = range_empty();
+	preference->varp.range = var;
+	preference->saved_val.range = NULL;
+}
+
+/*
+ * Register a static text 'preference'.  It can be used to add explanatory
+ * text inline with other preferences in the GUI.
+ * Note: Static preferences are not saved to the preferences file.
+ */
+void prefs_register_static_text_preference(module_t *module, const char *name,
+    const char *title, const char *description)
+{
+	register_preference(module, name, title, description, PREF_STATIC_TEXT);
+}
+
+/*
+ * Register a uat 'preference'. It adds a button that opens the uat's window in the
+ * preferences tab of the module.
+ */
+extern void prefs_register_uat_preference(module_t *module,
+										  const char *name,
+										  const char *title,
+										  const char *description,
+										  void* uat) {
+
+	pref_t* preference = register_preference(module, name, title, description, PREF_UAT);
+
+	preference->varp.uat = uat;
+
+}
+
+
+
+/*
+ * Register a preference that used to be supported but no longer is.
+ */
+void
+prefs_register_obsolete_preference(module_t *module, const char *name)
+{
+	register_preference(module, name, NULL, NULL, PREF_OBSOLETE);
+}
+
+/*
+ * Call a callback function, with a specified argument, for each preference
+ * in a given module.
+ *
+ * If any of the callbacks return a non-zero value, stop and return that
+ * value, otherwise return 0.
+ */
+guint
+prefs_pref_foreach(module_t *module, pref_cb callback, gpointer user_data)
+{
+	GList *elem;
+	pref_t *pref;
+	guint ret;
+
+	for (elem = g_list_first(module->prefs); elem != NULL;
+	    elem = g_list_next(elem)) {
+		pref = elem->data;
+		if (pref->type == PREF_OBSOLETE) {
+			/*
+			 * This preference is no longer supported; it's
+			 * not a real preference, so we don't call the
+			 * callback for it (i.e., we treat it as if it
+			 * weren't found in the list of preferences,
+			 * and we weren't called in the first place).
+			 */
+			continue;
+		}
+
+		ret = (*callback)(pref, user_data);
+		if (ret != 0)
+			return ret;
+	}
+	return 0;
+}
+
+/*
+ * Register all non-dissector modules' preferences.
+ */
+void
+prefs_register_modules(void)
+{
+}
+
+/* Parse through a list of comma-separated, possibly quoted strings.
+   Return a list of the string data. */
+GList *
+prefs_get_string_list(gchar *str)
+{
+  enum { PRE_STRING, IN_QUOT, NOT_IN_QUOT };
+
+  gint      state = PRE_STRING, i = 0, j = 0;
+  gboolean  backslash = FALSE;
+  guchar    cur_c;
+  gchar    *slstr = NULL;
+  GList    *sl = NULL;
+
+  /* Allocate a buffer for the first string.   */
+  slstr = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
+  j = 0;
+
+  for (;;) {
+    cur_c = str[i];
+    if (cur_c == '\0') {
+      /* It's the end of the input, so it's the end of the string we
+         were working on, and there's no more input. */
+      if (state == IN_QUOT || backslash) {
+        /* We were in the middle of a quoted string or backslash escape,
+           and ran out of characters; that's an error.  */
+        g_free(slstr);
+        prefs_clear_string_list(sl);
+        return NULL;
+      }
+      slstr[j] = '\0';
+      sl = g_list_append(sl, slstr);
+      break;
+    }
+    if (cur_c == '"' && ! backslash) {
+      switch (state) {
+        case PRE_STRING:
+          /* We hadn't yet started processing a string; this starts the
+             string, and we're now quoting.  */
+          state = IN_QUOT;
+          break;
+        case IN_QUOT:
+          /* We're in the middle of a quoted string, and we saw a quotation
+             mark; we're no longer quoting.   */
+          state = NOT_IN_QUOT;
+          break;
+        case NOT_IN_QUOT:
+          /* We're working on a string, but haven't seen a quote; we're
+             now quoting.  */
+          state = IN_QUOT;
+          break;
+        default:
+          break;
+      }
+    } else if (cur_c == '\\' && ! backslash) {
+      /* We saw a backslash, and the previous character wasn't a
+         backslash; escape the next character.
+
+         This also means we've started a new string. */
+      backslash = TRUE;
+      if (state == PRE_STRING)
+        state = NOT_IN_QUOT;
+    } else if (cur_c == ',' && state != IN_QUOT && ! backslash) {
+      /* We saw a comma, and we're not in the middle of a quoted string
+         and it wasn't preceded by a backslash; it's the end of
+         the string we were working on...  */
+      slstr[j] = '\0';
+      sl = g_list_append(sl, slstr);
+
+      /* ...and the beginning of a new string.  */
+      state = PRE_STRING;
+      slstr = (gchar *) g_malloc(sizeof(gchar) * COL_MAX_LEN);
+      j = 0;
+    } else if (!isspace(cur_c) || state != PRE_STRING) {
+      /* Either this isn't a white-space character, or we've started a
+         string (i.e., already seen a non-white-space character for that
+         string and put it into the string).
+
+         The character is to be put into the string; do so if there's
+         room.  */
+      if (j < COL_MAX_LEN) {
+        slstr[j] = cur_c;
+        j++;
+      }
+
+      /* If it was backslash-escaped, we're done with the backslash escape.  */
+      backslash = FALSE;
+    }
+    i++;
+  }
+  return(sl);
+}
+
+#define MAX_FMT_PREF_LEN      1024
+#define MAX_FMT_PREF_LINE_LEN   60
+static gchar *
+put_string_list(GList *sl)
+{
+  static gchar  pref_str[MAX_FMT_PREF_LEN] = "";
+  GList        *clp = g_list_first(sl);
+  gchar        *str;
+  int           cur_pos = 0, cur_len = 0;
+  gchar        *quoted_str;
+  int           str_len;
+  gchar        *strp, *quoted_strp, c;
+  int           fmt_len;
+
+  while (clp) {
+    str = clp->data;
+
+    /* Allocate a buffer big enough to hold the entire string, with each
+       character quoted (that's the worst case).  */
+    str_len = strlen(str);
+    quoted_str = g_malloc(str_len*2 + 1);
+
+    /* Now quote any " or \ characters in it. */
+    strp = str;
+    quoted_strp = quoted_str;
+    while ((c = *strp++) != '\0') {
+      if (c == '"' || c == '\\') {
+        /* It has to be backslash-quoted.  */
+        *quoted_strp++ = '\\';
+      }
+      *quoted_strp++ = c;
+    }
+    *quoted_strp = '\0';
+
+    fmt_len = strlen(quoted_str) + 4;
+    if ((fmt_len + cur_len) < (MAX_FMT_PREF_LEN - 1)) {
+      if ((fmt_len + cur_pos) > MAX_FMT_PREF_LINE_LEN) {
+        /* Wrap the line.  */
+        cur_len--;
+        cur_pos = 0;
+        pref_str[cur_len] = '\n'; cur_len++;
+        pref_str[cur_len] = '\t'; cur_len++;
+      }
+      g_snprintf(&pref_str[cur_len], MAX_FMT_PREF_LEN - cur_len, "\"%s\", ", quoted_str);
+      cur_pos += fmt_len;
+      cur_len += fmt_len;
+    }
+    g_free(quoted_str);
+    clp = clp->next;
+  }
+
+  /* If the string is at least two characters long, the last two characters
+     are ", ", and should be discarded, as there are no more items in the
+     string.  */
+  if (cur_len >= 2)
+    pref_str[cur_len - 2] = '\0';
+
+  return(pref_str);
+}
+
+void
+prefs_clear_string_list(GList *sl)
+{
+  GList *l = sl;
+
+  while (l) {
+    g_free(l->data);
+    l = g_list_remove_link(l, l);
+  }
+}
+
+/*
+ * Takes a string, a pointer to an array of "enum_val_t"s, and a default gint
+ * value.
+ * The array must be terminated by an entry with a null "name" string.
+ *
+ * If the string matches a "name" string in an entry, the value from that
+ * entry is returned.
+ *
+ * Otherwise, if a string matches a "desctiption" string in an entry, the
+ * value from that entry is returned; we do that for backwards compatibility,
+ * as we used to have only a "name" string that was used both for command-line
+ * and configuration-file values and in the GUI (which meant either that
+ * the GUI had what might be somewhat cryptic values to select from or that
+ * the "-o" flag took long strings, often with spaces in them).
+ *
+ * Otherwise, the default value that was passed as the third argument is
+ * returned.
+ */
+gint
+find_val_for_string(const char *needle, const enum_val_t *haystack,
+    gint default_value)
+{
+	int i;
+
+	for (i = 0; haystack[i].name != NULL; i++) {
+		if (g_ascii_strcasecmp(needle, haystack[i].name) == 0) {
+			return haystack[i].value;
+		}
+	}
+	for (i = 0; haystack[i].name != NULL; i++) {
+		if (g_ascii_strcasecmp(needle, haystack[i].description) == 0) {
+			return haystack[i].value;
+		}
+	}
+	return default_value;
+}
+
+/* Takes an string and a pointer to an array of strings, and a default int value.
+ * The array must be terminated by a NULL string. If the string is found in the array
+ * of strings, the index of that string in the array is returned. Otherwise, the
+ * default value that was passed as the third argument is returned.
+ */
+static int
+find_index_from_string_array(char *needle, const char **haystack, int default_value)
+{
+	int i = 0;
+
+	while (haystack[i] != NULL) {
+		if (strcmp(needle, haystack[i]) == 0) {
+			return i;
+		}
+		i++;
+	}
+	return default_value;
+}
+
+/* Preferences file format:
+ * - Configuration directives start at the beginning of the line, and
+ *   are terminated with a colon.
+ * - Directives can be continued on the next line by preceding them with
+ *   whitespace.
+ *
+ * Example:
+
+# This is a comment line
+print.command: lpr
+print.file: /a/very/long/path/
+	to/wireshark-out.ps
+ *
+ */
+
+#define DEF_NUM_COLS    6
+
+/* Initialize preferences to wired-in default values.
+ * They may be overridden by the global preferences file or the
+ *  user's preferences file.
+ */
+static void
+init_prefs(void) {
+  int         i;
+  fmt_data    *cfmt;
+  const gchar *col_fmt[] = {"No.",      "%m", "Time",        "%t",
+                           "Source",   "%s", "Destination", "%d",
+                           "Protocol", "%p", "Info",        "%i"};
+
+  if (prefs_initialized)
+    return;
+
+  uat_load_all();
+
+  prefs.pr_format  = PR_FMT_TEXT;
+  prefs.pr_dest    = PR_DEST_CMD;
+  prefs.pr_file    = g_strdup("wireshark.out");
+  prefs.pr_cmd     = g_strdup("lpr");
+  prefs.col_list = NULL;
+  for (i = 0; i < DEF_NUM_COLS; i++) {
+    cfmt = (fmt_data *) g_malloc(sizeof(fmt_data));
+    cfmt->title = g_strdup(col_fmt[i * 2]);
+    cfmt->fmt   = g_strdup(col_fmt[(i * 2) + 1]);
+    cfmt->custom_field = NULL;
+    prefs.col_list = g_list_append(prefs.col_list, cfmt);
+  }
+  prefs.num_cols  = DEF_NUM_COLS;
+  prefs.st_client_fg.pixel =     0;
+  prefs.st_client_fg.red   = 32767;
+  prefs.st_client_fg.green =     0;
+  prefs.st_client_fg.blue  =     0;
+  prefs.st_client_bg.pixel =     0;
+  prefs.st_client_bg.red   = 64507;
+  prefs.st_client_bg.green = 60909;
+  prefs.st_client_bg.blue  = 60909;
+  prefs.st_server_fg.pixel =     0;
+  prefs.st_server_fg.red   =     0;
+  prefs.st_server_fg.green =     0;
+  prefs.st_server_fg.blue  = 32767;
+  prefs.st_server_bg.pixel =     0;
+  prefs.st_server_bg.red   = 60909;
+  prefs.st_server_bg.green = 60909;
+  prefs.st_server_bg.blue  = 64507;
+  prefs.gui_scrollbar_on_right = TRUE;
+  prefs.gui_plist_sel_browse = FALSE;
+  prefs.gui_ptree_sel_browse = FALSE;
+  prefs.gui_altern_colors = FALSE;
+  prefs.gui_ptree_line_style = 0;
+  prefs.gui_ptree_expander_style = 1;
+  prefs.gui_hex_dump_highlight_style = 1;
+  prefs.filter_toolbar_show_in_statusbar = FALSE;
+  prefs.gui_toolbar_main_style = TB_STYLE_ICONS;
+#ifdef _WIN32
+  prefs.gui_font_name = g_strdup("Lucida Console 10");
+#else
+  /*
+   * XXX - for now, we make the initial font name a pattern that matches
+   * only ISO 8859/1 fonts, so that we don't match 2-byte fonts such
+   * as ISO 10646 fonts.
+   *
+   * Users in locales using other one-byte fonts will have to choose
+   * a different font from the preferences dialog - or put the font
+   * selection in the global preferences file to make that font the
+   * default for all users who don't explicitly specify a different
+   * font.
+   *
+   * Making this a font set rather than a font has two problems:
+   *
+   *	1) as far as I know, you can't select font sets with the
+   *	   font selection dialog;
+   *
+   *  2) if you use a font set, the text to be drawn must be a
+   *	   multi-byte string in the appropriate locale, but
+   *	   Wireshark does *NOT* guarantee that's the case - in
+   *	   the hex-dump window, each character in the text portion
+   *	   of the display must be a *single* byte, and in the
+   *	   packet-list and protocol-tree windows, text extracted
+   *	   from the packet is not necessarily in the right format.
+   *
+   * "Doing this right" may, for the packet-list and protocol-tree
+   * windows, require that dissectors know what the locale is
+   * *AND* know what locale and text representation is used in
+   * the packets they're dissecting, and may be impossible in
+   * the hex-dump window (except by punting and displaying only
+   * ASCII characters).
+   *
+   * GTK+ 2.0 may simplify part of the problem, as it will, as I
+   * understand it, use UTF-8-encoded Unicode as its internal
+   * character set; however, we'd still have to know whatever
+   * character set and encoding is used in the packet (which
+   * may differ for different protocols, e.g. SMB might use
+   * PC code pages for some strings and Unicode for others, whilst
+   * NFS might use some UNIX character set encoding, e.g. ISO 8859/x,
+   * or one of the EUC character sets for Asian languages, or one
+   * of the other multi-byte character sets, or UTF-8, or...).
+   *
+   * I.e., as far as I can tell, "internationalizing" the packet-list,
+   * protocol-tree, and hex-dump windows involves a lot more than, say,
+   * just using font sets rather than fonts.
+   */
+  /* XXX - the above comment was about the GTK1 font stuff, just remove this comment now */
+  /* XXX- is this the correct default font name for GTK2 none win32? */
+  prefs.gui_font_name = g_strdup("Monospace 10");
+#endif
+  prefs.gui_marked_fg.pixel        =     65535;
+  prefs.gui_marked_fg.red          =     65535;
+  prefs.gui_marked_fg.green        =     65535;
+  prefs.gui_marked_fg.blue         =     65535;
+  prefs.gui_marked_bg.pixel        =         0;
+  prefs.gui_marked_bg.red          =         0;
+  prefs.gui_marked_bg.green        =         0;
+  prefs.gui_marked_bg.blue         =         0;
+  prefs.gui_colorized_fg           = g_strdup("000000,000000,000000,000000,000000,000000,000000,000000,000000,000000");
+  prefs.gui_colorized_bg           = g_strdup("ffc0c0,ffc0ff,e0c0e0,c0c0ff,c0e0e0,c0ffff,c0ffc0,ffffc0,e0e0c0,e0e0e0");
+  prefs.gui_geometry_save_position =         FALSE;
+  prefs.gui_geometry_save_size     =         TRUE;
+  prefs.gui_geometry_save_maximized=         TRUE;
+  prefs.gui_macosx_style           = TRUE;
+  prefs.gui_console_open           = console_open_never;
+  prefs.gui_fileopen_style         = FO_STYLE_LAST_OPENED;
+  prefs.gui_recent_df_entries_max  = 10;
+  prefs.gui_recent_files_count_max = 10;
+  prefs.gui_fileopen_dir           = g_strdup(get_persdatafile_dir());
+  prefs.gui_fileopen_preview       = 3;
+  prefs.gui_ask_unsaved            = TRUE;
+  prefs.gui_find_wrap              = TRUE;
+  prefs.gui_use_pref_save          = FALSE;
+  prefs.gui_webbrowser             = g_strdup(HTML_VIEWER " %s");
+  prefs.gui_window_title           = g_strdup("");
+  prefs.gui_start_title            = g_strdup("The World's Most Popular Network Protocol Analyzer");
+  prefs.gui_version_in_start_page  = FALSE;
+  prefs.gui_layout_type            = layout_type_5;
+  prefs.gui_layout_content_1       = layout_pane_content_plist;
+  prefs.gui_layout_content_2       = layout_pane_content_pdetails;
+  prefs.gui_layout_content_3       = layout_pane_content_pbytes;
+  prefs.console_log_level          =
+      G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR;
+
+/* set the default values for the capture dialog box */
+  prefs.capture_device           = NULL;
+  prefs.capture_devices_linktypes= NULL;
+  prefs.capture_devices_descr    = NULL;
+  prefs.capture_devices_hide     = NULL;
+  prefs.capture_prom_mode        = TRUE;
+  prefs.capture_real_time        = TRUE;
+  prefs.capture_auto_scroll      = TRUE;
+  prefs.capture_show_info        = FALSE;
+
+/* set the default values for the name resolution dialog box */
+  prefs.name_resolve             = RESOLV_ALL ^ RESOLV_NETWORK;
+  prefs.name_resolve_concurrency = 500;
+
+/* set the default values for the tap/statistics dialog box */
+  prefs.tap_update_interval = TAP_UPDATE_DEFAULT_INTERVAL;
+  prefs.rtp_player_max_visible = RTP_PLAYER_DEFAULT_VISIBLE;
+
+  prefs.display_hidden_proto_items = FALSE;
+
+  prefs_initialized = TRUE;
+}
+
+/* Reset preferences */
+void
+prefs_reset(void)
+{
+  prefs_initialized = FALSE;
+  if (prefs.pr_file)
+    g_free(prefs.pr_file);
+  if (prefs.pr_cmd)
+    g_free(prefs.pr_cmd);
+  free_col_info(&prefs);
+  if (prefs.gui_font_name)
+    g_free(prefs.gui_font_name);
+  if (prefs.gui_colorized_fg)
+    g_free(prefs.gui_colorized_fg);
+  if (prefs.gui_colorized_bg)
+    g_free(prefs.gui_colorized_bg);
+  if (prefs.gui_fileopen_dir)
+    g_free(prefs.gui_fileopen_dir);
+  if (prefs.gui_webbrowser)
+    g_free(prefs.gui_webbrowser);
+  if (prefs.gui_window_title)
+    g_free(prefs.gui_window_title);
+  if (prefs.gui_start_title)
+    g_free(prefs.gui_start_title);
+  if (prefs.capture_device)
+    g_free(prefs.capture_device);
+  if (prefs.capture_devices_linktypes)
+    g_free(prefs.capture_devices_linktypes);
+  if (prefs.capture_devices_descr)
+    g_free(prefs.capture_devices_descr);
+  if (prefs.capture_devices_hide)
+    g_free(prefs.capture_devices_hide);
+
+  uat_unload_all();
+  init_prefs();
+}
+
+/* Read the preferences file, fill in "prefs", and return a pointer to it.
+
+   If we got an error (other than "it doesn't exist") trying to read
+   the global preferences file, stuff the errno into "*gpf_errno_return"
+   and a pointer to the path of the file into "*gpf_path_return", and
+   return NULL.
+
+   If we got an error (other than "it doesn't exist") trying to read
+   the user's preferences file, stuff the errno into "*pf_errno_return"
+   and a pointer to the path of the file into "*pf_path_return", and
+   return NULL. */
+e_prefs *
+read_prefs(int *gpf_errno_return, int *gpf_read_errno_return,
+	   char **gpf_path_return, int *pf_errno_return,
+	   int *pf_read_errno_return, char **pf_path_return)
+{
+  int         err;
+  char        *pf_path;
+  FILE        *pf;
+
+  init_prefs();
+
+  /*
+   * If we don't already have the pathname of the global preferences
+   * file, construct it.  Then, in either case, try to open the file.
+   */
+  if (gpf_path == NULL) {
+    /*
+     * We don't have the path; try the new path first, and, if that
+     * file doesn't exist, try the old path.
+     */
+    gpf_path = get_datafile_path(PF_NAME);
+    if ((pf = ws_fopen(gpf_path, "r")) == NULL && errno == ENOENT) {
+      /*
+       * It doesn't exist by the new name; try the old name.
+       */
+      g_free(gpf_path);
+      gpf_path = get_datafile_path(OLD_GPF_NAME);
+      pf = ws_fopen(gpf_path, "r");
+    }
+  } else {
+    /*
+     * We have the path; try it.
+     */
+    pf = ws_fopen(gpf_path, "r");
+  }
+
+  /*
+   * If we were able to open the file, read it.
+   * XXX - if it failed for a reason other than "it doesn't exist",
+   * report the error.
+   */
+  *gpf_path_return = NULL;
+  if (pf != NULL) {
+    /*
+     * Start out the counters of "mgcp.{tcp,udp}.port" entries we've
+     * seen.
+     */
+    mgcp_tcp_port_count = 0;
+    mgcp_udp_port_count = 0;
+
+    /* We succeeded in opening it; read it. */
+    err = read_prefs_file(gpf_path, pf, set_pref, NULL);
+    if (err != 0) {
+      /* We had an error reading the file; return the errno and the
+         pathname, so our caller can report the error. */
+      *gpf_errno_return = 0;
+      *gpf_read_errno_return = err;
+      *gpf_path_return = gpf_path;
+    }
+    fclose(pf);
+  } else {
+    /* We failed to open it.  If we failed for some reason other than
+       "it doesn't exist", return the errno and the pathname, so our
+       caller can report the error. */
+    if (errno != ENOENT) {
+      *gpf_errno_return = errno;
+      *gpf_read_errno_return = 0;
+      *gpf_path_return = gpf_path;
+    }
+  }
+
+  /* Construct the pathname of the user's preferences file. */
+  pf_path = get_persconffile_path(PF_NAME, TRUE, FALSE);
+
+  /* Read the user's preferences file, if it exists. */
+  *pf_path_return = NULL;
+  if ((pf = ws_fopen(pf_path, "r")) != NULL) {
+    /*
+     * Start out the counters of "mgcp.{tcp,udp}.port" entries we've
+     * seen.
+     */
+    mgcp_tcp_port_count = 0;
+    mgcp_udp_port_count = 0;
+
+    /* We succeeded in opening it; read it. */
+    err = read_prefs_file(pf_path, pf, set_pref, NULL);
+    if (err != 0) {
+      /* We had an error reading the file; return the errno and the
+         pathname, so our caller can report the error. */
+      *pf_errno_return = 0;
+      *pf_read_errno_return = err;
+      *pf_path_return = pf_path;
+    } else
+      g_free(pf_path);
+    fclose(pf);
+  } else {
+    /* We failed to open it.  If we failed for some reason other than
+       "it doesn't exist", return the errno and the pathname, so our
+       caller can report the error. */
+    if (errno != ENOENT) {
+      *pf_errno_return = errno;
+      *pf_read_errno_return = 0;
+      *pf_path_return = pf_path;
+    } else
+      g_free(pf_path);
+  }
+
+  return &prefs;
+}
+
+/* read the preferences file (or similiar) and call the callback
+ * function to set each key/value pair found */
+int
+read_prefs_file(const char *pf_path, FILE *pf, pref_set_pair_cb pref_set_pair_fct, void *private_data)
+{
+  enum { START, IN_VAR, PRE_VAL, IN_VAL, IN_SKIP };
+  int       got_c, state = START;
+  GString  *cur_val;
+  GString  *cur_var;
+  gboolean  got_val = FALSE;
+  gint      fline = 1, pline = 1;
+  gchar     hint[] = "(applying your preferences once should remove this warning)";
+
+  cur_val = g_string_new("");
+  cur_var = g_string_new("");
+
+  while ((got_c = getc(pf)) != EOF) {
+    if (got_c == '\n') {
+      state = START;
+      fline++;
+      continue;
+    }
+
+    switch (state) {
+      case START:
+        if (isalnum(got_c)) {
+          if (cur_var->len > 0) {
+            if (got_val) {
+              switch (pref_set_pair_fct(cur_var->str, cur_val->str, private_data)) {
+
+              case PREFS_SET_OK:
+                break;
+
+              case PREFS_SET_SYNTAX_ERR:
+                g_warning ("%s line %d: Syntax error %s", pf_path, pline, hint);
+                break;
+
+              case PREFS_SET_NO_SUCH_PREF:
+                g_warning ("%s line %d: No such preference \"%s\" %s", pf_path,
+                                pline, cur_var->str, hint);
+                break;
+
+              case PREFS_SET_OBSOLETE:
+                /* We silently ignore attempts to set these; it's
+                   probably not the user's fault that it's in there -
+                   they may have saved preferences with a release that
+                   supported them. */
+                break;
+              }
+            } else {
+              g_warning ("%s line %d: Incomplete preference %s", pf_path, pline, hint);
+            }
+          }
+          state      = IN_VAR;
+          got_val    = FALSE;
+          g_string_truncate(cur_var, 0);
+          g_string_append_c(cur_var, (gchar) got_c);
+          pline = fline;
+        } else if (isspace(got_c) && cur_var->len > 0 && got_val) {
+          state = PRE_VAL;
+        } else if (got_c == '#') {
+          state = IN_SKIP;
+        } else {
+          g_warning ("%s line %d: Malformed line %s", pf_path, fline, hint);
+        }
+        break;
+      case IN_VAR:
+        if (got_c != ':') {
+          g_string_append_c(cur_var, (gchar) got_c);
+        } else {
+          state   = PRE_VAL;
+          g_string_truncate(cur_val, 0);
+          got_val = TRUE;
+        }
+        break;
+      case PRE_VAL:
+        if (!isspace(got_c)) {
+          state = IN_VAL;
+          g_string_append_c(cur_val, (gchar) got_c);
+        }
+        break;
+      case IN_VAL:
+	g_string_append_c(cur_val, (gchar) got_c);
+        break;
+    }
+  }
+  if (cur_var->len > 0) {
+    if (got_val) {
+      switch (pref_set_pair_fct(cur_var->str, cur_val->str, private_data)) {
+
+      case PREFS_SET_OK:
+        break;
+
+      case PREFS_SET_SYNTAX_ERR:
+        g_warning ("%s line %d: Syntax error %s", pf_path, pline, hint);
+        break;
+
+      case PREFS_SET_NO_SUCH_PREF:
+        g_warning ("%s line %d: No such preference \"%s\" %s", pf_path,
+                        pline, cur_var->str, hint);
+        break;
+
+      case PREFS_SET_OBSOLETE:
+        /* We silently ignore attempts to set these; it's probably not
+           the user's fault that it's in there - they may have saved
+           preferences with a release that supported it. */
+        break;
+      }
+    } else {
+      g_warning ("%s line %d: Incomplete preference %s", pf_path, pline, hint);
+    }
+  }
+
+  g_string_free(cur_val, TRUE);
+  g_string_free(cur_var, TRUE);
+
+  if (ferror(pf))
+    return errno;
+  else
+    return 0;
+}
+
+/*
+ * If we were handed a preference starting with "uat:", try to turn it into
+ * a valid uat entry.
+ */
+static gboolean
+prefs_set_uat_pref(char *uat_entry) {
+	gchar *p, *colonp;
+	uat_t *uat;
+	gchar *err;
+
+	colonp = strchr(uat_entry, ':');
+	if (colonp == NULL)
+		return FALSE;
+
+	p = colonp;
+	*p++ = '\0';
+
+	/*
+	 * Skip over any white space (there probably won't be any, but
+	 * as we allow it in the preferences file, we might as well
+	 * allow it here).
+	 */
+	while (isspace((guchar)*p))
+		p++;
+	if (*p == '\0') {
+		/*
+		 * Put the colon back, so if our caller uses, in an
+		 * error message, the string they passed us, the message
+		 * looks correct.
+		 */
+		*colonp = ':';
+		return FALSE;
+	}
+
+	uat = uat_find(uat_entry);
+	*colonp = ':';
+	if (uat == NULL) {
+		return FALSE;
+	}
+
+	if (uat_load_str(uat, p, &err)) {
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/*
+ * Given a string of the form "<pref name>:<pref value>", as might appear
+ * as an argument to a "-o" option, parse it and set the preference in
+ * question.  Return an indication of whether it succeeded or failed
+ * in some fashion.
+ */
+prefs_set_pref_e
+prefs_set_pref(char *prefarg)
+{
+	gchar *p, *colonp;
+	prefs_set_pref_e ret;
+
+	/*
+	 * Set the counters of "mgcp.{tcp,udp}.port" entries we've
+	 * seen to values that keep us from trying to interpret tham
+	 * as "mgcp.{tcp,udp}.gateway_port" or "mgcp.{tcp,udp}.callagent_port",
+	 * as, from the command line, we have no way of guessing which
+	 * the user had in mind.
+	 */
+	mgcp_tcp_port_count = -1;
+	mgcp_udp_port_count = -1;
+
+	colonp = strchr(prefarg, ':');
+	if (colonp == NULL)
+		return PREFS_SET_SYNTAX_ERR;
+
+	p = colonp;
+	*p++ = '\0';
+
+	/*
+	 * Skip over any white space (there probably won't be any, but
+	 * as we allow it in the preferences file, we might as well
+	 * allow it here).
+	 */
+	while (isspace((guchar)*p))
+		p++;
+	if (*p == '\0') {
+		/*
+		 * Put the colon back, so if our caller uses, in an
+		 * error message, the string they passed us, the message
+		 * looks correct.
+		 */
+		*colonp = ':';
+		return PREFS_SET_SYNTAX_ERR;
+	}
+	if (strcmp(prefarg, "uat")) {
+		ret = set_pref(prefarg, p, NULL);
+	} else {
+		ret = prefs_set_uat_pref(p) ? PREFS_SET_OK : PREFS_SET_SYNTAX_ERR;
+	}
+	*colonp = ':';	/* put the colon back */
+	return ret;
+}
+
+/*
+ * Returns TRUE if the given device is hidden
+ */
+gboolean
+prefs_is_capture_device_hidden(const char *name)
+{
+	gchar *tok, *devices;
+	size_t len;
+
+	if (prefs.capture_devices_hide && name) {
+		devices = g_strdup (prefs.capture_devices_hide);
+		len = strlen (name);
+		for (tok = strtok (devices, ","); tok; tok = strtok(NULL, ",")) {
+			if (strlen (tok) == len && strcmp (name, tok) == 0) {
+				g_free (devices);
+				return TRUE;
+			}
+		}
+		g_free (devices);
+	}
+
+	return FALSE;
+}
+
+#define PRS_PRINT_FMT                    "print.format"
+#define PRS_PRINT_DEST                   "print.destination"
+#define PRS_PRINT_FILE                   "print.file"
+#define PRS_PRINT_CMD                    "print.command"
+#define PRS_COL_FMT                      "column.format"
+#define PRS_STREAM_CL_FG                 "stream.client.fg"
+#define PRS_STREAM_CL_BG                 "stream.client.bg"
+#define PRS_STREAM_SR_FG                 "stream.server.fg"
+#define PRS_STREAM_SR_BG                 "stream.server.bg"
+#define PRS_GUI_SCROLLBAR_ON_RIGHT       "gui.scrollbar_on_right"
+#define PRS_GUI_PLIST_SEL_BROWSE         "gui.packet_list_sel_browse"
+#define PRS_GUI_PTREE_SEL_BROWSE         "gui.protocol_tree_sel_browse"
+#define PRS_GUI_ALTERN_COLORS            "gui.tree_view_altern_colors"
+#define PRS_GUI_FILTER_TOOLBAR_IN_STATUSBAR "gui.filter_toolbar_show_in_statusbar"
+#define PRS_GUI_PTREE_LINE_STYLE         "gui.protocol_tree_line_style"
+#define PRS_GUI_PTREE_EXPANDER_STYLE     "gui.protocol_tree_expander_style"
+#define PRS_GUI_HEX_DUMP_HIGHLIGHT_STYLE "gui.hex_dump_highlight_style"
+#define PRS_GUI_FONT_NAME_1              "gui.font_name"
+#define PRS_GUI_FONT_NAME_2              "gui.gtk2.font_name"
+#define PRS_GUI_MARKED_FG                "gui.marked_frame.fg"
+#define PRS_GUI_MARKED_BG                "gui.marked_frame.bg"
+#define PRS_GUI_COLORIZED_FG             "gui.colorized_frame.fg"
+#define PRS_GUI_COLORIZED_BG             "gui.colorized_frame.bg"
+#define PRS_GUI_CONSOLE_OPEN             "gui.console_open"
+#define PRS_GUI_FILEOPEN_STYLE           "gui.fileopen.style"
+#define PRS_GUI_RECENT_COUNT_MAX         "gui.recent_files_count.max"
+#define PRS_GUI_RECENT_DF_ENTRIES_MAX    "gui.recent_display_filter_entries.max"
+#define PRS_GUI_FILEOPEN_DIR             "gui.fileopen.dir"
+#define PRS_GUI_FILEOPEN_REMEMBERED_DIR  "gui.fileopen.remembered_dir"
+#define PRS_GUI_FILEOPEN_PREVIEW         "gui.fileopen.preview"
+#define PRS_GUI_ASK_UNSAVED              "gui.ask_unsaved"
+#define PRS_GUI_FIND_WRAP                "gui.find_wrap"
+#define PRS_GUI_USE_PREF_SAVE            "gui.use_pref_save"
+#define PRS_GUI_GEOMETRY_SAVE_POSITION   "gui.geometry.save.position"
+#define PRS_GUI_GEOMETRY_SAVE_SIZE       "gui.geometry.save.size"
+#define PRS_GUI_GEOMETRY_SAVE_MAXIMIZED  "gui.geometry.save.maximized"
+#define PRS_GUI_MACOSX_STYLE             "gui.macosx_style"
+#define PRS_GUI_GEOMETRY_MAIN_X          "gui.geometry.main.x"
+#define PRS_GUI_GEOMETRY_MAIN_Y          "gui.geometry.main.y"
+#define PRS_GUI_GEOMETRY_MAIN_WIDTH      "gui.geometry.main.width"
+#define PRS_GUI_GEOMETRY_MAIN_HEIGHT     "gui.geometry.main.height"
+#define PRS_GUI_TOOLBAR_MAIN_SHOW        "gui.toolbar_main_show"
+#define PRS_GUI_TOOLBAR_MAIN_STYLE       "gui.toolbar_main_style"
+#define PRS_GUI_WEBBROWSER               "gui.webbrowser"
+#define PRS_GUI_WINDOW_TITLE             "gui.window_title"
+#define PRS_GUI_START_TITLE              "gui.start_title"
+#define PRS_GUI_VERSION_IN_START_PAGE    "gui.version_in_start_page"
+#define PRS_GUI_LAYOUT_TYPE              "gui.layout_type"
+#define PRS_GUI_LAYOUT_CONTENT_1         "gui.layout_content_1"
+#define PRS_GUI_LAYOUT_CONTENT_2         "gui.layout_content_2"
+#define PRS_GUI_LAYOUT_CONTENT_3         "gui.layout_content_3"
+#define PRS_CONSOLE_LOG_LEVEL		 "console.log.level"
+
+/*
+ * This applies to more than just captures, so it's not "capture.name_resolve";
+ * "capture.name_resolve" is supported on input for backwards compatibility.
+ *
+ * It's not a preference for a particular part of Wireshark, it's used all
+ * over the place, so its name doesn't have two components.
+ */
+#define PRS_NAME_RESOLVE "name_resolve"
+#define PRS_NAME_RESOLVE_CONCURRENCY "name_resolve_concurrency"
+#define PRS_CAP_NAME_RESOLVE "capture.name_resolve"
+
+/*  values for the capture dialog box */
+#define PRS_CAP_DEVICE        "capture.device"
+#define PRS_CAP_DEVICES_LINKTYPES "capture.devices_linktypes"
+#define PRS_CAP_DEVICES_DESCR "capture.devices_descr"
+#define PRS_CAP_DEVICES_HIDE  "capture.devices_hide"
+#define PRS_CAP_PROM_MODE     "capture.prom_mode"
+#define PRS_CAP_REAL_TIME     "capture.real_time_update"
+#define PRS_CAP_AUTO_SCROLL   "capture.auto_scroll"
+#define PRS_CAP_SHOW_INFO     "capture.show_info"
+
+#define RED_COMPONENT(x)   (guint16) (((((x) >> 16) & 0xff) * 65535 / 255))
+#define GREEN_COMPONENT(x) (guint16) (((((x) >>  8) & 0xff) * 65535 / 255))
+#define BLUE_COMPONENT(x)  (guint16) ( (((x)        & 0xff) * 65535 / 255))
+
+/*  values for the rtp player preferences dialog box */
+#define PRS_TAP_UPDATE_INTERVAL           "taps.update_interval"
+#define PRS_RTP_PLAYER_MAX_VISIBLE        "taps.rtp_player_max_visible"
+
+#define PRS_DISPLAY_HIDDEN_PROTO_ITEMS          "packet_list.display_hidden_proto_items"
+
+static const gchar *pr_formats[] = { "text", "postscript" };
+static const gchar *pr_dests[]   = { "command", "file" };
+
+typedef struct {
+  char    letter;
+  guint32 value;
+} name_resolve_opt_t;
+
+static name_resolve_opt_t name_resolve_opt[] = {
+  { 'm', RESOLV_MAC },
+  { 'n', RESOLV_NETWORK },
+  { 't', RESOLV_TRANSPORT },
+  { 'C', RESOLV_CONCURRENT },
+};
+
+#define N_NAME_RESOLVE_OPT	(sizeof name_resolve_opt / sizeof name_resolve_opt[0])
+
+static const char *
+name_resolve_to_string(guint32 name_resolve)
+{
+  static char string[N_NAME_RESOLVE_OPT+1];
+  char *p;
+  unsigned int i;
+  gboolean all_opts_set = TRUE;
+
+  if (name_resolve == RESOLV_NONE)
+    return "FALSE";
+  p = &string[0];
+  for (i = 0; i < N_NAME_RESOLVE_OPT; i++) {
+    if (name_resolve & name_resolve_opt[i].value)
+      *p++ =  name_resolve_opt[i].letter;
+    else
+      all_opts_set = FALSE;
+  }
+  *p = '\0';
+  if (all_opts_set)
+    return "TRUE";
+  return string;
+}
+
+char
+string_to_name_resolve(char *string, guint32 *name_resolve)
+{
+  char c;
+  unsigned int i;
+
+  *name_resolve = 0;
+  while ((c = *string++) != '\0') {
+    for (i = 0; i < N_NAME_RESOLVE_OPT; i++) {
+      if (c == name_resolve_opt[i].letter) {
+        *name_resolve |= name_resolve_opt[i].value;
+        break;
+      }
+    }
+    if (i == N_NAME_RESOLVE_OPT) {
+      /*
+       * Unrecognized letter.
+       */
+      return c;
+    }
+  }
+  return '\0';
+}
+
+static prefs_set_pref_e
+set_pref(gchar *pref_name, gchar *value, void *private_data _U_)
+{
+  GList    *col_l, *col_l_elt;
+  gint      llen;
+  fmt_data *cfmt;
+  unsigned long int cval;
+  guint    uval;
+  gboolean bval;
+  gint     enum_val;
+  char     *p;
+  gchar    *dotp, *last_dotp;
+  module_t *module;
+  pref_t   *pref;
+  gboolean had_a_dot;
+  const gchar *cust_format = col_format_to_string(COL_CUSTOM);
+  int cust_format_len = strlen(cust_format);
+
+  if (strcmp(pref_name, PRS_PRINT_FMT) == 0) {
+    if (strcmp(value, pr_formats[PR_FMT_TEXT]) == 0) {
+      prefs.pr_format = PR_FMT_TEXT;
+    } else if (strcmp(value, pr_formats[PR_FMT_PS]) == 0) {
+      prefs.pr_format = PR_FMT_PS;
+    } else {
+      return PREFS_SET_SYNTAX_ERR;
+    }
+  } else if (strcmp(pref_name, PRS_PRINT_DEST) == 0) {
+    if (strcmp(value, pr_dests[PR_DEST_CMD]) == 0) {
+      prefs.pr_dest = PR_DEST_CMD;
+    } else if (strcmp(value, pr_dests[PR_DEST_FILE]) == 0) {
+      prefs.pr_dest = PR_DEST_FILE;
+    } else {
+      return PREFS_SET_SYNTAX_ERR;
+    }
+  } else if (strcmp(pref_name, PRS_PRINT_FILE) == 0) {
+    if (prefs.pr_file) g_free(prefs.pr_file);
+    prefs.pr_file = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_PRINT_CMD) == 0) {
+    if (prefs.pr_cmd) g_free(prefs.pr_cmd);
+    prefs.pr_cmd = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_COL_FMT) == 0) {
+    col_l = prefs_get_string_list(value);
+    if (col_l == NULL)
+      return PREFS_SET_SYNTAX_ERR;
+    if ((g_list_length(col_l) % 2) != 0) {
+      /* A title didn't have a matching format.  */
+      prefs_clear_string_list(col_l);
+      return PREFS_SET_SYNTAX_ERR;
+    }
+    /* Check to make sure all column formats are valid.  */
+    col_l_elt = g_list_first(col_l);
+    while(col_l_elt) {
+      /* Make sure the title isn't empty.  */
+      if (strcmp(col_l_elt->data, "") == 0) {
+      	/* It is.  */
+        prefs_clear_string_list(col_l);
+        return PREFS_SET_SYNTAX_ERR;
+      }
+
+      /* Go past the title.  */
+      col_l_elt = col_l_elt->next;
+
+      /* Check the format.  */
+      if (strncmp(col_l_elt->data, cust_format, cust_format_len) != 0) {
+        if (get_column_format_from_str(col_l_elt->data) == -1) {
+          /* It's not a valid column format.  */
+          prefs_clear_string_list(col_l);
+          return PREFS_SET_SYNTAX_ERR;
+        }
+      }
+
+      /* Go past the format.  */
+      col_l_elt = col_l_elt->next;
+    }
+    free_col_info(&prefs);
+    prefs.col_list = NULL;
+    llen             = g_list_length(col_l);
+    prefs.num_cols   = llen / 2;
+    col_l_elt = g_list_first(col_l);
+    while(col_l_elt) {
+      cfmt = (fmt_data *) g_malloc(sizeof(fmt_data));
+      cfmt->title    = g_strdup(col_l_elt->data);
+      col_l_elt      = col_l_elt->next;
+      if (strncmp(col_l_elt->data, cust_format, cust_format_len) == 0) {
+        gchar *fmt     = g_strdup(col_l_elt->data);
+        cfmt->fmt      = g_strdup(cust_format);
+        cfmt->custom_field = g_strdup(&fmt[cust_format_len+1]);  /* add 1 for ':' */
+        g_free (fmt);
+      } else {
+        cfmt->fmt      = g_strdup(col_l_elt->data);
+        cfmt->custom_field = NULL;
+      }
+      col_l_elt      = col_l_elt->next;
+      prefs.col_list = g_list_append(prefs.col_list, cfmt);
+    }
+    prefs_clear_string_list(col_l);
+  } else if (strcmp(pref_name, PRS_STREAM_CL_FG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.st_client_fg.pixel = 0;
+    prefs.st_client_fg.red   = RED_COMPONENT(cval);
+    prefs.st_client_fg.green = GREEN_COMPONENT(cval);
+    prefs.st_client_fg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_STREAM_CL_BG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.st_client_bg.pixel = 0;
+    prefs.st_client_bg.red   = RED_COMPONENT(cval);
+    prefs.st_client_bg.green = GREEN_COMPONENT(cval);
+    prefs.st_client_bg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_STREAM_SR_FG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.st_server_fg.pixel = 0;
+    prefs.st_server_fg.red   = RED_COMPONENT(cval);
+    prefs.st_server_fg.green = GREEN_COMPONENT(cval);
+    prefs.st_server_fg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_STREAM_SR_BG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.st_server_bg.pixel = 0;
+    prefs.st_server_bg.red   = RED_COMPONENT(cval);
+    prefs.st_server_bg.green = GREEN_COMPONENT(cval);
+    prefs.st_server_bg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_GUI_SCROLLBAR_ON_RIGHT) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_scrollbar_on_right = TRUE;
+    }
+    else {
+	    prefs.gui_scrollbar_on_right = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_PLIST_SEL_BROWSE) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_plist_sel_browse = TRUE;
+    }
+    else {
+	    prefs.gui_plist_sel_browse = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_PTREE_SEL_BROWSE) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_ptree_sel_browse = TRUE;
+    }
+    else {
+	    prefs.gui_ptree_sel_browse = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_ALTERN_COLORS) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+            prefs.gui_altern_colors = TRUE;
+    }
+    else {
+            prefs.gui_altern_colors = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_PTREE_LINE_STYLE) == 0) {
+    prefs.gui_ptree_line_style =
+	find_index_from_string_array(value, gui_ptree_line_style_text, 0);
+  } else if (strcmp(pref_name, PRS_GUI_PTREE_EXPANDER_STYLE) == 0) {
+    prefs.gui_ptree_expander_style =
+	find_index_from_string_array(value, gui_ptree_expander_style_text, 1);
+  } else if (strcmp(pref_name, PRS_GUI_HEX_DUMP_HIGHLIGHT_STYLE) == 0) {
+    prefs.gui_hex_dump_highlight_style =
+	find_index_from_string_array(value, gui_hex_dump_highlight_style_text, 1);
+  } else if (strcmp(pref_name, PRS_GUI_FILTER_TOOLBAR_IN_STATUSBAR) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+            prefs.filter_toolbar_show_in_statusbar = TRUE;
+    }
+    else {
+            prefs.filter_toolbar_show_in_statusbar = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_TOOLBAR_MAIN_SHOW) == 0) {
+    /* obsoleted by recent setting */
+  } else if (strcmp(pref_name, PRS_GUI_TOOLBAR_MAIN_STYLE) == 0) {
+    /* see toolbar.c for details, "icons only" is default */
+	prefs.gui_toolbar_main_style =
+	    find_index_from_string_array(value, gui_toolbar_style_text,
+				     TB_STYLE_ICONS);
+  } else if (strcmp(pref_name, PRS_GUI_FONT_NAME_1) == 0) {
+    /* GTK1 font name obsolete */
+  } else if (strcmp(pref_name, PRS_GUI_FONT_NAME_2) == 0) {
+    if (prefs.gui_font_name != NULL)
+      g_free(prefs.gui_font_name);
+    prefs.gui_font_name = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_MARKED_FG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.gui_marked_fg.pixel = 0;
+    prefs.gui_marked_fg.red   = RED_COMPONENT(cval);
+    prefs.gui_marked_fg.green = GREEN_COMPONENT(cval);
+    prefs.gui_marked_fg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_GUI_MARKED_BG) == 0) {
+    cval = strtoul(value, NULL, 16);
+    prefs.gui_marked_bg.pixel = 0;
+    prefs.gui_marked_bg.red   = RED_COMPONENT(cval);
+    prefs.gui_marked_bg.green = GREEN_COMPONENT(cval);
+    prefs.gui_marked_bg.blue  = BLUE_COMPONENT(cval);
+  } else if (strcmp(pref_name, PRS_GUI_COLORIZED_FG) == 0) {
+    if (prefs.gui_colorized_fg != NULL)
+      g_free(prefs.gui_colorized_fg);
+    prefs.gui_colorized_fg = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_COLORIZED_BG) == 0) {
+    if (prefs.gui_colorized_bg != NULL)
+      g_free(prefs.gui_colorized_bg);
+    prefs.gui_colorized_bg = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_SAVE_POSITION) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_geometry_save_position = TRUE;
+    }
+    else {
+	    prefs.gui_geometry_save_position = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_SAVE_SIZE) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_geometry_save_size = TRUE;
+    }
+    else {
+	    prefs.gui_geometry_save_size = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_SAVE_MAXIMIZED) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_geometry_save_maximized = TRUE;
+    }
+    else {
+	    prefs.gui_geometry_save_maximized = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_MACOSX_STYLE) == 0) {
+     if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_macosx_style = TRUE;
+    }
+    else {
+	    prefs.gui_macosx_style = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_MAIN_X) == 0) {         /* deprecated */
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_MAIN_Y) == 0) {         /* deprecated */
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_MAIN_WIDTH) == 0) {     /* deprecated */
+  } else if (strcmp(pref_name, PRS_GUI_GEOMETRY_MAIN_HEIGHT) == 0) {    /* deprecated */
+  } else if (strcmp(pref_name, PRS_GUI_CONSOLE_OPEN) == 0) {
+    prefs.gui_console_open =
+	find_index_from_string_array(value, gui_console_open_text,
+				     console_open_never);
+  } else if (strcmp(pref_name, PRS_GUI_RECENT_COUNT_MAX) == 0) {
+    prefs.gui_recent_files_count_max = strtoul(value, NULL, 10);
+    if (prefs.gui_recent_files_count_max == 0) {
+      /* We really should put up a dialog box here ... */
+      prefs.gui_recent_files_count_max = 10;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_RECENT_DF_ENTRIES_MAX) == 0) {
+    prefs.gui_recent_df_entries_max = strtoul(value, NULL, 10);
+    if (prefs.gui_recent_df_entries_max == 0) {
+      /* We really should put up a dialog box here ... */
+      prefs.gui_recent_df_entries_max = 10;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_FILEOPEN_STYLE) == 0) {
+    prefs.gui_fileopen_style =
+	find_index_from_string_array(value, gui_fileopen_style_text,
+				     FO_STYLE_LAST_OPENED);
+  } else if (strcmp(pref_name, PRS_GUI_FILEOPEN_DIR) == 0) {
+    if (prefs.gui_fileopen_dir != NULL)
+      g_free(prefs.gui_fileopen_dir);
+    prefs.gui_fileopen_dir = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_FILEOPEN_REMEMBERED_DIR) == 0) { /* deprecated */
+  } else if (strcmp(pref_name, PRS_GUI_FILEOPEN_PREVIEW) == 0) {
+    prefs.gui_fileopen_preview = strtoul(value, NULL, 10);
+  } else if (strcmp(pref_name, PRS_GUI_ASK_UNSAVED) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_ask_unsaved = TRUE;
+    }
+    else {
+	    prefs.gui_ask_unsaved = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_FIND_WRAP) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_find_wrap = TRUE;
+    }
+    else {
+	    prefs.gui_find_wrap = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_USE_PREF_SAVE) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_use_pref_save = TRUE;
+    }
+    else {
+	    prefs.gui_use_pref_save = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_WEBBROWSER) == 0) {
+    g_free(prefs.gui_webbrowser);
+    prefs.gui_webbrowser = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_WINDOW_TITLE) == 0) {
+    if (prefs.gui_window_title != NULL)
+      g_free(prefs.gui_window_title);
+    prefs.gui_window_title = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_START_TITLE) == 0) {
+    if (prefs.gui_start_title != NULL)
+      g_free(prefs.gui_start_title);
+    prefs.gui_start_title = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_GUI_VERSION_IN_START_PAGE) == 0) {
+    if (g_ascii_strcasecmp(value, "true") == 0) {
+	    prefs.gui_version_in_start_page = TRUE;
+    } else {
+	    prefs.gui_version_in_start_page = FALSE;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_LAYOUT_TYPE) == 0) {
+    prefs.gui_layout_type = strtoul(value, NULL, 10);
+    if (prefs.gui_layout_type == layout_unused ||
+        prefs.gui_layout_type >= layout_type_max) {
+      /* XXX - report an error?  It's not a syntax error - we'd need to
+         add a way of reporting a *semantic* error. */
+      prefs.gui_layout_type = layout_type_5;
+    }
+  } else if (strcmp(pref_name, PRS_GUI_LAYOUT_CONTENT_1) == 0) {
+    prefs.gui_layout_content_1 =
+	find_index_from_string_array(value, gui_layout_content_text, 0);
+  } else if (strcmp(pref_name, PRS_GUI_LAYOUT_CONTENT_2) == 0) {
+    prefs.gui_layout_content_2 =
+	find_index_from_string_array(value, gui_layout_content_text, 0);
+  } else if (strcmp(pref_name, PRS_GUI_LAYOUT_CONTENT_3) == 0) {
+    prefs.gui_layout_content_3 =
+	find_index_from_string_array(value, gui_layout_content_text, 0);
+  } else if (strcmp(pref_name, PRS_CONSOLE_LOG_LEVEL) == 0) {
+    prefs.console_log_level = strtoul(value, NULL, 10);
+
+/* handle the capture options */
+  } else if (strcmp(pref_name, PRS_CAP_DEVICE) == 0) {
+    if (prefs.capture_device != NULL)
+      g_free(prefs.capture_device);
+    prefs.capture_device = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_CAP_DEVICES_LINKTYPES) == 0) {
+    if (prefs.capture_devices_linktypes != NULL)
+      g_free(prefs.capture_devices_linktypes);
+    prefs.capture_devices_linktypes = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_CAP_DEVICES_DESCR) == 0) {
+    if (prefs.capture_devices_descr != NULL)
+      g_free(prefs.capture_devices_descr);
+    prefs.capture_devices_descr = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_CAP_DEVICES_HIDE) == 0) {
+    if (prefs.capture_devices_hide != NULL)
+      g_free(prefs.capture_devices_hide);
+    prefs.capture_devices_hide = g_strdup(value);
+  } else if (strcmp(pref_name, PRS_CAP_PROM_MODE) == 0) {
+    prefs.capture_prom_mode = ((g_ascii_strcasecmp(value, "true") == 0)?TRUE:FALSE);
+  } else if (strcmp(pref_name, PRS_CAP_REAL_TIME) == 0) {
+    prefs.capture_real_time = ((g_ascii_strcasecmp(value, "true") == 0)?TRUE:FALSE);
+  } else if (strcmp(pref_name, PRS_CAP_AUTO_SCROLL) == 0) {
+    prefs.capture_auto_scroll = ((g_ascii_strcasecmp(value, "true") == 0)?TRUE:FALSE);
+  } else if (strcmp(pref_name, PRS_CAP_SHOW_INFO) == 0) {
+    prefs.capture_show_info = ((g_ascii_strcasecmp(value, "true") == 0)?TRUE:FALSE);
+
+/* handle the global options */
+  } else if (strcmp(pref_name, PRS_NAME_RESOLVE) == 0 ||
+	     strcmp(pref_name, PRS_CAP_NAME_RESOLVE) == 0) {
+    /*
+     * "TRUE" and "FALSE", for backwards compatibility, are synonyms for
+     * RESOLV_ALL and RESOLV_NONE.
+     *
+     * Otherwise, we treat it as a list of name types we want to resolve.
+     */
+    if (g_ascii_strcasecmp(value, "true") == 0)
+      prefs.name_resolve = RESOLV_ALL;
+    else if (g_ascii_strcasecmp(value, "false") == 0)
+      prefs.name_resolve = RESOLV_NONE;
+    else {
+      prefs.name_resolve = RESOLV_NONE;	/* start out with none set */
+      if (string_to_name_resolve(value, &prefs.name_resolve) != '\0')
+        return PREFS_SET_SYNTAX_ERR;
+    }
+  } else if (strcmp(pref_name, PRS_NAME_RESOLVE_CONCURRENCY) == 0) {
+    prefs.name_resolve_concurrency = strtol(value, NULL, 10);
+  } else if ((strcmp(pref_name, PRS_RTP_PLAYER_MAX_VISIBLE) == 0) ||
+             (strcmp(pref_name, "rtp_player.max_visible") == 0)) {
+    /* ... also accepting old name for this preference */
+    prefs.rtp_player_max_visible = strtol(value, NULL, 10);
+  } else if (strcmp(pref_name, PRS_TAP_UPDATE_INTERVAL) == 0) {
+    prefs.tap_update_interval = strtol(value, NULL, 10);
+  } else if (strcmp(pref_name, PRS_DISPLAY_HIDDEN_PROTO_ITEMS) == 0) {
+    prefs.display_hidden_proto_items = ((g_ascii_strcasecmp(value, "true") == 0)?TRUE:FALSE);
+  } else {
+    /* To which module does this preference belong? */
+    module = NULL;
+    last_dotp = pref_name;
+    had_a_dot = FALSE;
+    while (!module) {
+        dotp = strchr(last_dotp, '.');
+        if (dotp == NULL) {
+            if (had_a_dot) {
+              /* no such module */
+              return PREFS_SET_NO_SUCH_PREF;
+            }
+            else {
+              /* no ".", so no module/name separator */
+              return PREFS_SET_SYNTAX_ERR;
+            }
+        }
+        else {
+            had_a_dot = TRUE;
+        }
+        *dotp = '\0';		/* separate module and preference name */
+        module = prefs_find_module(pref_name);
+
+        /*
+         * XXX - "Diameter" rather than "diameter" was used in earlier
+         * versions of Wireshark; if we didn't find the module, and its name
+         * was "Diameter", look for "diameter" instead.
+         *
+         * In addition, the BEEP protocol used to be the BXXP protocol,
+         * so if we didn't find the module, and its name was "bxxp",
+         * look for "beep" instead.
+         *
+         * Also, the preferences for GTP v0 and v1 were combined under
+         * a single "gtp" heading, and the preferences for SMPP were
+         * moved to "smpp-gsm-sms" and then moved to "gsm-sms-ud".
+         * However, SMPP now has its own preferences, so we just map
+         * "smpp-gsm-sms" to "gsm-sms-ud", and then handle SMPP below.
+         *
+         * We also renamed "dcp" to "dccp".
+         */
+        if (module == NULL) {
+          if (strcmp(pref_name, "Diameter") == 0)
+            module = prefs_find_module("diameter");
+          else if (strcmp(pref_name, "bxxp") == 0)
+            module = prefs_find_module("beep");
+          else if (strcmp(pref_name, "gtpv0") == 0 ||
+                   strcmp(pref_name, "gtpv1") == 0)
+            module = prefs_find_module("gtp");
+          else if (strcmp(pref_name, "smpp-gsm-sms") == 0)
+            module = prefs_find_module("gsm-sms-ud");
+          else if (strcmp(pref_name, "dcp") == 0)
+            module = prefs_find_module("dccp");
+        }
+        *dotp = '.';		/* put the preference string back */
+        dotp++;			/* skip past separator to preference name */
+        last_dotp = dotp;
+    }
+
+    pref = prefs_find_preference(module, dotp);
+
+    if (pref == NULL) {
+      if (strcmp(module->name, "mgcp") == 0) {
+        /*
+         * XXX - "mgcp.display raw text toggle" and "mgcp.display dissect tree"
+         * rather than "mgcp.display_raw_text" and "mgcp.display_dissect_tree"
+         * were used in earlier versions of Wireshark; if we didn't find the
+         * preference, it was an MGCP preference, and its name was
+         * "display raw text toggle" or "display dissect tree", look for
+         * "display_raw_text" or "display_dissect_tree" instead.
+         *
+         * "mgcp.tcp.port" and "mgcp.udp.port" are harder to handle, as both
+         * the gateway and callagent ports were given those names; we interpret
+         * the first as "mgcp.{tcp,udp}.gateway_port" and the second as
+         * "mgcp.{tcp,udp}.callagent_port", as that's the order in which
+         * they were registered by the MCCP dissector and thus that's the
+         * order in which they were written to the preferences file.  (If
+         * we're not reading the preferences file, but are handling stuff
+         * from a "-o" command-line option, we have no clue which the user
+         * had in mind - they should have used "mgcp.{tcp,udp}.gateway_port"
+         * or "mgcp.{tcp,udp}.callagent_port" instead.)
+         */
+        if (strcmp(dotp, "display raw text toggle") == 0)
+          pref = prefs_find_preference(module, "display_raw_text");
+        else if (strcmp(dotp, "display dissect tree") == 0)
+          pref = prefs_find_preference(module, "display_dissect_tree");
+        else if (strcmp(dotp, "tcp.port") == 0) {
+          mgcp_tcp_port_count++;
+          if (mgcp_tcp_port_count == 1) {
+            /* It's the first one */
+            pref = prefs_find_preference(module, "tcp.gateway_port");
+ 	  } else if (mgcp_tcp_port_count == 2) {
+            /* It's the second one */
+            pref = prefs_find_preference(module, "tcp.callagent_port");
+	  }
+          /* Otherwise it's from the command line, and we don't bother
+             mapping it. */
+	} else if (strcmp(dotp, "udp.port") == 0) {
+          mgcp_udp_port_count++;
+          if (mgcp_udp_port_count == 1) {
+            /* It's the first one */
+            pref = prefs_find_preference(module, "udp.gateway_port");
+	  } else if (mgcp_udp_port_count == 2) {
+            /* It's the second one */
+            pref = prefs_find_preference(module, "udp.callagent_port");
+	  }
+          /* Otherwise it's from the command line, and we don't bother
+             mapping it. */
+	}
+      } else if (strcmp(module->name, "smb") == 0) {
+        /* Handle old names for SMB preferences. */
+        if (strcmp(dotp, "smb.trans.reassembly") == 0)
+          pref = prefs_find_preference(module, "trans_reassembly");
+        else if (strcmp(dotp, "smb.dcerpc.reassembly") == 0)
+          pref = prefs_find_preference(module, "dcerpc_reassembly");
+      } else if (strcmp(module->name, "ndmp") == 0) {
+        /* Handle old names for NDMP preferences. */
+        if (strcmp(dotp, "ndmp.desegment") == 0)
+          pref = prefs_find_preference(module, "desegment");
+      } else if (strcmp(module->name, "diameter") == 0) {
+        /* Handle old names for Diameter preferences. */
+        if (strcmp(dotp, "diameter.desegment") == 0)
+          pref = prefs_find_preference(module, "desegment");
+      } else if (strcmp(module->name, "pcli") == 0) {
+        /* Handle old names for PCLI preferences. */
+        if (strcmp(dotp, "pcli.udp_port") == 0)
+          pref = prefs_find_preference(module, "udp_port");
+      } else if (strcmp(module->name, "artnet") == 0) {
+        /* Handle old names for ARTNET preferences. */
+        if (strcmp(dotp, "artnet.udp_port") == 0)
+          pref = prefs_find_preference(module, "udp_port");
+      } else if (strcmp(module->name, "mapi") == 0) {
+        /* Handle old names for MAPI preferences. */
+        if (strcmp(dotp, "mapi_decrypt") == 0)
+          pref = prefs_find_preference(module, "decrypt");
+      } else if (strcmp(module->name, "fc") == 0) {
+        /* Handle old names for Fibre Channel preferences. */
+        if (strcmp(dotp, "reassemble_fc") == 0)
+          pref = prefs_find_preference(module, "reassemble");
+        else if (strcmp(dotp, "fc_max_frame_size") == 0)
+          pref = prefs_find_preference(module, "max_frame_size");
+      } else if (strcmp(module->name, "fcip") == 0) {
+        /* Handle old names for Fibre Channel-over-IP preferences. */
+        if (strcmp(dotp, "desegment_fcip_messages") == 0)
+          pref = prefs_find_preference(module, "desegment");
+        else if (strcmp(dotp, "fcip_port") == 0)
+          pref = prefs_find_preference(module, "target_port");
+      } else if (strcmp(module->name, "gtp") == 0) {
+        /* Handle old names for GTP preferences. */
+        if (strcmp(dotp, "gtpv0_port") == 0)
+          pref = prefs_find_preference(module, "v0_port");
+        else if (strcmp(dotp, "gtpv1c_port") == 0)
+          pref = prefs_find_preference(module, "v1c_port");
+        else if (strcmp(dotp, "gtpv1u_port") == 0)
+          pref = prefs_find_preference(module, "v1u_port");
+        else if (strcmp(dotp, "gtp_dissect_tpdu") == 0)
+          pref = prefs_find_preference(module, "dissect_tpdu");
+        else if (strcmp(dotp, "gtpv0_dissect_cdr_as") == 0)
+          pref = prefs_find_preference(module, "v0_dissect_cdr_as");
+        else if (strcmp(dotp, "gtpv0_check_etsi") == 0)
+          pref = prefs_find_preference(module, "v0_check_etsi");
+        else if (strcmp(dotp, "gtpv1_check_etsi") == 0)
+          pref = prefs_find_preference(module, "v1_check_etsi");
+      } else if (strcmp(module->name, "ip") == 0) {
+        /* Handle old names for IP preferences. */
+        if (strcmp(dotp, "ip_summary_in_tree") == 0)
+          pref = prefs_find_preference(module, "summary_in_tree");
+      } else if (strcmp(module->name, "iscsi") == 0) {
+        /* Handle old names for iSCSI preferences. */
+        if (strcmp(dotp, "iscsi_port") == 0)
+          pref = prefs_find_preference(module, "target_port");
+      } else if (strcmp(module->name, "lmp") == 0) {
+        /* Handle old names for LMP preferences. */
+        if (strcmp(dotp, "lmp_version") == 0)
+          pref = prefs_find_preference(module, "version");
+      } else if (strcmp(module->name, "mtp3") == 0) {
+        /* Handle old names for MTP3 preferences. */
+        if (strcmp(dotp, "mtp3_standard") == 0)
+          pref = prefs_find_preference(module, "standard");
+        else if (strcmp(dotp, "net_addr_format") == 0)
+          pref = prefs_find_preference(module, "addr_format");
+      } else if (strcmp(module->name, "nlm") == 0) {
+        /* Handle old names for NLM preferences. */
+        if (strcmp(dotp, "nlm_msg_res_matching") == 0)
+          pref = prefs_find_preference(module, "msg_res_matching");
+      } else if (strcmp(module->name, "ppp") == 0) {
+        /* Handle old names for PPP preferences. */
+        if (strcmp(dotp, "ppp_fcs") == 0)
+          pref = prefs_find_preference(module, "fcs_type");
+        else if (strcmp(dotp, "ppp_vj") == 0)
+          pref = prefs_find_preference(module, "decompress_vj");
+      } else if (strcmp(module->name, "rsvp") == 0) {
+        /* Handle old names for RSVP preferences. */
+        if (strcmp(dotp, "rsvp_process_bundle") == 0)
+          pref = prefs_find_preference(module, "process_bundle");
+      } else if (strcmp(module->name, "tcp") == 0) {
+        /* Handle old names for TCP preferences. */
+        if (strcmp(dotp, "tcp_summary_in_tree") == 0)
+          pref = prefs_find_preference(module, "summary_in_tree");
+        else if (strcmp(dotp, "tcp_analyze_sequence_numbers") == 0)
+          pref = prefs_find_preference(module, "analyze_sequence_numbers");
+        else if (strcmp(dotp, "tcp_relative_sequence_numbers") == 0)
+          pref = prefs_find_preference(module, "relative_sequence_numbers");
+      } else if (strcmp(module->name, "udp") == 0) {
+        /* Handle old names for UDP preferences. */
+        if (strcmp(dotp, "udp_summary_in_tree") == 0)
+          pref = prefs_find_preference(module, "summary_in_tree");
+      } else if (strcmp(module->name, "ndps") == 0) {
+        /* Handle old names for NDPS preferences. */
+        if (strcmp(dotp, "desegment_ndps") == 0)
+          pref = prefs_find_preference(module, "desegment_tcp");
+      } else if (strcmp(module->name, "http") == 0) {
+        /* Handle old names for HTTP preferences. */
+        if (strcmp(dotp, "desegment_http_headers") == 0)
+          pref = prefs_find_preference(module, "desegment_headers");
+        else if (strcmp(dotp, "desegment_http_body") == 0)
+          pref = prefs_find_preference(module, "desegment_body");
+      } else if (strcmp(module->name, "smpp") == 0) {
+        /* Handle preferences that moved from SMPP. */
+        module_t *new_module = prefs_find_module("gsm-sms-ud");
+        if(new_module){
+          if (strcmp(dotp, "port_number_udh_means_wsp") == 0)
+            pref = prefs_find_preference(new_module, "port_number_udh_means_wsp");
+          else if (strcmp(dotp, "try_dissect_1st_fragment") == 0)
+            pref = prefs_find_preference(new_module, "try_dissect_1st_fragment");
+        }
+      } else if (strcmp(module->name, "asn1") == 0) {
+        /* Handle old generic ASN.1 preferences (it's not really a
+           rename, as the new preferences support multiple ports,
+           but we might as well copy them over). */
+        if (strcmp(dotp, "tcp_port") == 0)
+          pref = prefs_find_preference(module, "tcp_ports");
+        else if (strcmp(dotp, "udp_port") == 0)
+          pref = prefs_find_preference(module, "udp_ports");
+        else if (strcmp(dotp, "sctp_port") == 0)
+          pref = prefs_find_preference(module, "sctp_ports");
+      } else if (strcmp(module->name, "llcgprs") == 0) {
+        if (strcmp(dotp, "ignore_cipher_bit") == 0)
+          pref = prefs_find_preference(module, "autodetect_cipher_bit");
+      } else if (strcmp(module->name, "erf") == 0) {
+        if (strcmp(dotp, "erfeth") == 0) {
+          /* Handle the old "erfeth" preference; map it to the new
+             "ethfcs" preference, and map the values to those for
+             the new preference. */
+          pref = prefs_find_preference(module, "ethfcs");
+          if (strcmp(value, "ethfcs") == 0 || strcmp(value, "Ethernet with FCS") == 0)
+            value = "TRUE";
+          else if (strcmp(value, "eth") == 0 || strcmp(value, "Ethernet") == 0)
+            value = "FALSE";
+          else if (strcmp(value, "raw") == 0 || strcmp(value, "Raw data") == 0)
+            value = "TRUE";
+        } else if (strcmp(dotp, "erfatm") == 0) {
+          /* Handle the old "erfatm" preference; map it to the new
+             "aal5_type" preference, and map the values to those for
+             the new preference. */
+          pref = prefs_find_preference(module, "aal5_type");
+          if (strcmp(value, "atm") == 0 || strcmp(value, "ATM") == 0)
+            value = "guess";
+          else if (strcmp(value, "llc") == 0 || strcmp(value, "LLC") == 0)
+            value = "llc";
+          else if (strcmp(value, "raw") == 0 || strcmp(value, "Raw data") == 0)
+            value = "guess";
+        } else if (strcmp(dotp, "erfhdlc") == 0) {
+          /* Handle the old "erfhdlc" preference; map it to the new
+             "hdlc_type" preference, and map the values to those for
+             the new preference. */
+          pref = prefs_find_preference(module, "hdlc_type");
+          if (strcmp(value, "chdlc") == 0 || strcmp(value, "Cisco HDLC") == 0)
+            value = "chdlc";
+          else if (strcmp(value, "ppp") == 0 || strcmp(value, "PPP serial") == 0)
+            value = "ppp";
+          else if (strcmp(value, "fr") == 0 || strcmp(value, "Frame Relay") == 0)
+            value = "frelay";
+          else if (strcmp(value, "mtp2") == 0 || strcmp(value, "SS7 MTP2") == 0)
+            value = "mtp2";
+          else if (strcmp(value, "raw") == 0 || strcmp(value, "Raw data") == 0)
+            value = "guess";
+        }
+      }
+    }
+    if (pref == NULL)
+      return PREFS_SET_NO_SUCH_PREF;	/* no such preference */
+
+    switch (pref->type) {
+
+    case PREF_UINT:
+      uval = strtoul(value, &p, pref->info.base);
+      if (p == value || *p != '\0')
+        return PREFS_SET_SYNTAX_ERR;	/* number was bad */
+      if (*pref->varp.uint != uval) {
+        module->prefs_changed = TRUE;
+        *pref->varp.uint = uval;
+      }
+      break;
+
+    case PREF_BOOL:
+      /* XXX - give an error if it's neither "true" nor "false"? */
+      if (g_ascii_strcasecmp(value, "true") == 0)
+        bval = TRUE;
+      else
+        bval = FALSE;
+      if (*pref->varp.boolp != bval) {
+	module->prefs_changed = TRUE;
+	*pref->varp.boolp = bval;
+      }
+      break;
+
+    case PREF_ENUM:
+      /* XXX - give an error if it doesn't match? */
+      enum_val = find_val_for_string(value,
+					pref->info.enum_info.enumvals, 1);
+      if (*pref->varp.enump != enum_val) {
+	module->prefs_changed = TRUE;
+	*pref->varp.enump = enum_val;
+      }
+      break;
+
+    case PREF_STRING:
+      if (strcmp(*pref->varp.string, value) != 0) {
+        module->prefs_changed = TRUE;
+        g_free((void *)*pref->varp.string);
+        *pref->varp.string = g_strdup(value);
+      }
+      break;
+
+    case PREF_RANGE:
+    {
+      range_t *newrange;
+
+      if (range_convert_str(&newrange, value, pref->info.max_value) !=
+          CVT_NO_ERROR) {
+        /* XXX - distinguish between CVT_SYNTAX_ERROR and
+           CVT_NUMBER_TOO_BIG */
+        return PREFS_SET_SYNTAX_ERR;	/* number was bad */
+      }
+
+      if (!ranges_are_equal(*pref->varp.range, newrange)) {
+	module->prefs_changed = TRUE;
+	g_free(*pref->varp.range);
+	*pref->varp.range = newrange;
+      } else {
+	g_free (newrange);
+      }
+      break;
+    }
+
+    case PREF_STATIC_TEXT:
+    case PREF_UAT:
+    {
+      break;
+    }
+
+    case PREF_OBSOLETE:
+      return PREFS_SET_OBSOLETE;	/* no such preference any more */
+    }
+  }
+
+  return PREFS_SET_OK;
+}
+
+typedef struct {
+	module_t *module;
+	FILE	*pf;
+} write_pref_arg_t;
+
+/*
+ * Write out a single preference.
+ */
+static void
+write_pref(gpointer data, gpointer user_data)
+{
+	pref_t *pref = data;
+	write_pref_arg_t *arg = user_data;
+	const enum_val_t *enum_valp;
+	const char *val_string;
+	gchar **desc_lines;
+	int i;
+
+	if (pref->type == PREF_OBSOLETE) {
+		/*
+		 * This preference is no longer supported; it's not a
+		 * real preference, so we don't write it out (i.e., we
+		 * treat it as if it weren't found in the list of
+		 * preferences, and we weren't called in the first place).
+		 */
+		return;
+	}
+
+	/*
+	 * Make multiple line descriptions appear as
+	 * multiple commented lines in prefs file.
+	 */
+	if (g_ascii_strncasecmp(pref->description,"", 2) != 0) {
+		desc_lines = g_strsplit(pref->description,"\n",0);
+		for (i = 0; desc_lines[i] != NULL; ++i) {
+			fprintf(arg->pf, "\n# %s", desc_lines[i]);
+		}
+		fprintf(arg->pf, "\n");
+		g_strfreev(desc_lines);
+	} else {
+		fprintf(arg->pf, "\n# No description\n");
+	}
+
+	switch (pref->type) {
+
+	case PREF_UINT:
+		switch (pref->info.base) {
+
+		case 10:
+			fprintf(arg->pf, "# A decimal number.\n");
+			fprintf(arg->pf, "%s.%s: %u\n", arg->module->name,
+			    pref->name, *pref->varp.uint);
+			break;
+
+		case 8:
+			fprintf(arg->pf, "# An octal number.\n");
+			fprintf(arg->pf, "%s.%s: %#o\n", arg->module->name,
+			    pref->name, *pref->varp.uint);
+			break;
+
+		case 16:
+			fprintf(arg->pf, "# A hexadecimal number.\n");
+			fprintf(arg->pf, "%s.%s: %#x\n", arg->module->name,
+			    pref->name, *pref->varp.uint);
+			break;
+		}
+		break;
+
+	case PREF_BOOL:
+		fprintf(arg->pf, "# TRUE or FALSE (case-insensitive).\n");
+		fprintf(arg->pf, "%s.%s: %s\n", arg->module->name, pref->name,
+		    *pref->varp.boolp ? "TRUE" : "FALSE");
+		break;
+
+	case PREF_ENUM:
+		/*
+		 * For now, we save the "description" value, so that if we
+		 * save the preferences older versions of Wireshark can at
+		 * least read preferences that they supported; we support
+		 * either the short name or the description when reading
+		 * the preferences file or a "-o" option.
+		 */
+		fprintf(arg->pf, "# One of: ");
+		enum_valp = pref->info.enum_info.enumvals;
+		val_string = NULL;
+		while (enum_valp->name != NULL) {
+			if (enum_valp->value == *pref->varp.enump)
+				val_string = enum_valp->description;
+			fprintf(arg->pf, "%s", enum_valp->description);
+			enum_valp++;
+			if (enum_valp->name == NULL)
+				fprintf(arg->pf, "\n");
+			else
+				fprintf(arg->pf, ", ");
+		}
+		fprintf(arg->pf, "# (case-insensitive).\n");
+		fprintf(arg->pf, "%s.%s: %s\n", arg->module->name,
+		    pref->name, val_string);
+		break;
+
+	case PREF_STRING:
+		fprintf(arg->pf, "# A string.\n");
+		fprintf(arg->pf, "%s.%s: %s\n", arg->module->name, pref->name,
+		    *pref->varp.string);
+		break;
+
+	case PREF_RANGE:
+	{
+		char *range_string;
+
+		range_string = range_convert_range(*pref->varp.range);
+		fprintf(arg->pf, "# A string denoting an positive integer range (e.g., \"1-20,30-40\").\n");
+		fprintf(arg->pf, "%s.%s: %s\n", arg->module->name, pref->name,
+			range_string);
+		break;
+	}
+
+	case PREF_STATIC_TEXT:
+	case PREF_UAT:
+	{
+		/* Nothing to do */
+		break;
+	}
+
+	case PREF_OBSOLETE:
+		g_assert_not_reached();
+		break;
+	}
+}
+
+static gboolean
+write_module_prefs(void *value, void *data)
+{
+	write_pref_arg_t arg;
+
+	arg.module = value;
+	arg.pf = data;
+	g_list_foreach(arg.module->prefs, write_pref, &arg);
+	return FALSE;
+}
+
+/* Write out "prefs" to the user's preferences file, and return 0.
+
+   If the preferences file path is NULL, write to stdout.
+
+   If we got an error, stuff a pointer to the path of the preferences file
+   into "*pf_path_return", and return the errno. */
+int
+write_prefs(char **pf_path_return)
+{
+  char        *pf_path;
+  FILE        *pf;
+  GList       *clp, *col_l;
+  fmt_data    *cfmt;
+  const gchar *cust_format = col_format_to_string(COL_CUSTOM);
+
+  /* Needed for "-G defaultprefs" */
+  init_prefs();
+
+  /* To do:
+   * - Split output lines longer than MAX_VAL_LEN
+   * - Create a function for the preference directory check/creation
+   *   so that duplication can be avoided with filter.c
+   */
+
+  if (pf_path_return != NULL) {
+    pf_path = get_persconffile_path(PF_NAME, TRUE, TRUE);
+    if ((pf = ws_fopen(pf_path, "w")) == NULL) {
+      *pf_path_return = pf_path;
+      return errno;
+    }
+  } else {
+    pf = stdout;
+  }
+
+  fputs("# Configuration file for Wireshark " VERSION ".\n"
+    "#\n"
+    "# This file is regenerated each time preferences are saved within\n"
+    "# Wireshark.  Making manual changes should be safe, however.\n", pf);
+
+  fprintf (pf, "\n######## User Interface ########\n");
+
+  fprintf(pf, "\n# Vertical scrollbars should be on right side?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_SCROLLBAR_ON_RIGHT ": %s\n",
+		  prefs.gui_scrollbar_on_right == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Packet-list selection bar can be used to browse w/o selecting?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_PLIST_SEL_BROWSE ": %s\n",
+		  prefs.gui_plist_sel_browse == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Protocol-tree selection bar can be used to browse w/o selecting?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_PTREE_SEL_BROWSE ": %s\n",
+		  prefs.gui_ptree_sel_browse == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Alternating colors in TreeViews?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_ALTERN_COLORS ": %s\n",
+		  prefs.gui_altern_colors == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Place filter toolbar inside the statusbar?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_FILTER_TOOLBAR_IN_STATUSBAR ": %s\n",
+                 prefs.filter_toolbar_show_in_statusbar == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Protocol-tree line style.\n");
+  fprintf(pf, "# One of: NONE, SOLID, DOTTED, TABBED\n");
+  fprintf(pf, PRS_GUI_PTREE_LINE_STYLE ": %s\n",
+          gui_ptree_line_style_text[prefs.gui_ptree_line_style]);
+
+  fprintf(pf, "\n# Protocol-tree expander style.\n");
+  fprintf(pf, "# One of: NONE, SQUARE, TRIANGLE, CIRCULAR\n");
+  fprintf(pf, PRS_GUI_PTREE_EXPANDER_STYLE ": %s\n",
+		  gui_ptree_expander_style_text[prefs.gui_ptree_expander_style]);
+
+  fprintf(pf, "\n# Hex dump highlight style.\n");
+  fprintf(pf, "# One of: BOLD, INVERSE\n");
+  fprintf(pf, PRS_GUI_HEX_DUMP_HIGHLIGHT_STYLE ": %s\n",
+		  gui_hex_dump_highlight_style_text[prefs.gui_hex_dump_highlight_style]);
+
+  fprintf(pf, "\n# Main Toolbar style.\n");
+  fprintf(pf, "# One of: ICONS, TEXT, BOTH\n");
+  fprintf(pf, PRS_GUI_TOOLBAR_MAIN_STYLE ": %s\n",
+		  gui_toolbar_style_text[prefs.gui_toolbar_main_style]);
+
+  fprintf(pf, "\n# Save window position at exit?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_GEOMETRY_SAVE_POSITION ": %s\n",
+		  prefs.gui_geometry_save_position == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Save window size at exit?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_GEOMETRY_SAVE_SIZE ": %s\n",
+		  prefs.gui_geometry_save_size == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Save window maximized state at exit?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_GEOMETRY_SAVE_MAXIMIZED ": %s\n",
+		  prefs.gui_geometry_save_maximized == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Use MacOS X style (Mac OS X with native GTK only)?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_MACOSX_STYLE ": %s\n",
+	          prefs.gui_macosx_style == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Open a console window (WIN32 only)?\n");
+  fprintf(pf, "# One of: NEVER, AUTOMATIC, ALWAYS\n");
+  fprintf(pf, PRS_GUI_CONSOLE_OPEN ": %s\n",
+		  gui_console_open_text[prefs.gui_console_open]);
+
+  fprintf(pf, "\n# The max. number of entries in the display filter list.\n");
+  fprintf(pf, "# A decimal number.\n");
+  fprintf(pf, PRS_GUI_RECENT_DF_ENTRIES_MAX ": %d\n",
+	          prefs.gui_recent_df_entries_max);
+
+  fprintf(pf, "\n# The max. number of items in the open recent files list.\n");
+  fprintf(pf, "# A decimal number.\n");
+  fprintf(pf, PRS_GUI_RECENT_COUNT_MAX ": %d\n",
+	          prefs.gui_recent_files_count_max);
+
+  fprintf(pf, "\n# Where to start the File Open dialog box.\n");
+  fprintf(pf, "# One of: LAST_OPENED, SPECIFIED\n");
+  fprintf(pf, PRS_GUI_FILEOPEN_STYLE ": %s\n",
+		  gui_fileopen_style_text[prefs.gui_fileopen_style]);
+
+  if (prefs.gui_fileopen_dir != NULL) {
+    fprintf(pf, "\n# Directory to start in when opening File Open dialog.\n");
+    fprintf(pf, PRS_GUI_FILEOPEN_DIR ": %s\n",
+                  prefs.gui_fileopen_dir);
+  }
+
+  fprintf(pf, "\n# The preview timeout in the File Open dialog.\n");
+  fprintf(pf, "# A decimal number (in seconds).\n");
+  fprintf(pf, PRS_GUI_FILEOPEN_PREVIEW ": %d\n",
+	          prefs.gui_fileopen_preview);
+
+  fprintf(pf, "\n# Ask to save unsaved capture files?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_ASK_UNSAVED ": %s\n",
+		  prefs.gui_ask_unsaved == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Wrap to beginning/end of file during search?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_FIND_WRAP ": %s\n",
+		  prefs.gui_find_wrap == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Settings dialogs use a save button?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_USE_PREF_SAVE ": %s\n",
+		  prefs.gui_use_pref_save == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# The path to the webbrowser.\n");
+  fprintf(pf, "# Ex: mozilla %%s\n");
+  fprintf(pf, PRS_GUI_WEBBROWSER ": %s\n", prefs.gui_webbrowser);
+
+  fprintf(pf, "\n# Custom window title. (Prepended to existing titles.)\n");
+  fprintf(pf, PRS_GUI_WINDOW_TITLE ": %s\n",
+              prefs.gui_window_title);
+
+  fprintf(pf, "\n# Custom start page title.\n");
+  fprintf(pf, PRS_GUI_START_TITLE ": %s\n",
+              prefs.gui_start_title);
+
+  fprintf(pf, "\n# Show version in start page, can be useful in custom builds.\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_GUI_VERSION_IN_START_PAGE ": %s\n",
+		  prefs.gui_version_in_start_page == TRUE ? "TRUE" : "FALSE");
+
+  fprintf (pf, "\n######## User Interface: Layout ########\n");
+
+  fprintf(pf, "\n# Layout type (1-6).\n");
+  fprintf(pf, PRS_GUI_LAYOUT_TYPE ": %d\n",
+	          prefs.gui_layout_type);
+
+  fprintf(pf, "\n# Layout content of the panes (1-3).\n");
+  fprintf(pf, "# One of: NONE, PLIST, PDETAILS, PBYTES\n");
+  fprintf(pf, PRS_GUI_LAYOUT_CONTENT_1 ": %s\n",
+	          gui_layout_content_text[prefs.gui_layout_content_1]);
+  fprintf(pf, PRS_GUI_LAYOUT_CONTENT_2 ": %s\n",
+	          gui_layout_content_text[prefs.gui_layout_content_2]);
+  fprintf(pf, PRS_GUI_LAYOUT_CONTENT_3 ": %s\n",
+	          gui_layout_content_text[prefs.gui_layout_content_3]);
+
+  fprintf (pf, "\n######## User Interface: Columns ########\n");
+
+  clp = prefs.col_list;
+  col_l = NULL;
+  while (clp) {
+    cfmt = (fmt_data *) clp->data;
+    col_l = g_list_append(col_l, cfmt->title);
+    if ((strcmp(cfmt->fmt, cust_format) == 0) && (cfmt->custom_field)) {
+      gchar *fmt = g_strdup_printf("%s:%s", cfmt->fmt, cfmt->custom_field);
+      col_l = g_list_append(col_l, fmt);
+    } else {
+      col_l = g_list_append(col_l, cfmt->fmt);
+    }
+    clp = clp->next;
+  }
+  fprintf (pf, "\n# Packet list column format.\n");
+  fprintf (pf, "# Each pair of strings consists of a column title and its format.\n");
+  fprintf (pf, "%s: %s\n", PRS_COL_FMT, put_string_list(col_l));
+  /* This frees the list of strings, but not the strings to which it
+     refers; that's what we want, as we haven't copied those strings,
+     we just referred to them.  */
+  g_list_free(col_l);
+
+  fprintf (pf, "\n######## User Interface: Font ########\n");
+
+  fprintf(pf, "\n# Font name for packet list, protocol tree, and hex dump panes.\n");
+  fprintf(pf, PRS_GUI_FONT_NAME_2 ": %s\n", prefs.gui_font_name);
+
+  fprintf (pf, "\n######## User Interface: Colors ########\n");
+
+  fprintf (pf, "\n# Color preferences for a marked frame.\n");
+  fprintf (pf, "# Each value is a six digit hexadecimal color value in the form rrggbb.\n");
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_GUI_MARKED_FG,
+    (prefs.gui_marked_fg.red * 255 / 65535),
+    (prefs.gui_marked_fg.green * 255 / 65535),
+    (prefs.gui_marked_fg.blue * 255 / 65535));
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_GUI_MARKED_BG,
+    (prefs.gui_marked_bg.red * 255 / 65535),
+    (prefs.gui_marked_bg.green * 255 / 65535),
+    (prefs.gui_marked_bg.blue * 255 / 65535));
+
+  /* Don't write the colors of the 10 easy-access-colorfilters to the preferences
+   * file until the colors can be changed in the GUI. Currently this is not really
+   * possible since the STOCK-icons for these colors are hardcoded.
+   *
+   * XXX Find a way to change the colors of the STOCK-icons on the fly and then
+   *     add these 10 colors to the list of colors that can be changed through
+   *     the preferences.
+   *
+  fprintf (pf, "%s: %s\n", PRS_GUI_COLORIZED_FG, prefs.gui_colorized_fg);
+  fprintf (pf, "%s: %s\n", PRS_GUI_COLORIZED_BG, prefs.gui_colorized_bg);
+  */
+
+  fprintf (pf, "\n# TCP stream window color preferences.\n");
+  fprintf (pf, "# Each value is a six digit hexadecimal color value in the form rrggbb.\n");
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_STREAM_CL_FG,
+    (prefs.st_client_fg.red * 255 / 65535),
+    (prefs.st_client_fg.green * 255 / 65535),
+    (prefs.st_client_fg.blue * 255 / 65535));
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_STREAM_CL_BG,
+    (prefs.st_client_bg.red * 255 / 65535),
+    (prefs.st_client_bg.green * 255 / 65535),
+    (prefs.st_client_bg.blue * 255 / 65535));
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_STREAM_SR_FG,
+    (prefs.st_server_fg.red * 255 / 65535),
+    (prefs.st_server_fg.green * 255 / 65535),
+    (prefs.st_server_fg.blue * 255 / 65535));
+  fprintf (pf, "%s: %02x%02x%02x\n", PRS_STREAM_SR_BG,
+    (prefs.st_server_bg.red * 255 / 65535),
+    (prefs.st_server_bg.green * 255 / 65535),
+    (prefs.st_server_bg.blue * 255 / 65535));
+
+  fprintf(pf, "\n######## Console: logging level ########\n");
+  fprintf(pf, "# (debugging only, not in the Preferences dialog)\n");
+  fprintf(pf, "# A bitmask of glib log levels:\n"
+          "# G_LOG_LEVEL_ERROR    = 4\n"
+          "# G_LOG_LEVEL_CRITICAL = 8\n"
+          "# G_LOG_LEVEL_WARNING  = 16\n"
+          "# G_LOG_LEVEL_MESSAGE  = 32\n"
+          "# G_LOG_LEVEL_INFO     = 64\n"
+          "# G_LOG_LEVEL_DEBUG    = 128\n");
+
+  fprintf(pf, PRS_CONSOLE_LOG_LEVEL ": %u\n",
+          prefs.console_log_level);
+
+  fprintf(pf, "\n####### Capture ########\n");
+
+  if (prefs.capture_device != NULL) {
+    fprintf(pf, "\n# Default capture device\n");
+    fprintf(pf, PRS_CAP_DEVICE ": %s\n", prefs.capture_device);
+  }
+
+  if (prefs.capture_devices_linktypes != NULL) {
+    fprintf(pf, "\n# Interface link-layer header types.\n");
+    fprintf(pf, "# A decimal number for the DLT.\n");
+    fprintf(pf, "# Ex: en0(1),en1(143),...\n");
+    fprintf(pf, PRS_CAP_DEVICES_LINKTYPES ": %s\n", prefs.capture_devices_linktypes);
+  }
+
+  if (prefs.capture_devices_descr != NULL) {
+    fprintf(pf, "\n# Interface descriptions.\n");
+    fprintf(pf, "# Ex: eth0(eth0 descr),eth1(eth1 descr),...\n");
+    fprintf(pf, PRS_CAP_DEVICES_DESCR ": %s\n", prefs.capture_devices_descr);
+  }
+
+  if (prefs.capture_devices_hide != NULL) {
+    fprintf(pf, "\n# Hide interface?\n");
+    fprintf(pf, "# Ex: eth0,eth3,...\n");
+    fprintf(pf, PRS_CAP_DEVICES_HIDE ": %s\n", prefs.capture_devices_hide);
+  }
+
+  fprintf(pf, "\n# Capture in promiscuous mode?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_CAP_PROM_MODE ": %s\n",
+		  prefs.capture_prom_mode == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Update packet list in real time during capture?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_CAP_REAL_TIME ": %s\n",
+		  prefs.capture_real_time == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Scroll packet list during capture?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_CAP_AUTO_SCROLL ": %s\n",
+		  prefs.capture_auto_scroll == TRUE ? "TRUE" : "FALSE");
+
+  fprintf(pf, "\n# Show capture info dialog while capturing?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_CAP_SHOW_INFO ": %s\n",
+		  prefs.capture_show_info == TRUE ? "TRUE" : "FALSE");
+
+  fprintf (pf, "\n######## Printing ########\n");
+
+  fprintf (pf, "\n# Can be one of \"text\" or \"postscript\".\n"
+    "print.format: %s\n", pr_formats[prefs.pr_format]);
+
+  fprintf (pf, "\n# Can be one of \"command\" or \"file\".\n"
+    "print.destination: %s\n", pr_dests[prefs.pr_dest]);
+
+  fprintf (pf, "\n# This is the file that gets written to when the "
+    "destination is set to \"file\"\n"
+    "%s: %s\n", PRS_PRINT_FILE, prefs.pr_file);
+
+  fprintf (pf, "\n# Output gets piped to this command when the destination "
+    "is set to \"command\"\n"
+    "%s: %s\n", PRS_PRINT_CMD, prefs.pr_cmd);
+
+  fprintf(pf, "\n####### Name Resolution ########\n");
+
+  fprintf(pf, "\n# Resolve addresses to names?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive), or a list of address types to resolve.\n");
+  fprintf(pf, PRS_NAME_RESOLVE ": %s\n",
+		  name_resolve_to_string(prefs.name_resolve));
+
+  fprintf(pf, "\n# Name resolution concurrency.\n");
+  fprintf(pf, "# A decimal number.\n");
+  fprintf(pf, PRS_NAME_RESOLVE_CONCURRENCY ": %d\n",
+		  prefs.name_resolve_concurrency);
+
+  fprintf(pf, "\n####### Taps/Statistics ########\n");
+
+  fprintf(pf, "\n# Tap update interval in ms.\n");
+  fprintf(pf, "# An integer value greater between 100 and 10000.\n");
+  fprintf(pf, PRS_TAP_UPDATE_INTERVAL ": %d\n",
+          prefs.tap_update_interval);
+  fprintf(pf, "\n# Maximum visible channels in RTP Player window.\n");
+  fprintf(pf, "# An integer value greater than 0.\n");
+  fprintf(pf, PRS_RTP_PLAYER_MAX_VISIBLE ": %d\n",
+		  prefs.rtp_player_max_visible);
+
+  fprintf(pf, "\n####### Protocols ########\n");
+
+  fprintf(pf, "\n# Display hidden items in packet details pane?\n");
+  fprintf(pf, "# TRUE or FALSE (case-insensitive).\n");
+  fprintf(pf, PRS_DISPLAY_HIDDEN_PROTO_ITEMS ": %s\n",
+		  prefs.display_hidden_proto_items == TRUE ? "TRUE" : "FALSE");
+
+  pe_tree_foreach(prefs_modules, write_module_prefs, pf);
+
+  fclose(pf);
+
+  /* XXX - catch I/O errors (e.g. "ran out of disk space") and return
+     an error indication, or maybe write to a new preferences file and
+     rename that file on top of the old one only if there are not I/O
+     errors. */
+  return 0;
+}
+
+/* Copy a set of preferences. */
+void
+copy_prefs(e_prefs *dest, e_prefs *src)
+{
+  fmt_data *src_cfmt, *dest_cfmt;
+  GList *entry;
+
+  dest->pr_format = src->pr_format;
+  dest->pr_dest = src->pr_dest;
+  dest->pr_file = g_strdup(src->pr_file);
+  dest->pr_cmd = g_strdup(src->pr_cmd);
+  dest->col_list = NULL;
+  for (entry = src->col_list; entry != NULL; entry = g_list_next(entry)) {
+    src_cfmt = entry->data;
+    dest_cfmt = (fmt_data *) g_malloc(sizeof(fmt_data));
+    dest_cfmt->title = g_strdup(src_cfmt->title);
+    dest_cfmt->fmt = g_strdup(src_cfmt->fmt);
+    if (src_cfmt->custom_field) {
+      dest_cfmt->custom_field = g_strdup(src_cfmt->custom_field);
+    } else {
+      dest_cfmt->custom_field = NULL;
+    }
+    dest->col_list = g_list_append(dest->col_list, dest_cfmt);
+  }
+  dest->num_cols = src->num_cols;
+  dest->st_client_fg = src->st_client_fg;
+  dest->st_client_bg = src->st_client_bg;
+  dest->st_server_fg = src->st_server_fg;
+  dest->st_server_bg = src->st_server_bg;
+  dest->gui_scrollbar_on_right = src->gui_scrollbar_on_right;
+  dest->gui_plist_sel_browse = src->gui_plist_sel_browse;
+  dest->gui_ptree_sel_browse = src->gui_ptree_sel_browse;
+  dest->gui_altern_colors = src->gui_altern_colors;
+  dest->filter_toolbar_show_in_statusbar = src->filter_toolbar_show_in_statusbar;
+  dest->gui_ptree_line_style = src->gui_ptree_line_style;
+  dest->gui_ptree_expander_style = src->gui_ptree_expander_style;
+  dest->gui_hex_dump_highlight_style = src->gui_hex_dump_highlight_style;
+  dest->gui_toolbar_main_style = src->gui_toolbar_main_style;
+  dest->gui_fileopen_dir = g_strdup(src->gui_fileopen_dir);
+  dest->gui_console_open = src->gui_console_open;
+  dest->gui_fileopen_style = src->gui_fileopen_style;
+  dest->gui_fileopen_preview = src->gui_fileopen_preview;
+  dest->gui_ask_unsaved = src->gui_ask_unsaved;
+  dest->gui_find_wrap = src->gui_find_wrap;
+  dest->gui_use_pref_save = src->gui_use_pref_save;
+  dest->gui_layout_type = src->gui_layout_type;
+  dest->gui_layout_content_1 = src->gui_layout_content_1;
+  dest->gui_layout_content_2 = src->gui_layout_content_2;
+  dest->gui_layout_content_3 = src->gui_layout_content_3;
+  dest->gui_font_name = g_strdup(src->gui_font_name);
+  dest->gui_marked_fg = src->gui_marked_fg;
+  dest->gui_marked_bg = src->gui_marked_bg;
+  dest->gui_geometry_save_position = src->gui_geometry_save_position;
+  dest->gui_geometry_save_size = src->gui_geometry_save_size;
+  dest->gui_geometry_save_maximized = src->gui_geometry_save_maximized;
+  dest->gui_macosx_style = src->gui_macosx_style;
+  dest->gui_webbrowser = g_strdup(src->gui_webbrowser);
+  dest->gui_window_title = g_strdup(src->gui_window_title);
+  dest->gui_start_title = g_strdup(src->gui_start_title);
+  dest->gui_version_in_start_page = src->gui_version_in_start_page;
+  dest->console_log_level = src->console_log_level;
+/*  values for the capture dialog box */
+  dest->capture_device = g_strdup(src->capture_device);
+  dest->capture_devices_linktypes = g_strdup(src->capture_devices_linktypes);
+  dest->capture_devices_descr = g_strdup(src->capture_devices_descr);
+  dest->capture_devices_hide = g_strdup(src->capture_devices_hide);
+  dest->capture_prom_mode = src->capture_prom_mode;
+  dest->capture_real_time = src->capture_real_time;
+  dest->capture_auto_scroll = src->capture_auto_scroll;
+  dest->capture_show_info = src->capture_show_info;
+  dest->name_resolve = src->name_resolve;
+  dest->name_resolve_concurrency = src->name_resolve_concurrency;
+  dest->display_hidden_proto_items = src->display_hidden_proto_items;
+
+}
+
+/* Free a set of preferences. */
+void
+free_prefs(e_prefs *pr)
+{
+  if (pr->pr_file != NULL) {
+    g_free(pr->pr_file);
+    pr->pr_file = NULL;
+  }
+  if (pr->pr_cmd != NULL) {
+    g_free(pr->pr_cmd);
+    pr->pr_cmd = NULL;
+  }
+  free_col_info(pr);
+  if (pr->gui_font_name != NULL) {
+    g_free(pr->gui_font_name);
+    pr->gui_font_name = NULL;
+  }
+  if (pr->gui_fileopen_dir != NULL) {
+    g_free(pr->gui_fileopen_dir);
+    pr->gui_fileopen_dir = NULL;
+  }
+  g_free(pr->gui_webbrowser);
+  pr->gui_webbrowser = NULL;
+  if (pr->gui_window_title != NULL) {
+    g_free(pr->gui_window_title);
+    pr->gui_window_title = NULL;
+  }
+  if (pr->gui_start_title != NULL) {
+    g_free(pr->gui_start_title);
+    pr->gui_start_title = NULL;
+  }
+  if (pr->capture_device != NULL) {
+    g_free(pr->capture_device);
+    pr->capture_device = NULL;
+  }
+  if (pr->capture_devices_linktypes != NULL) {
+    g_free(pr->capture_devices_linktypes);
+    pr->capture_devices_linktypes = NULL;
+  }
+  if (pr->capture_devices_descr != NULL) {
+    g_free(pr->capture_devices_descr);
+    pr->capture_devices_descr = NULL;
+  }
+  if (pr->capture_devices_hide != NULL) {
+    g_free(pr->capture_devices_hide);
+    pr->capture_devices_hide = NULL;
+  }
+}
+
+static void
+free_col_info(e_prefs *pr)
+{
+  fmt_data *cfmt;
+
+  while (pr->col_list != NULL) {
+    cfmt = pr->col_list->data;
+    g_free(cfmt->title);
+    g_free(cfmt->fmt);
+    if (cfmt->custom_field) {
+      g_free(cfmt->custom_field);
+    }
+    g_free(cfmt);
+    pr->col_list = g_list_remove_link(pr->col_list, pr->col_list);
+  }
+  g_list_free(pr->col_list);
+  pr->col_list = NULL;
+}
+
+
