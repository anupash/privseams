--- ethereal-0.10.14/epan/dissectors/Makefile.common	2005-12-27 00:21:11.000000000 -0200
+++ ethereal-0.10.14-i3/epan/dissectors/Makefile.common	2006-02-08 14:17:14.000000000 -0200
@@ -330,6 +330,8 @@
 	packet-hsrp.c	\
 	packet-http.c	\
 	packet-hyperscsi.c	\
+	packet-i3.c	\
+	packet-i3_server.c	\
 	packet-iapp.c	\
 	packet-iax2.c	\
 	packet-ib.c	\
--- ethereal-0.10.14/epan/dissectors/packet-i3.c	1969-12-31 21:00:00.000000000 -0300
+++ ethereal-0.10.14-i3/epan/dissectors/packet-i3.c	2006-02-08 14:46:59.000000000 -0200
@@ -0,0 +1,899 @@
+/* packet-i3.c
+ * Routines for Internet Indirection Infrastructure dissection
+ * Copyright 2000, Fernando Henrique Gines <fgines@larc.usp.br>,
+ * Thiago Tadeu Tsai <ttsai@larc.usp.br>,
+ * Fernando de Oliveira Gil <fgil@larc.usp.br>,
+ * Ernesto Jin Hoa Lee <ejhlee@larc.usp.br>,
+ * Danielle Paquiela Camilato <danielle@larc.usp.br>
+ *
+ * Packet dissector created by LARC (Laboratory of Computer 
+ * Architecture and Networks) for disassembling I3 packets.
+ *
+ * Update 2006-02-08:
+ *  Added protocol preferences for dissecting Hi3 data.
+ *
+ *
+ * $Id: README.developer 13227 2005-02-01 15:45:03Z jmayer $
+ *
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "packet-i3.h"
+
+#define UDP_PORT             20000
+
+/* Initialize the protocol and registered fields */
+static int proto_i3 = -1;
+
+/* set the udp port */
+static int gbl_prefPort = UDP_PORT;
+
+/*I3 header*/
+static int hf_i3_version = -1; /* I3 Version*/
+static int hf_i3_flags = -1; /* Flags */
+static int hf_i3_flags_data = -1;
+static int hf_i3_flags_option_list = -1;
+static int hf_i3_flags_first_hop = -1;
+static int hf_i3_stacklen = -1;
+static int hf_i3_stacks = 0;
+static int hf_i3_stack_id = -1;
+static int hf_i3_option_list_len = -1;
+static int hf_i3_option_addr_opttype = -1;
+
+/*I3 option return address*/
+static int hf_i3_option_addr = -1;
+static int hf_i3_option_addr_datatype = -1;
+static int hf_i3_option_addr_stack = -1;
+static int hf_i3_option_addr_ipv4 = -1;
+static int hf_i3_option_addr_ipv6 = -1;
+static int hf_i3_option_addr_ipv4_nat_host = -1;
+static int hf_i3_option_addr_ipv4_nat_natserver = -1;
+static int hf_i3_option_addr_ipv4_nat_i3server = -1;
+static int hf_i3_option_addr_port = -1;
+
+/*I3 option trigger*/
+static int hf_i3_option_trigger = -1;
+static int hf_i3_option_trigger_flags = -1;
+static int hf_i3_option_trigger_id = -1;
+static int hf_i3_option_trigger_prefixlen = -1;
+static int hf_i3_option_trigger_nonce = -1;
+static int hf_i3_option_trigger_addr_datatype = -1;
+static int hf_i3_option_trigger_addr_stack = -1;
+static int hf_i3_option_trigger_addr_ipv4 = -1;
+static int hf_i3_option_trigger_addr_ipv4_nat_host = -1;
+static int hf_i3_option_trigger_addr_ipv4_nat_natserver = -1;
+static int hf_i3_option_trigger_addr_ipv4_nat_i3server = -1;
+static int hf_i3_option_trigger_addr_ipv6 = -1;
+static int hf_i3_option_trigger_addr_port = -1;
+static int hf_i3_option_trigger_public =-1;
+static int hf_i3_option_trigger_token_type = -1;
+static int hf_i3_option_trigger_token_depth =-1;
+static int hf_i3_option_trigger_token_long_term_rate = -1;
+static int hf_i3_option_trigger_token_maximum_rate =-1;
+
+/*I3 header*/
+static guint8 i3h_flags = -1;
+static guint8 i3h_stacklen = -1;
+static guint16 i3h_optlistlen = -1;
+static guint8 i3h_option_addr_opttype = -1;
+static gboolean i3h_error = FALSE;
+static guint8 i3h_trigger_flags = -1;
+
+/*I3 option return address*/
+static guint8 i3h_option_addr_datatype = -1;
+static guint32 i3h_option_addr_stack = -1;
+static guint32 i3h_option_addr_ipv4 = -1;
+static guint32 i3h_option_addr_ipv6 = -1;
+
+/*I3 option trigger*/
+static guint8 i3h_option_trigger_addr_datatype = -1;
+static guint32 i3h_option_trigger_addr_ipv4 = -1;
+static guint32 i3h_option_trigger_addr_ipv6 = -1;
+
+/*I3 options list*/
+static const value_string hf_i3_option_addr_opttype_vals[] = {
+	{ I3_OPT_SENDER,		"I3 Option SENDER" },
+	{ I3_OPT_TRIGGER_INSERT,		"I3 Option TRIGGER INSERT" },
+	{ I3_OPT_TRIGGER_CHALLENGE,		"I3 Option TRIGGER CHALLENGE" },
+	{ I3_OPT_TRIGGER_ACK,		"I3 Option ACK" },
+	{ I3_OPT_TRIGGER_REMOVE,		"I3 Option REMOVE" },
+	{ I3_OPT_TRIGGER_NOT_PRESENT,		"I3 Option TRIGGET NOT PRESENT" },
+	{ I3_OPT_REQUEST_FOR_CACHE,		"I3 Option REQUEST FOR CACHE" },
+	{ I3_OPT_CACHE_ADDR,		"I3 Option CACHE ADDRESS" },
+	{ I3_OPT_FORCE_CACHE_ADDR,		"I3 Option FORCE CACHE ADDRESS" },
+	{ I3_OPT_CONSTRAINT_FAILED,		"I3 Option CONSTRAINT FAILED" },
+	{ I3_OPT_ROUTE_BROKEN,		"I3 Option ROUTE BROKEN" },
+	{ I3_OPT_REQUEST_FOR_CACHE_SHORTCUT,	"I3 Option REQUEST FOR CACHE SHORTCUT" },
+	{ I3_OPT_CACHE_SHORTCUT_ADDR,	"I3 Option CACHE SHORTCUT ADDRESS" },
+	{ I3_OPT_CACHE_DEST_ADDR,	"I3 Option CACHE DESTINATION ADDRESS" },
+	{ I3_OPT_REQUEST_FOR_CACHE_SHORTCUT_INDIR,	"I3 Option REQUEST FOR CACHE SHORTCUR INDIRECT" }, 
+	{ I3_OPT_DESTINATION,              "I3 Option DESTINATION" },
+	{ I3_OPT_TRIGGER_RATELIMIT,        "I3 Option TRIGGER RATE LIMIT" }
+};
+
+/*I3 Flags*/
+static const value_string hf_i3_flags_vals[] = {
+	{ 0x10, "Flags (Data)" },
+	{ 0x20, "Flags (Option List)" },
+	{ 0x30, "Flags (Data, Option List)" },
+	{ 0x40, "Flags (First Hop)" },
+	{ 0x50, "Flags (Data, First Hop)" },
+	{ 0x60, "Flags (Option List, First Hop)" },
+	{ 0x70, "Flags (Data, Option List, First Hop)" }
+};
+
+/**/
+static const value_string hf_i3_option_addr_datatype_vals[] = {
+	{ I3_ADDR_TYPE_STACK,		"ID" },
+	{ I3_ADDR_TYPE_IPv4,		"IPv4" },
+	{ I3_ADDR_TYPE_IPv6,		"IPv6" },
+	{ I3_ADDR_TYPE_IPv4_NAT,	"NAT" }
+};
+
+/* Decode data as Hi3 */
+static gboolean i3_dissect_hi3 = FALSE;
+
+/* Functions */
+
+char * i3_opt(int n);
+char * i3_flags(int n);
+static dissector_handle_t i3_handle;
+static dissector_handle_t data_handle;
+
+void
+decode_data(tvbuff_t *tvb, int offset, packet_info *pinfo,proto_tree *tree) {
+
+gint  len, reported_len;
+tvbuff_t  *next_tvb;
+
+		if(i3_dissect_hi3)
+			data_handle = find_dissector("ip");
+		else
+			data_handle = find_dissector("data");
+
+		len = tvb_length_remaining(tvb, offset);
+
+		next_tvb = tvb_new_subset(tvb, offset, len, len);
+	
+		call_dissector(data_handle,next_tvb, pinfo, tree);
+	
+  return;
+}
+
+
+/* Initialize the subtree pointers */
+static gint ett_i3 = -1;
+static gint ett_i3_flags = -1;
+static gint ett_i3_stacks = -1;
+static gint ett_i3_options = -1;
+
+
+/* Code to actually dissect the packets */
+extern void
+dissect_i3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+
+/* Set up structures needed to add the protocol subtree and manage it */
+	proto_item *ti, *tf;
+	proto_tree *i3_tree, *field_tree = NULL;
+	int	offset = 0;
+	tvbuff_t *next_tvb = NULL;
+	gboolean hi3_data = FALSE;
+
+	i3h_flags = tvb_get_guint8(tvb, 1);
+	i3h_stacklen = tvb_get_guint8(tvb, 2); /* Determine the stack length  */
+	offset += (32 * i3h_stacklen) + 3;
+	
+	if(i3h_flags & I3_OPTION_LIST){
+		i3h_optlistlen = tvb_get_ntohs(tvb, offset);
+		offset+=2;
+	} else {
+		i3h_optlistlen = 0;
+	}
+
+	i3h_option_addr_opttype = tvb_get_guint8(tvb, offset);
+	i3h_option_addr_datatype = tvb_get_guint8(tvb, offset + 1);
+
+
+/* Make entries in Protocol column and Info column on summary display */
+	if (check_col(pinfo->cinfo, COL_PROTOCOL))
+	{
+		col_set_str(pinfo->cinfo, COL_PROTOCOL, "i3");
+	}
+
+	if (check_col(pinfo->cinfo, COL_INFO)) { 
+		col_set_str(pinfo->cinfo, COL_INFO, "i3");
+		col_add_str(pinfo->cinfo, COL_INFO, i3_flags(i3h_flags));
+	}
+	
+	if (tree) {
+		/* create display subtree for the protocol */
+		offset = 0;
+		ti = proto_tree_add_item(tree, proto_i3, tvb, offset, -1, FALSE);
+
+		i3_tree = proto_item_add_subtree(ti, ett_i3); /* Adding I3 Tree */
+
+		proto_tree_add_item(i3_tree,
+		    hf_i3_version, tvb, offset, 1, FALSE); /* I3 Version */
+		offset++;
+		/* Adding Flags Subtree*/
+		    tf = proto_tree_add_uint_format(i3_tree, hf_i3_flags, tvb, offset, 1,
+		i3h_flags, "%s 0x%02x", i3_flags(i3h_flags), i3h_flags);
+
+		    field_tree = proto_item_add_subtree(tf, ett_i3_flags);
+		    proto_tree_add_boolean(field_tree, hf_i3_flags_data, tvb, offset, 1, i3h_flags); /* I3 Flag Data */
+		    proto_tree_add_boolean(field_tree, hf_i3_flags_option_list, tvb, offset, 1, i3h_flags); /* I3 Flag Option List */
+		    proto_tree_add_boolean(field_tree, hf_i3_flags_first_hop, tvb, offset, 1, i3h_flags); /* I3 Flag First Hop */
+		offset++;
+
+		proto_tree_add_item(i3_tree,
+		    hf_i3_stacklen, tvb, offset, 1, FALSE); /* I3 Stack Length*/
+		offset++;
+
+		if (i3h_stacklen > 0) {
+			tf = proto_tree_add_uint_format(i3_tree, hf_i3_stacks, tvb, offset, i3h_stacklen * 32,
+			i3h_stacklen, "I3 Stack"); /* All I3 Stack Selected */
+
+			field_tree = proto_item_add_subtree(tf, ett_i3_stacks); /* Creating I3 Stack Subtree */
+			while (i3h_stacklen > 0) {
+				proto_tree_add_item(field_tree,
+                	           hf_i3_stack_id, tvb, offset, 32, FALSE); /* Adding ID to the Stack */
+		               i3h_stacklen--;
+	                	offset += 32;
+      		  	}
+		}
+		
+		/* Testing if I3_OPTION_LIST is set */
+		if (i3h_flags & I3_OPTION_LIST) {
+			proto_tree_add_item(i3_tree,
+			    hf_i3_option_list_len, tvb, offset, 2, FALSE); /* I3 Option List Length */
+			offset += 2;
+			i3h_optlistlen -= 2;		
+			/* Reading I3 Options */
+			while (i3h_optlistlen > 0) {
+
+				if (i3h_option_addr_opttype == I3_OPT_SENDER ||
+					i3h_option_addr_opttype == I3_OPT_DESTINATION) {
+
+					/* Adding ret address */
+					/*     
+					       return address
+					       ---------------
+					      | opt type      |
+					       ---------------
+					      | data type     |
+					       ---------------
+					      | i3 stack or   |
+					      | IPv4 addr or  |
+					      | IPv6 addr or  |
+					      | NAT addr      |
+					      -----------------
+					*/
+					tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_opttype, offset, 1);
+
+					tf = proto_tree_add_uint_format(i3_tree, hf_i3_option_trigger, tvb, offset, 1,
+					    FALSE , "Option: %s", i3_opt(i3h_option_addr_opttype));
+
+		      		        field_tree = proto_item_add_subtree(tf, ett_i3_options);
+
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_addr_opttype, tvb, offset, 1, FALSE); /* I3 Option Type */
+					offset++;
+
+					tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_datatype, offset, 1);
+
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_addr_datatype, tvb, offset, 1, i3h_option_addr_datatype); /* I3 Data Type */
+					offset++;
+					i3h_optlistlen -= 2;
+
+					/* Testing I3 OPTION DATA TYPE */
+					if (i3h_option_addr_datatype == I3_ADDR_TYPE_STACK) {
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_stack, tvb, offset, 32, FALSE); /* I3 ID */
+						i3h_optlistlen -= 32;
+						offset += 32;
+					} else if (i3h_option_addr_datatype == I3_ADDR_TYPE_IPv4) {
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_addr_ipv4, tvb, offset, 4, i3h_option_addr_ipv4); /* I3 IPv4 Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+					} else if (i3h_option_addr_datatype == I3_ADDR_TYPE_IPv6) {
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_ipv6, offset, 16);
+						proto_tree_add_ipv6(field_tree,
+						    hf_i3_option_addr_ipv6, tvb, offset, 16, i3h_option_addr_ipv6); /* I3 IPv6 Address */
+						offset += 16;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_port, tvb, offset, 2, FALSE); /* I3 IPv6 Port */
+						offset += 2;
+						i3h_optlistlen -= 18;
+					} else if (i3h_option_addr_datatype == I3_ADDR_TYPE_IPv4_NAT) {
+						/*
+						IPv4_NAT contains:
+						
+					       ----------------
+					      | IPv4 Host Addr | Internal IP (Host)
+					       ----------------
+					      | Port           |
+					       ----------------
+					      | IPv4 NAT Addr  | NAT IPv4 Address
+					       ----------------
+					      | Port           |
+					       ----------------
+					      | IPv4 i3 server | First i3 Server IPv4 Address
+					       ----------------
+					      | Port           |
+					       ----------------
+						
+						*/
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_addr_ipv4_nat_host, tvb, offset, 4, i3h_option_addr_ipv4); /* Host IP Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_addr_ipv4_nat_natserver, tvb, offset, 4, i3h_option_addr_ipv4); /* NAT Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_addr_ipv4_nat_i3server, tvb, offset, 4, i3h_option_addr_ipv4); /* First i3 Server Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+					} else {
+					/* Unknow Data Type */
+					}
+				} else if ((i3h_option_addr_opttype == I3_OPT_TRIGGER_INSERT) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_TRIGGER_CHALLENGE) ||
+			           (i3h_option_addr_opttype == I3_OPT_CONSTRAINT_FAILED) ||
+        			   (i3h_option_addr_opttype == I3_OPT_TRIGGER_ACK) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_TRIGGER_REMOVE) ||
+	        		   (i3h_option_addr_opttype == I3_OPT_CACHE_ADDR) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_FORCE_CACHE_ADDR) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_CACHE_DEST_ADDR) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_CACHE_SHORTCUT_ADDR) ||
+	        		   (i3h_option_addr_opttype == I3_OPT_ROUTE_BROKEN)) {
+
+					/*
+					      trigger
+					      ---------------
+					     | opt type      |
+					      ---------------
+					     | flags         |                
+					      ---------------                 
+					     |               |
+					     | i3 id (32B)   |
+					     |    ...        |
+					      ---------------
+					     |prefix len (2B)|
+					      ---------------
+					     |               |
+					     | Nonce (16B)   |
+					     |    ...        |
+					      ---------------
+					     |  Data type    |
+					      ---------------
+					     | IPv4 addr or  |
+					     | IPv6 addr or  |
+					     | I3_stack      |
+					     ----------------
+					     |  I3 Public    |
+					     |   Trigger     |
+					     ----------------
+					*/
+
+					tvb_memcpy(tvb, (guint8 *)&i3h_option_addr_opttype, offset, 1);
+
+					tf = proto_tree_add_uint_format(i3_tree, hf_i3_option_trigger, tvb, offset, 1,
+					    FALSE , "Option: %s", i3_opt(i3h_option_addr_opttype));
+
+		      		        field_tree = proto_item_add_subtree(tf, ett_i3_options);
+
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_addr_opttype, tvb, offset, 1, FALSE); /* I3 Option Type */
+
+					offset++;
+
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_trigger_flags, tvb, offset, 1, FALSE); /* Trigger Flags */
+					
+					i3h_trigger_flags = tvb_get_guint8(tvb, offset);
+
+					offset++;
+					i3h_optlistlen -= 2;
+
+					proto_tree_add_item(field_tree,
+	                	           hf_i3_option_trigger_id, tvb, offset, 32, FALSE); /* I3 ID */
+
+					offset += 32;
+					i3h_optlistlen -= 32;
+
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_trigger_prefixlen, tvb, offset, 2, FALSE); /* Prefix Length */
+
+					offset += 2;
+					i3h_optlistlen -= 2;
+
+					proto_tree_add_item(field_tree,
+	                	           hf_i3_option_trigger_nonce, tvb, offset, 16, FALSE); /* Nonce */
+
+					offset += 16;
+					i3h_optlistlen -= 16;
+
+
+					tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_datatype, offset, 1);
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_trigger_addr_datatype, tvb, offset, 1, i3h_option_trigger_addr_datatype); /* I3 Data Type */
+					offset++;
+					i3h_optlistlen --;
+
+					/*
+					         i3_addr
+					        ---------------
+					       |   type        |
+					        ---------------
+					       | IPv4 addr or  |
+					       | IPv6 addr or  |
+					       | NAT addr or   |
+					       | I3_stack      |
+					       ----------------
+					*/
+					
+					/* Testing I3 Data Type */
+					if (i3h_option_trigger_addr_datatype == I3_ADDR_TYPE_STACK) {
+						proto_tree_add_item(field_tree,
+						    hf_i3_stacklen, tvb, offset, 1, FALSE); /* I3 Stack Length*/
+						offset++;
+						i3h_optlistlen --;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_stack, tvb, offset, 32, FALSE); /* I3 ID */
+						i3h_optlistlen -= 32;
+						offset += 32;
+					} else if (i3h_option_trigger_addr_datatype == I3_ADDR_TYPE_IPv4) {
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_trigger_addr_ipv4, tvb, offset, 4, i3h_option_trigger_addr_ipv4); /* I3 IPv4 Address*/
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_public, tvb, offset, 16, FALSE); /* I3 Public Trigger */ 
+						offset += 16;
+						i3h_optlistlen -= 16;
+					} else if (i3h_option_trigger_addr_datatype == I3_ADDR_TYPE_IPv6) {
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_ipv6, offset, 16);
+						proto_tree_add_ipv6(field_tree,
+						    hf_i3_option_trigger_addr_ipv6, tvb, offset, 16, i3h_option_trigger_addr_ipv6); /* I3 IPv6 Address*/
+						offset += 16;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_port, tvb, offset, 2, FALSE); /* I3 IPv6 Port */
+						offset += 2;
+						i3h_optlistlen -= 18;
+
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_public, tvb, offset, 16, FALSE); /* I3 Public Trigger */ 
+						offset += 16;
+						i3h_optlistlen -= 16;
+					} else if (i3h_option_addr_datatype == I3_ADDR_TYPE_IPv4_NAT) {
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_trigger_addr_ipv4_nat_host, tvb, offset,
+						    4, i3h_option_trigger_addr_ipv4); /* Host IP Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_trigger_addr_ipv4_nat_natserver, tvb, offset,
+						    4, i3h_option_trigger_addr_ipv4); /* NAT Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+
+						tvb_memcpy(tvb, (guint8 *)&i3h_option_trigger_addr_ipv4, offset, 4);
+						proto_tree_add_ipv4(field_tree,
+						    hf_i3_option_trigger_addr_ipv4_nat_i3server, tvb, offset, 
+                                                    4, i3h_option_addr_ipv4); /* First i3 Server Address */
+						offset += 4;
+						proto_tree_add_item(field_tree,
+						    hf_i3_option_trigger_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+						offset += 2;
+						i3h_optlistlen -= 6;
+					} else {
+					i3h_error = TRUE;
+					proto_tree_add_text(field_tree, tvb, offset, -1, "INVALID OPTION");
+					/* Unknown Data Type */
+					}
+
+
+					if (i3h_trigger_flags & I3_TRIGGER_FLAG_RATE_LIMIT) {
+/* It's NOT tested yet
+						proto_tree_add_item(field_tree,
+		                	           hf_i3_option_trigger_token_type, tvb, offset, 1, FALSE); 
+*/	
+						offset += 1;
+						i3h_optlistlen -= 1;
+	
+/*						proto_tree_add_item(field_tree,
+	        	        	           hf_i3_option_trigger_token_depth, tvb, offset, 4, FALSE); 
+*/	
+						offset += 4;
+						i3h_optlistlen -= 4;
+	
+/*						proto_tree_add_item(field_tree,
+	        	        	           hf_i3_option_trigger_token_long_term_rate, tvb, offset, 4, FALSE); 
+*/	
+						offset += 4;
+						i3h_optlistlen -= 4;
+
+/*						proto_tree_add_item(field_tree,
+	        	        	           hf_i3_option_trigger_token_maximum_rate, tvb, offset, 4, FALSE); 
+*/	
+						offset += 4;
+						i3h_optlistlen -= 4;
+					}
+
+				
+				} else if ((i3h_option_addr_opttype == I3_OPT_REQUEST_FOR_CACHE) ||
+		        	   (i3h_option_addr_opttype == I3_OPT_REQUEST_FOR_CACHE_SHORTCUT) ||
+	        		   (i3h_option_addr_opttype == I3_OPT_REQUEST_FOR_CACHE_SHORTCUT_INDIR) ){
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_addr_opttype, tvb, offset, 1, FALSE); /* I3 Option */
+					offset++;
+					i3h_optlistlen--;
+
+				} else if ((i3h_option_addr_opttype == I3_OPT_TRIGGER_NOT_PRESENT) ||
+	        		   (i3h_option_addr_opttype == I3_OPT_TRIGGER_RATELIMIT) ){
+					proto_tree_add_item(field_tree,
+					    hf_i3_option_addr_opttype, tvb, offset, 1, FALSE); /* I3 Option */
+					offset++;
+					i3h_optlistlen--;
+
+					proto_tree_add_item(field_tree,
+	                	           hf_i3_option_trigger_id, tvb, offset, 32, FALSE); /* I3 ID */
+
+					offset += 32;
+					i3h_optlistlen -= 32;
+
+				} else {
+				/* Invalid Option  */
+					proto_tree_add_text(field_tree, tvb, offset, -1, "INVALID OPTION");
+					offset++;
+					i3h_optlistlen--;
+					i3h_error = TRUE;
+				}
+				if (i3h_optlistlen > 0 ) {
+					i3h_option_addr_opttype = tvb_get_guint8(tvb, offset);
+				}
+			}
+		} else {
+		}
+			
+		if (tvb_length_remaining(tvb, offset) > 0) {
+				decode_data(tvb, offset, pinfo, tree);
+				hi3_data = TRUE;
+		}
+	}
+	
+	/* Set summary info for Hi3 */
+	if(i3_dissect_hi3 && hi3_data)
+	{
+		if (check_col(pinfo->cinfo, COL_PROTOCOL))
+			col_add_str(pinfo->cinfo, COL_PROTOCOL, "Hi3");
+	}
+}
+
+
+void
+proto_reg_handoff_i3(void)
+{
+	dissector_add("udp.port", gbl_prefPort, i3_handle);
+}
+
+
+/* Register the protocol with Ethereal */
+
+void
+proto_register_i3(void)
+{
+	module_t *i3_module;
+	static hf_register_info hf[] = {
+		{ &hf_i3_version,
+			{ "Version",           "i3.version",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"Version", HFILL }},
+		{ &hf_i3_flags,
+			{ "Flags",           "i3.flags",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"Flags", HFILL }},
+		{ &hf_i3_flags_data,
+			{ "I3 Data",           "i3.flags.data",
+			FT_BOOLEAN, 8, TFS(&flags_set_truth), I3_DATA,          
+			"Flag", HFILL }},
+		{ &hf_i3_flags_option_list,
+			{ "I3 Option List",           "i3.flags.optlist",
+			FT_BOOLEAN, 8, TFS(&flags_set_truth), I3_OPTION_LIST,          
+			"Flag", HFILL }},
+		{ &hf_i3_flags_first_hop,
+			{ "I3 First Hop",           "i3.flags.firsthop",
+			FT_BOOLEAN, 8, TFS(&flags_set_truth), I3_FIRST_HOP,     
+			"Flag", HFILL }},
+		{ &hf_i3_stacklen,
+			{ "Stack Length",           "i3.stacklen",
+			FT_UINT8, BASE_DEC, NULL, 0x0,          
+			"Stack Length", HFILL }},
+		{ &hf_i3_stacks,
+			{ "Stacks",           "i3.stack",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"Stacks", HFILL }},
+		{ &hf_i3_stack_id,
+			{ "ID",           "i3.stack.id",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"ID", HFILL }},
+		{ &hf_i3_option_list_len,
+			{ "Option List Length",           "i3.optlistlen",
+			FT_UINT16, BASE_DEC, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_opttype,
+			{ "Option Type",           "i3.option.addr.opttype",
+			FT_UINT8, BASE_HEX, VALS(hf_i3_option_addr_opttype_vals), 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr,
+			{ "Option Return Address",           "i3.option.addr",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"Option Return Address", HFILL }},
+		{ &hf_i3_option_addr_datatype,
+			{ "Data Type",           "i3.option.addr.datatype",
+			FT_UINT8, BASE_HEX, VALS(hf_i3_option_addr_datatype_vals), 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_ipv4,
+			{ "IPv4",           "i3.option.addr.ipv4",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_ipv4_nat_host,
+			{ "NAT Host",           "i3.option.addr.nat.host",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_ipv4_nat_natserver,
+			{ "NAT server",           "i3.option.addr.nat.natserver",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_ipv4_nat_i3server,
+			{ "First i3 Server",           "i3.option.addr.nat.i3server",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_ipv6,
+			{ "IPv6",           "i3.option.addr.ipv6",
+			FT_IPv6, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_stack,
+			{ "Stack",           "i3.option.addr.stack",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_addr_port,
+			{ "Port",           "i3.option.addr.port",
+			FT_UINT16, BASE_DEC, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger,
+			{ "Option Trigger",           "i3.option.trigger",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"Option Trigger", HFILL }},
+		{ &hf_i3_option_trigger_flags,
+			{ "Flags",           "i3.option.trigger.flags",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_id,
+			{ "ID",           "i3.option.trigger.id",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_prefixlen,
+			{ "Prefix Length",           "i3.option.trigger.id",
+			FT_UINT16, BASE_DEC, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_nonce,
+			{ "Nonce",           "i3.option.trigger.nonce",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_datatype,
+			{ "Data type",           "i3.option.trigger.addr.datatype",
+			FT_UINT8, BASE_HEX, VALS(hf_i3_option_addr_datatype_vals), 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_stack,
+			{ "ID",           "i3.option.trigger.addr.id",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_ipv4,
+			{ "IPv4",           "i3.option.trigger.addr.ipv4",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_ipv4_nat_host,
+			{ "NAT host",           "i3.option.trigger.addr.nat.host",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_ipv4_nat_natserver,
+			{ "NAT server",           "i3.option.trigger.addr.nat.natserver",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_ipv4_nat_i3server,
+			{ "First i3 Server",           "i3.option.trigger.addr.nat.i3server",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_ipv6,
+			{ "IPv6",           "i3.option.trigger.addr.ipv6",
+			FT_IPv6, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_addr_port,
+			{ "Port",           "i3.option.trigger.addr.port",
+			FT_UINT16, BASE_DEC, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_token_type,
+			{ "Token Type",           "i3.option.trigger.token.type",
+			FT_UINT8, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_token_depth,
+			{ "Token Depth",           "i3.option.trigger.token.depth",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_token_long_term_rate,
+			{ "Token Long Term Rate",           "i3.option.trigger.token.longrate",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_token_maximum_rate,
+			{ "Token Maximum Rate",           "i3.option.trigger.token.maximumrate",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_option_trigger_public,
+			{ "Public Trigger",           "i3.option.trigger.public",
+			FT_BYTES, BASE_NONE, NULL, 0x0,          
+			"", HFILL }}
+	};
+
+/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_i3,
+		&ett_i3_flags,
+		&ett_i3_stacks,
+		&ett_i3_options
+	};
+	
+/* Register the protocol name and description */
+	proto_i3 = proto_register_protocol("Internet Indirection Infrastructure Protocol",
+	    "I3", "i3");
+
+/* Required function calls to register the header fields and subtrees used */
+	proto_register_field_array(proto_i3, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+
+	i3_handle = create_dissector_handle(dissect_i3,proto_i3);
+	
+/* Register configuration preferences */
+	i3_module = prefs_register_protocol(proto_i3, NULL);
+	prefs_register_bool_preference(i3_module, "dissect_hi3",
+	"Dissect data field as Hi3",
+	"Decode the I3 data field as Hi3.",
+	&i3_dissect_hi3);
+}
+
+char * i3_flags(int n)
+{
+     static char s[24];
+
+     switch (n)
+     {
+ 	case 0x10:
+ 	    sprintf(s, "Flags (Data)");
+ 	    break;
+ 	case 0x20:
+ 	    sprintf(s, "Flags (Option List)");
+ 	    break;
+ 	case 0x30:
+ 	    sprintf(s, "Flags (Data, Option List)");
+ 	    break;
+ 	case 0x40:
+ 	    sprintf(s, "Flags (First Hop)");
+ 	    break;
+ 	case 0x50:
+ 	    sprintf(s, "Flags (Data, First Hop)");
+ 	    break;
+ 	case 0x60:
+ 	    sprintf(s, "Flags (Option List, First Hop)");
+ 	    break;
+ 	case 0x70:
+ 	    sprintf(s, "Flags (Data, Option List, First Hop)");
+ 	    break;
+ 	default:
+ 	    sprintf(s, "?UNKNOWN?");
+ 	    break;
+     }
+
+     return s;
+
+}
+
+char * i3_opt(int n)
+{
+     static char s[24];
+     
+     switch (n)
+     {
+ 	case I3_OPT_SENDER:
+ 	    sprintf(s, "I3 Option SENDER");
+ 	    break;
+ 	case I3_OPT_TRIGGER_INSERT:
+ 	    sprintf(s, "I3 Option TRIGGER INSERT");
+ 	    break;
+ 	case I3_OPT_TRIGGER_CHALLENGE:
+ 	    sprintf(s, "I3 Option TRIGGER CHALLENGE");
+ 	    break;
+ 	case I3_OPT_TRIGGER_ACK:
+ 	    sprintf(s, "I3 Option ACK");
+ 	    break;
+ 	case I3_OPT_TRIGGER_REMOVE:
+ 	    sprintf(s, "I3 Option REMOVE");
+ 	    break;
+ 	case I3_OPT_TRIGGER_NOT_PRESENT:
+ 	    sprintf(s, "I3 Option TRIGGET NOT PRESENT");
+ 	    break;
+ 	case I3_OPT_REQUEST_FOR_CACHE:
+ 	    sprintf(s, "I3 Option REQUEST FOR CACHE");
+ 	    break;
+ 	case I3_OPT_CACHE_ADDR:
+ 	    sprintf(s, "I3 Option CACHE ADDRESS");
+ 	    break;
+ 	case I3_OPT_FORCE_CACHE_ADDR:
+ 	    sprintf(s, "I3 Option FORCE CACHE ADDRESS");
+ 	    break;
+ 	case I3_OPT_CONSTRAINT_FAILED:
+ 	    sprintf(s, "I3 Option CONSTRAINT FAILED");
+ 	    break;
+ 	case I3_OPT_ROUTE_BROKEN:
+ 	    sprintf(s, "I3 Option ROUTE BROKEN");
+ 	    break;
+ 	default:
+ 	    sprintf(s, "?UNKNOWN?");
+ 	    break;
+     }
+ 
+     return s;
+}
--- ethereal-0.10.14/epan/dissectors/packet-i3.h	1969-12-31 21:00:00.000000000 -0300
+++ ethereal-0.10.14-i3/epan/dissectors/packet-i3.h	2006-02-08 14:47:43.000000000 -0200
@@ -0,0 +1,95 @@
+/* packet-i3.h
+ * Routines for Internet Indirection Infrastructure dissection
+ * Copyright 2000, Fernando Henrique Gines <fgines@larc.usp.br>,
+ * Thiago Tadeu Tsai <ttsai@larc.usp.br>,
+ * Fernando de Oliveira Gil <fgil@larc.usp.br>,
+ * Ernesto Jin Hoa Lee <ejhlee@larc.usp.br>,
+ * Danielle Paquiela Camilato <danielle@larc.usp.br>
+ *
+ * Packet dissector created by LARC (Laboratory of Computer
+ * Architecture and Networks) for disassembling I3 packets.
+ *
+ * $Id: README.developer 13227 2005-02-01 15:45:03Z jmayer $
+ *
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include <epan/packet.h>
+#include <epan/prefs.h>
+
+#define I3_DATA         0x10
+#define I3_OPTION_LIST  0x20
+#define I3_FIRST_HOP    0x40
+
+#define I3_ADDR_TYPE_STACK 0x10
+#define I3_ADDR_TYPE_IPv4  0x20
+#define I3_ADDR_TYPE_IPv6  0x30
+#define I3_ADDR_TYPE_IPv4_NAT   0x40
+
+
+#define I3_ID_TYPE_PUBLIC       0x10
+#define I3_ID_TYPE_PRIVATE      0x20
+
+
+#define I3_OPT_SENDER                   0x01
+#define I3_OPT_TRIGGER_INSERT           0x02
+#define I3_OPT_TRIGGER_CHALLENGE        0x03
+#define I3_OPT_TRIGGER_ACK              0x04
+#define I3_OPT_TRIGGER_REMOVE           0x05
+#define I3_OPT_TRIGGER_NOT_PRESENT      0x06
+#define I3_OPT_REQUEST_FOR_CACHE        0x07
+#define I3_OPT_CACHE_ADDR               0x08
+#define I3_OPT_FORCE_CACHE_ADDR         0x09
+#define I3_OPT_CONSTRAINT_FAILED        0x10
+#define I3_OPT_ROUTE_BROKEN             0x11
+#define I3_OPT_REQUEST_FOR_CACHE_SHORTCUT 0x12
+#define I3_OPT_CACHE_SHORTCUT_ADDR      0x13
+#define I3_OPT_CACHE_DEST_ADDR          0x14
+#define I3_OPT_REQUEST_FOR_CACHE_SHORTCUT_INDIR 0x15
+#define I3_OPT_DESTINATION              0x20
+#define I3_OPT_TRIGGER_RATELIMIT        0x30
+
+
+#define I3_TRIGGER_FLAG_ALLOW_SHORTCUT  0x1
+#define I3_TRIGGER_FLAG_RATE_LIMIT      0x2
+
+/* I3 Port */
+
+void decode_data(tvbuff_t *tvb, int offset, packet_info *pinfo,proto_tree *tree);
+
+extern void dissect_i3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+void proto_reg_handoff_i3(void);
+
+void proto_register_i3(void);
+
+char * i3_flags(int n);
+
+char * i3_opt(int n);
--- ethereal-0.10.14/epan/dissectors/packet-i3_server.c	1969-12-31 21:00:00.000000000 -0300
+++ ethereal-0.10.14-i3/epan/dissectors/packet-i3_server.c	2006-02-08 14:46:34.000000000 -0200
@@ -0,0 +1,382 @@
+/* packet-i3_server.c
+ * Routines for Internet Indirection Infrastructure dissection
+ * Copyright 2000, Fernando Henrique Gines <fgines@larc.usp.br>,
+ * Thiago Tadeu Tsai <ttsai@larc.usp.br>,
+ * Fernando de Oliveira Gil <fgil@larc.usp.br>,
+ * Ernesto Jin Hoa Lee <ejhlee@larc.usp.br>,
+ * Danielle Paquiela Camilato <danielle@larc.usp.br>
+ *
+ * Packet dissector created by LARC (Laboratory of Computer
+ * Architecture and Networks) for disassembling I3 packets.
+ *
+ * $Id: README.developer 13227 2005-02-01 15:45:03Z jmayer $
+ *
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "packet-i3.h" 
+
+#include <glib.h>
+
+#include <epan/packet.h>
+#include <epan/prefs.h>
+
+#define     CHORD_ROUTE		0x00    /* data packet */
+#define     CHORD_FS          	0x01	/* find_successor */
+#define     CHORD_FS_REPL     	0x02	/* find_successor reply */
+#define     CHORD_STAB        	0x03	/* get predecessor */
+#define     CHORD_STAB_REPL   	0x04 	/* ... response */
+#define     CHORD_NOTIFY        0x05	/* notify (predecessor) */
+#define     CHORD_PING        	0x06	/* are you alive? */
+#define     CHORD_PONG        	0x07	/* yes, I am */
+#define     CHORD_GET_FINGERS 	0x08	/* get your finger list */
+#define     CHORD_REPL_FINGERS	0x09	/* .. here is my finger list */
+
+
+/* Initialize the protocol and registered fields */
+static int proto_i3server = -1;
+
+/* set the udp port */
+#define UDP_PORT             32768
+static int gbl_prefPort = UDP_PORT;
+
+/*I3 header*/
+static int hf_i3_server_type = -1;
+static int hf_i3_server_finger = -1;
+static int hf_i3_server_lenght = -1;
+static int hf_i3_server_id = -1;
+static int hf_i3_server_addr_ipv4 = -1;
+static int hf_i3_server_addr_port = -1;
+static int hf_i3_server_timestamp = -1;
+
+
+/*static int hf_i3_message =-1;*/
+
+/*I3 header*/
+static guint8 i3h_server_type = -1;
+
+/*I3 server address*/
+static guint32 i3h_server_addr_ipv4 = -1;
+
+/*I3 server types*/
+static const value_string hf_i3_server_types_vals[] = {
+	{ CHORD_ROUTE,    	"Data Packet"},
+	{ CHORD_FS,		"Request Find Successor" },
+	{ CHORD_FS_REPL,	"Find Successor Reply" },
+	{ CHORD_STAB,		"Request Predecessor" },
+	{ CHORD_STAB_REPL,	"Predecessor Reply" },
+	{ CHORD_NOTIFY,		"Notify (predecessor)" },
+	{ CHORD_PING,		"Ping" },
+	{ CHORD_PONG,		"Pong" },
+	{ CHORD_GET_FINGERS,	"Request Finger List" },
+	{ CHORD_REPL_FINGERS,	"Finger List Reply" }
+};
+
+
+/* Functions */
+char * format_i3_server_types(int n);
+
+
+/*char * i3_server_type(int n);*/
+static dissector_handle_t i3server_handle;
+static dissector_handle_t data_handle;
+
+static int hf_i3_server_temp = 0;
+
+void
+decode_data_i3server(tvbuff_t *tvb, int offset, packet_info *pinfo,proto_tree *tree) {
+
+gint  len;
+tvbuff_t  *next_tvb;
+
+		data_handle = find_dissector("data");
+
+		len = tvb_length_remaining(tvb, offset);
+
+	    	next_tvb = tvb_new_subset(tvb, offset, len, len);
+		if (hf_i3_server_temp == 0) {
+			call_dissector(data_handle,next_tvb, pinfo, tree);
+		} else {
+			dissect_i3(next_tvb, pinfo, tree);
+		}
+	
+  return;
+}
+
+
+/* Initialize the subtree pointers */
+static gint ett_i3server = -1;
+
+
+/* Code to actually dissect the packets */
+static void
+dissect_i3server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+
+/* Set up structures needed to add the protocol subtree and manage it */
+	proto_item *ti;
+	proto_tree *i3server_tree = NULL;
+	int	offset = 0;
+
+	i3h_server_type = tvb_get_guint8(tvb, 0);
+
+
+/* Make entries in Protocol column and Info column on summary display */
+	if (check_col(pinfo->cinfo, COL_PROTOCOL)) 
+		col_set_str(pinfo->cinfo, COL_PROTOCOL, "i3 Server");
+
+	if (check_col(pinfo->cinfo, COL_INFO)) { 
+		col_set_str(pinfo->cinfo, COL_INFO, "i3 Server");
+		col_add_str(pinfo->cinfo, COL_INFO, format_i3_server_types(i3h_server_type));
+	}
+
+	if (tree) {
+/* create display subtree for the protocol */
+		offset = 0;
+		ti = proto_tree_add_item(tree, proto_i3server, tvb, offset, -1, FALSE);
+
+		i3server_tree = proto_item_add_subtree(ti, ett_i3server); /* Adding I3 Tree */
+
+		/*
+		     ---------------
+		     | Type (1 byte) |
+		      ---------------
+		*/
+
+		proto_tree_add_item(i3server_tree,
+		    hf_i3_server_type, tvb, offset, 1, FALSE); /* I3 Version */
+		offset++;
+
+		if ((i3h_server_type == CHORD_ROUTE) ||
+			(i3h_server_type == CHORD_FS_REPL)) {
+		/*
+		      ---------------
+		     |    Finger     |                			     
+		     |   (1 byte)    |                			     
+		      ---------------
+		*/
+	
+		proto_tree_add_item(i3server_tree,
+		    hf_i3_server_finger, tvb, offset, 1, FALSE); /* I3 The one byte */
+		offset++;
+		}
+
+		if ((i3h_server_type == CHORD_ROUTE) ||
+			(i3h_server_type == CHORD_FS) ||
+		        (i3h_server_type == CHORD_FS_REPL) ||
+		        (i3h_server_type == CHORD_STAB) ||
+		        (i3h_server_type == CHORD_STAB_REPL) ||
+			(i3h_server_type == CHORD_NOTIFY) ||
+			(i3h_server_type == CHORD_GET_FINGERS) ||
+			(i3h_server_type == CHORD_REPL_FINGERS)) {
+			/*
+			      ---------------
+			     | I3 server id  |                
+			     |  (20 bytes)   |
+			      ---------------
+
+			*/
+			proto_tree_add_item(i3server_tree,
+               	           hf_i3_server_id, tvb, offset, 20, FALSE); /* I3 ID */
+			offset += 20;
+
+		}
+		
+		if ((i3h_server_type == CHORD_ROUTE)) {
+		/*
+		      ---------------
+		     |    Lenght     |                			     
+		     |   (2 bytes)   |                			     
+		      ---------------
+		*/
+		
+		proto_tree_add_item(i3server_tree,
+		    hf_i3_server_lenght, tvb, offset, 2, FALSE);
+		offset+=2;
+		/*
+		Chama o proximo
+		static void dissect_i3(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+		tvbuff_t *next_tvb;
+		next_tvb = tvb_new_subset(tvb, offset, len, reported_len);i
+		*/
+		hf_i3_server_temp = 1;
+		}
+		
+
+		/*If desnecessario (todos), mas deixe assim por enquanto*/
+		if ((i3h_server_type == CHORD_FS) ||
+		        (i3h_server_type == CHORD_FS_REPL) ||
+		        (i3h_server_type == CHORD_STAB) ||
+			(i3h_server_type == CHORD_STAB_REPL) ||
+			(i3h_server_type == CHORD_NOTIFY) ||
+			(i3h_server_type == CHORD_PING) ||
+			(i3h_server_type == CHORD_PONG) ||
+			(i3h_server_type == CHORD_GET_FINGERS) ||
+			(i3h_server_type == CHORD_REPL_FINGERS)) {
+			/*
+			      ---------------
+			     | IPv4 addr     |
+			     |   (4 bytes)   |
+			      ---------------
+			     | IPv4 port     |
+			     |   (2 bytes)   |
+			      ---------------
+			*/
+
+			tvb_memcpy(tvb, (guint8 *)&i3h_server_addr_ipv4, offset, 4);
+			proto_tree_add_ipv4(i3server_tree,
+		        hf_i3_server_addr_ipv4, tvb, offset, 4, i3h_server_addr_ipv4); /* I3 IPv4 Address*/
+			offset += 4;
+			proto_tree_add_item(i3server_tree,
+			hf_i3_server_addr_port, tvb, offset, 2, FALSE); /* I3 IPv4 Port */
+			offset += 2;
+			}
+
+		if ((i3h_server_type == CHORD_PING) ||
+		    (i3h_server_type == CHORD_PONG) ||
+		    (i3h_server_type == CHORD_GET_FINGERS)) {
+			/*
+			      ---------------
+			     |   Timestamp   |
+			     |   (4 bytes)   |
+			      ---------------
+			*/
+		proto_tree_add_item(i3server_tree,
+	            hf_i3_server_timestamp, tvb, offset, 4, FALSE); /* Timestamp usec */
+		offset += 4;
+		}
+		if (tvb_length_remaining(tvb, offset) > 0) {
+
+		decode_data_i3server(tvb, offset, pinfo, tree);
+		}
+	}
+}
+
+
+void
+proto_reg_handoff_i3server(void)
+{
+	dissector_add("udp.port", gbl_prefPort, i3server_handle);
+}
+
+
+/* Register the protocol with Ethereal */
+
+void
+proto_register_i3server(void)
+{                 
+	static hf_register_info hf[] = {
+		{ &hf_i3_server_type,
+			{ "Type",           "i3server.type",
+			FT_UINT8, BASE_HEX, VALS(hf_i3_server_types_vals), 0x0,          
+			"Type", HFILL }},
+		{ &hf_i3_server_finger,
+			{ "Finger",           "i3server.finger",
+			FT_UINT8, BASE_DEC, NULL, 0x0,          
+			"finger", HFILL }},
+		{ &hf_i3_server_id,
+			{ "ID",           "i3server.id",
+			FT_BYTES, BASE_HEX, NULL, 0x0,          
+			"ID", HFILL }},
+		{ &hf_i3_server_lenght,
+			{ "Lenght",           "i3server.lenght",
+			FT_UINT8, BASE_DEC, NULL, 0x0,          
+			"lenght", HFILL }},
+		{ &hf_i3_server_addr_ipv4,
+			{ "IPv4",           "i3server.addr.ipv4",
+			FT_IPv4, BASE_NONE, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_server_addr_port,
+			{ "Port",           "i3server.addr.port",
+			FT_UINT16, BASE_DEC, NULL, 0x0,          
+			"", HFILL }},
+		{ &hf_i3_server_timestamp,
+			{ "Timestamp usec",           "i3server.timestamp",
+			FT_UINT32, BASE_DEC, NULL, 0x0,          
+			"", HFILL }}
+	};
+
+/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_i3server
+	};
+
+/* Register the protocol name and description */
+	proto_i3server = proto_register_protocol("Internet Indirection Infrastructure Protocol - Server",
+	    "I3SERVER", "i3server");
+
+/* Required function calls to register the header fields and subtrees used */
+	proto_register_field_array(proto_i3server, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+
+	i3server_handle = create_dissector_handle(dissect_i3server,proto_i3server);
+}
+
+char * format_i3_server_types(int n)
+{
+     static char s[24];
+
+     switch (n)
+     {
+ 	case 0x00:
+ 	    sprintf(s, "Data Packet");
+ 	    break;
+ 	case 0x01:
+ 	    sprintf(s, "Request Find Successor");
+ 	    break;
+ 	case 0x02:
+ 	    sprintf(s, "Find Successor Reply");
+ 	    break;
+ 	case 0x03:
+ 	    sprintf(s, "Request Predecessor");
+ 	    break;
+ 	case 0x04:
+ 	    sprintf(s, "Predecessor Reply");
+ 	    break;
+ 	case 0x05:
+ 	    sprintf(s, "Notify (predecessor)");
+ 	    break;
+ 	case 0x06:
+ 	    sprintf(s, "Ping");
+ 	    break;
+ 	case 0x07:
+ 	    sprintf(s, "Pong");
+ 	    break;
+ 	case 0x08:
+ 	    sprintf(s, "Request Finger List");
+ 	    break;
+ 	case 0x09:
+ 	    sprintf(s, "Finger List Reply");
+ 	    break;
+ 	default:
+ 	    sprintf(s, "?UNKNOWN?");
+ 	    break;
+     }
+
+     return s;
+
+}
--- ethereal-0.10.14/epan/prefs.c	2005-12-27 00:21:16.000000000 -0200
+++ ethereal-0.10.14-i3/epan/prefs.c	2006-02-08 14:29:10.000000000 -0200
@@ -2000,6 +2000,10 @@
           pref = find_preference(module, "desegment_headers");
         else if (strcmp(dotp, "desegment_http_body") == 0)
           pref = find_preference(module, "desegment_body");
+      } else if (strcmp(module->name, "i3") == 0) {
+        /* Handle i3 preferences. */
+        if (strcmp(dotp, "i3_dissect_hi3") == 0)
+          pref = find_preference(module, "dissect_hi3");
       } else if (strcmp(module->name, "smpp") == 0) {
         /* Handle preferences that moved from SMPP. */
         module_t *new_module = find_module("gsm-sms-ud");
@@ -2648,4 +2652,3 @@
   g_list_free(pr->col_list);
   pr->col_list = NULL;
 }
-
