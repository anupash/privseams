<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <!-- NOTE: TO GET A TEXT VERSION FROM THIS, TYPE "xmlto txt HOWTO.xml"  -->
  <title>HIPL User Manual</title>
  <chapter>
    <title>Warning</title>
    <para>
      HIPL code is currently at a very experimental level. Use at your own
      responsibility! Using VMWare, Xen or User Mode Linux is recommended for
      testing HIPL.
      </para>
    </chapter>
  <chapter>
    <title>Software Requirements</title>
    <para>
     It is recommended that you get the latest source and compile it yourself.
     As an alternative, you may download frozen, binary releases of the kernel
     from http://hipl.hiit.fi/hipl/release/. However, before reporting any
     bugs, please have a go with the latest source instead of the binaries
     because the bug may already have been resolved upstream. There is also a
     Knoppix based live cd available from the HIPL download pages.
    </para>
    <para>
      As the first requirement, you also need know the basics on Linux kernel
      compilation and usage. Refer to linux/README for further instructions.
    </para>
    <para>
      You need the following software to build and run the HIPL 
      software bundle:
    </para>
    <para>
      * Mandatory
    </para>
    <para>
     &nbsp; * Linux Operating System
    </para>
    <para>
      &nbsp;* A BEET patched Linux 2.6 kernel with dummy device,
      XFRM_USER, IPv6, IPsec and AES+3DES+SHA1 support. Also,
      you should have also CONFIG_IP_ADVANCED_ROUTER and
      CONFIG_IP_MULTIPLE_TABLES as built-in.
    </para>
    <para>
      &nbsp;* OpenSSL-library and developer headers
    </para>
    <para>
      &nbsp;* GNU make
    </para>
    <para>
      &nbsp;* the latest versions of autoconf, automake, autoreconf and libtool
    </para>
    <para>
      &nbsp;* iproute and its development headers
    </para>
    <para>
      &nbsp;* wxgtk 2.6.2 and libgtk-2.x library and development headers
    </para>
    <para>
      * Optional Software Requirements
    </para>
    <para>
      &nbsp;* iputils-ping (or netkit-ping): ping, ping6
    </para>
    <para>
      &nbsp;* ipsec-tools: setkey
    </para>
    <para>
      &nbsp;* iptables userspace tools and IPv6 netfilter in the kernel
              (for the HIP firewall only)
    </para>
    <para>
      &nbsp;* iptables development headers (HIP firewall)
    </para>
    <para>
      &nbsp;* glib (www.gtk.org) and development headers (HIP firewall)
    </para>
    <para>
      &nbsp;* netcat6
    </para>
    <para>
      &nbsp;* latex, dvips, dvipdf, fig2dev, doxygen (for building the
      HIPL source code documentation)
    </para>
    <para>
      &nbsp;* java compiler for "jip" (java hip resolver) if you want to
              build HIP enabled java programs
    </para>
    <para>*Network Requirements</para>
    <para>
      &nbsp;* Make sure that the end-host firewall does not block HIP
              and ESP traffic (try "iptables -L") or otherwise you won't get
              any traffic through. As a workaround, you try enabling the
              NAT mode at the end-host.
    </para>
    <para>
      &nbsp;* Make sure that a middlebox is not blocking HIP traffic.
              If there is firewall between the machines, it might have been
              configured to block HIP or ESP traffic. If there is a NAT
              between the machines, it might also be blocking traffic.
              Either make sure that the middlebox allows HIP and ESP traffic,
              or you can try enabling the NAT mode at the end-host.
    </para>
  </chapter>
  <chapter>
    <title> Building the HIPL Documentation</title>
    <para>
     Architectural documentation:
    </para>
    <para>
     &nbsp; % cd hipl/doc
    </para>
    <para>
     &nbsp; % make design_choices.dvi design_choices.ps design_choices.pdf
    </para>
	<para>
	 Source code documentation:
	</para>
	<para>
	 &nbsp; % cd hipl/doc
	</para>
	<para>
	 &nbsp; % doxygen
	</para>
  </chapter>
  <chapter>
    <title>Compiling the Kernel</title>
    
    <para>
      If you haven't configured linux kernel before, please consult
      linux/README before doing that. We have some example
      configurations files in hipl/test/configs for "typical" systems. You
      can use one of those as a template, and modify it to suite the needs
      of your system. Read hipl/test/configs/README before doing so.
    </para>
    <para>
      The 2.6 kernel series should be compilable with both gcc 2.9x and 3.x
      series. We recommend the latter.
    </para>
    <para>
      Download linux kernel 2.6.x.y. Compile the kernel with
      at least the following options:
    </para>
    <para>
      &nbsp;Legend: [*] built-in  [ ] excluded  &lt;M &gt; module  &lt; &gt; module capable
    </para>
    <para>
      &nbsp;Code maturity level options
    </para>
    <para>
      &nbsp;[*] Prompt for development and/or incomplete code/drivers
    </para>
    <para>
      &nbsp;Processor type and features
    </para>
    <para>
      &nbsp;Device Drivers ---&gt; Networking support ---&gt; Networking options
    </para>
    <para>
      &nbsp;[*] TCP/IP networking
    </para>
    <para>
      &nbsp;[*] The IPv6 protocol (EXPERIMENTAL)
    </para>
    <para>
      IPsec, IPv6 security support, SHA1 and 3DES should be auto enabled as
      dependencies after you have selected HIP. We recommend that you
      compile HIP as a kernel module, and the IPv6 support as built-in.
    </para>
    <para>
      The hipd tries to probe the necessary kernel modules automatically,
      However, should this fail, you should make sure that you have
      configured your /etc/modules accordingly. Insert "xfrm6_tunnel", 
      "xfrm4_tunnel", "xfrm_user", "dummy", "esp6", "esp4", "ipv6", 
      "aes", "crypto_null", and "des" to your /etc/modules.
    </para>
  </chapter>
  <chapter>
    <title>Compiling Userspace Applications</title>
    <para>
      After you have successfully compiled and installed the HIP kernel and
      rebooted both of the hosts, you need to compile the userspace
      applications in order to use HIP. Start by moving to the top level directory
      of HIPL:
      </para>
    <para>
      &nbsp;cd hipl
    </para>
    <para>
      If the file autogen.sh exists (to test type ls autogen.sh), run it:
    </para>
    <para>
      &nbsp;./autogen.sh
    </para>
    <para>
      Next, build the hipd, libinet6, tools and test directory as follows:
    </para>
    <para>
      &nbsp;./configure &amp;&amp; make
    </para>
    <para>
      It is not necessary to "make install" the applications. You can
      execute them straight from their source directories. Note that making
      from the top directory does not currently build e.g. java libraries or
      telnet. Follow the instructions presented later in this document to
      build them.
    </para>
    <para>
      Some features, like the HIP firewall are not compiled by default.
      Run "./configure --enable-FEATURE" to compile those.
      See "./configure --help" for a full list of options.
    </para>
  </chapter>
  <chapter>
    <title>Testing a HIP connection between two hosts</title>
    <para>
      HIPL developers test HIP using two machines called crash (3ffe::1) and
      oops (3ffe::2). They are used through this whole document as examples
      even though you probably have your own naming and addressing
      conventions. It is possible to use IPv4 addresses on-wire as well
      but the applications being used need to support IPv6 currently.
      </para>
    <para>
      We expect that you have two hosts for testing HIP which will be
      referred to as "crash" and "oops". You should run these commands in
      the testing hosts as root. conntest-client-gai and
      conntest-server can also be run as a non-root user, with
      conntest-server using port numbers less than 1024 still requires root
      privileges.
    </para>
    <para>
      oops:
    </para>
    <para>
      &nbsp;ifconfig eth0 inet6 add 3ffe::2/64
    </para>
    <para>
      &nbsp;cd somewhere/hipl
    </para>
    <para>
      &nbsp;hipd/hipd # (to start as a background daemon process, add -b flag)
    </para>
    <para>
      &nbsp;test/conntest-server tcp 1111
    </para>
    <para>
      Crash will act as the connection initiator, so we need to configure
      the hosts files of crash (note: use of IPv4 addresses is also possible):
    </para>
    <para>
      crash:
    </para>
    <para>
      &nbsp;/etc/hosts:
    </para>
    <para>
      &nbsp;&nbsp;3ffe::2 oops
      </para>
    <para>
     &nbsp; /etc/hip/hosts:
      </para>
    <para>
      &nbsp;&nbsp;HIT_OF_OOPS oops
    </para>
    <para>
      &nbsp;ifconfig eth0 inet6 add 3ffe::1/64
      </para>
    <para>
      &nbsp;cd somewhere/hipl
    </para>
    <para>
      &nbsp;hipd/hipd
    </para>
    <para>
      &nbsp;test/conntest-client-gai oops tcp 1111
    </para>
    <para>
      &nbsp;&lt;type some text in crash, press enter and ctrl+d and you
      &nbsp;should see some text appearing in the output of the hosts&gt;
    </para>
    <para>
      This will setup a HIP connection between the two hosts (it may take a
      while if you are using virtual machines). You should replace
      HIT_OF_XXX with the HIT of the host XXX. The hip daemon loads (and
      creates if necessary) the host identities from /etc/hip automatically.
      If you want to know the HITs of the localhost, run "ifconfig dummy0" or
      "ip addr show dummy0".
    </para>
    <para>
      Mappings between HITs and IP addresses are usually set up
      automatically with the hosts files. Manual configuration is also
      possible but not necessary:
    </para>
    <para>
      &nbsp;tools/hipconf add map PEER_HIT PEER_IP
    </para>
    <para>
      It is also possible to use DNS or OpenDHT for the mappings. See the
      relevant sections from this document.
    </para>
    <para>
      Link local IPv6 addresses are not supported well, so do not use
      them. Use global IPv6 addresses instead for testing. The reason for
      this is that it is hard to know if the peer belongs to the same local
      network as we are or not.
      </para>
    <para>
      See the log messages for information about the result of HIP base
      exchange and USAGI IPSec negotiation. Tcpdump or ethereal are good
      tools for dumping the network traffic during the base exchange.
      For tcpdump, you can use "tcpdump -n -i any esp or proto 253 or 
      port 50500" to catch HIP-only traffic.
    </para>
    <para>
      There is also a program called "hipsetup" in "hipl/test" directory for
      quick testing of the base exchange. Run it without arguments to see
      how it is used.
    </para>
  </chapter>
  <chapter>
    <title>Closing HIP Security Associations Manually</title>
     <para>
      You can use the hipconf tool to reset HIP SAs manually. Type
      "hipconf hip rst all" to close all SAs. 
     </para>
  </chapter>
  <chapter>
    <title>Testing Handover</title>
    <para>
      The handover code is based on draft-nikander-hip-mm-00
      specification. Not all of the features all yet implemented and the
      code quality is still far from bullet proof.
    </para>
    <para>
      A naive handover test example is below. It assumes that you have
      already established the base exchange between the hosts. You also need
      to have the nc6 tool which can be found from e.g. "www.freshmeat.net".
      The example is based on IPv6 addresses but you can also use IPv4.
    </para>
    <para>
      &nbsp;&lt;first, establish a HIP connection as intructed in the previous
      section&gt;
      </para>
    <para>
      &nbsp;oops  # nc6 -l -p 12345
      </para>
    <para>
      &nbsp;crash # nc6 &lt;the HIT of oops&gt; 12345
    </para>
    <para>
      &nbsp;crash # &lt;type some text and press enter&gt;
    </para>
    <para>
      &nbsp;oops  # &lt;the text that you typed in crash should appear in oops
      console&gt;
    </para>
    <para>
      &nbsp;crash # ifconfig eth0 inet6 del 3ffe::1/64
    </para>
    <para>
      &nbsp;crash # ifconfig eth0 inet6 add 3ffe::3/64
    </para>
    <para>
      &nbsp;crash # &lt;type some text and press enter&gt;
    </para>
    <para>
      &nbsp;oops  # &lt;the text that you typed in crash should appear in oops console&gt;
    </para>
    <para>
      Do not use link local addresses for the mobility scenarios for the
      hosts, unless you know what you are doing! For example, you are asking
      for trouble if you establish HIP SA between the mobile and
      correspondent node using link local addresses, and move the mobile
      node to a different network. The readdressing fails, because either
      node has no way of reaching the other node.
    </para>

    <para>
	Make sure to add the route for the new address as soon as the new address is 
	added. If the route is missing, the update packets might not get sent at all. 
	The daemon waits for a couple of seconds if a transmit of an update fails for 
	restransmitting it. 
    </para>
  </chapter>
  <chapter>
    <title> Compiling Java Applications</title>
    <para>
      HIPL software bundle includes also a java wrapper library to the HIP
      enabled libinet6 resolver library. The library is called "jip" and it
      is located in "path-to-hipl/jip". The use of the java library requires
      the HIP socket handler defined elsewhere in this document.
      </para>
    <para>
      You need to have either Blackdown or Sun java jdk 1.4.x or later to
      compile jip. The code does *not* work on java 1.3.  The installation
      assumes that you are using Blackdown 1.4 jdk, but if you are Sun jdk
      or other version of blackdown java, just set up the environment
      variable "JAVA_HOME" to point to the correct java installation
      directory.
    </para>
    <para>
      Compile libinet6.so and jip:
    </para>
    <para>
      # cd path-to-hipl/libinet6
    </para>
    <para>
      # make libinet6.so
    </para>
    <para>
      # cd ../jip
    </para>
    <para>
      # make
    </para>
    <para>
      The outcome of the previous operation is jip/jip.jar which you should
      use in your java applications to enable HIP. You can also run "make
      apidoc" to build the Javadoc documentation into the directory
      path-to-hipl/doc/jip-api.
    </para>
    <para>
      There are three example java applications in "test" directory that you
      must compile manually with the following procedure:
      </para>
    <para>
      # cd ../test
    </para>
    <para>
      # javac -classpath ../jip/jip.jar HipClient.java
    </para>
    <para>
      # javac -classpath ../jip/jip.jar HipUserkeyClient.java
    </para>
    <para>
      # javac -classpath ../jip/jip.jar HipServer.java
    </para>
    <para>
      You should have setup your networking environment as explained in
      section "Testing a HIP Connection Between Two Hosts", that is, you
      should have configured your /etc/hosts and /etc/hip/hosts
      properly. However, hipd will automatically create your public keys,
      so you don't have to worry about them.
    </para>
    <para>
      You cannot quite convert your normal Java networking application to a
      HIP application by just setting the socket factories.  You will need
      to either ensure that a used host name always resolves only to IPv6
      addresses, or that you never pass host names to methods in Socket and
      ServerSocket classes.  This latter can be achieved by using the
      resolver methods in the HipAddress class as is done in the example.
    </para>
    <para>
      Run the example applications as follows:
    </para>
    <para>
      crash # cd path-to-hipl/test
    </para>
    <para>
      crash # ./java HipServer 12345
    </para>
    <para>
      oops # cd test
    </para>
    <para>
      oops # ./java HipClient crash 12345 54321
    </para>
    <para>
      &lt;wait for the prompt, type some text and press enter&gt;
    </para>
    <para>
      The shell script "test/java" contains some LD_PRELOAD, library and
      class path information necessary for executing the HIP enabled java
      applications.
    </para>
    <para>
      The HipUserkeyClient class is otherwise the same as the HipClient
      class, except that its optional fourth argument is the name of a file
      from which to read an application-specified endpoint.
    </para>
  </chapter>
  <chapter>
    <title>HIP Enabled Telnet</title>
    <para>
      We have modified netkit-telnet from usagi (www.linux-ipv6.org) to
      support native HIP API. HIP is a compile time option, so that you can
      see the required modifications to the code (ifdef USE_HIP). Here's how
      you compile the telnet applications:
    </para>
    <para>
	# cd test/telnetd
    </para>
    <para>
	# ./configure
    </para>
    <para>
	# make
    </para>
    <para>
      # cd ../telnet
    </para>
    <para>
	# ./configure
    </para>
    <para>
	# make
    </para>
    <para>
       Before actually using the telnet, you should build and "insmod"
       the HIP kernel module. It is needed for telnet because it uses
       the native API (and not the legacy APIs). After that, you can
       experiment with telnet as follows:
    </para>
    <para>
	oops  # telnetd/telnetd -debug 12345
      </para>
    <para>
	crash # telnet/telnet -l username oops 12345
    </para>
    <para>
      Note: the username must be non-root.
    </para>
  </chapter>
  <chapter>
    <title> How to Use HIP in Other C Based Applications?</title>
    <para>
      Use one the following methods:
    </para>
    <para>
      1. Port it to use the native HIP API. See the telnet code for a
      practical example. The API is documented in url:
      http://hipl.hiit.fi/hipl/hip-native-api-final.pdf
    </para>
    <para>
      2. Relink the application to use the libinet6 library provided in the HIPL
      software bundle. Then, use either of the following methods:
    </para>
    <para>
      a) Set the AI_HIP flag in the getaddrinfo call. This will make the
      getaddrinfo function to return only HITs in the place of IP addresses
      (no IP addresses are returned). Also, the getaddrinfo function sends
      the HIT-to-IP-address mapping to the kernel.
      </para>
    <para>
      b) You are using the transparent mode in the resolver (see the
      HIP_TRANSPARENT_API compilation flag in libinet6/Makefile.in). Only
      relinking is required, no changes are needed in the application.
    </para>
    <para>
      3. Override the resolver library dynamically:
    </para>
    <para>
      a. Give the binary as an argument to hipconf: "hipconf run normal &lt;EXECUTABLE&gt;"
    </para>
    <para>
      b. Override the getaddrinfo function from the command line:
      http://www-106.ibm.com/developerworks/linux/library/l-glibc.html?ca=3Ddgr-ln=
    </para>
    <para>
	E.g. "env 
LD_PRELOAD=~/hipl--main--2.6/libinet6/.libs/libinet6.so:~/hipl--main--2.6/libhiptool/.libs/libhiptool.so 
 firefox hipserver.infrahip.net"
        Or add to .bash_profile LD_PRELOAD=libinet6.so:libhiptool.so and 
LD_LIBRARY_PATH=~/hipl--main--2.6/libhiptool/.libs/:~/hipl--main--2.6/libinet6/.libs/
    </para>
    <para>If you have installed the library using make install, you should reference /usr/lib instead of your home directory.
    </para>
    <para>
Make sure that libinet6 is compiled with 
HIP_TRANSPARENT_API on in libinet6/Makefile.in
CFLAGS += -DHIP_TRANSPARENT_API
    </para>
    <para>
      Note! Methods two and three assume two prequisites! First, the
      application must be IPv6-enabled in order to support HITs. Second, the 
      application must really use the getaddrinfo interface because 
      otherwise the getaddrinfo hack (i.e. sending HIT-to-IPv6 mapping 
      to the HIP module) does not work.
    </para>
    <para>
	Following applications use getaddrinfo on FC4: telnet, firefox, 
lynx, ssh. Not 
using getaddrinfo: ping, ping6, tla, svn.
    </para>
    <para>
    4. Insert the HIT to /etc/hosts, instead of /etc/hip/hosts. Then, add
       the HIT-to-IP mapping with "hipconf add map HIT IP". This is the
       quick-and-dirty method...
    </para>
    <para>
    5. Use the opportunistic mode as described in section "opportunistic mode".
    Remember that you need to link the application to libopphip, libinet6 and
    libhiptool (in that particular order). Use /usr/lib prefix for the libs or
    as follows (in case you did not make install):
    </para>
    <para>
    a. hipconf run opp &lt;EXECUTABLE&gt;
    </para>
    <para>
    b. export LD_PRELOAD=~/hipl--main--2.6//libopphip/.libs/libopphip.so:~/hipl--main--2.6/libinet6/.libs/libinet6.so:~/hipl--main--2.6/libhiptool/.libs/libhiptool.so
    </para>
    <para>
    6. Use HIP agent GUI to run the application. This is a new, not very well
       tested feature, but it should work. You can execute applications
       with GUI and edit their library-path as you like. Also you should be
       able to see list of processes you have executed from GUI.
    </para>
  </chapter>
  <chapter>
  <title>Testing HIP Rendezvous Server/Mechanism</title>
  <para>
   The rendezvous extension extends HIP and the HIP registration extension for
   initiating communication between HIP nodes via HIP rendezvous servers. The
   rendezvous server (RVS) serves as an initial contact point ("rendezvous
   point") for its clients. The clients of an RVS are HIP nodes that use the HIP
   Registration Protocol [draft-ietf-hip-registration-02] to register their
   HIT->IP address mappings with the RVS. After this registration, other HIP
   nodes can initiate a base exchange using the IP address of the RVS instead of
   the current IP address of the node they attempt to contact. Essentially, the
   clients of an RVS become reachable at the RVS' IP addresses.
  </para>
  <para>
   The rendezvous server is similar to the home agent in Mobile IP. The
   rendezvous server provides a stable IP for the responder and forwards
   the initial I1 packet to the current location of the responder.
  </para>
  <para>
   Prerequisites:
  </para>
  <para>
    ./configure --enable-rvs
  </para>
  <para>
   The hipconf tool must support the a) "rvs" and b) "service" options:
  </para>
  <para>
   a) hipconf add rvs &lt;HIT&gt; &lt;IP&gt;
  </para>
  <para>
   b) hipconf add service rvs
  </para>
  <para>
   The participants:
  </para>
  <para>
  I = Initiator, RVS = RendezVous Server, R = Responder
  </para>
  <para>
   For now it is best if all the hosts involved in communications have the
   rendezvous mechanism option enabled ("./configure --enable-rvs"). Although,
   for the initiator this should not be a requirement. Also, you should have run
   the base exchange once without rendezvous server to get familiar how the
   "/etc/hosts" and "/etc/hip/hosts" are configured.
  </para>
  <para>
   The idea is that I wants to connect to R's HIT but only knows RVS's IP
   address (and that RVS is representing R). We'll show how to use RVS
   the native HIP example applications (although you can do it with
   nc6 or the other conntest test applications).
  </para>
  <para>
   "/etc/hosts" and "/etc/hip/hosts" configurations:
  </para>
  <para>
   INITIATOR: At the initiator, you must modify the "/etc/hosts" file. In the
   file, responder's hostname must be mapped to the IP address of the rendezvous
   server. It must not be mapped to the responder's IP address, or otherwise the
   rendezvous server is not used at all! Thus in /etc/hosts you should have:
   &lt;RVS IP&gt; &lt;RESPONDER NAME&gt;. The "/etc/hip/hosts" file should
   contain the hostname and the HIT of the responder as in the normal base
   exchange execution: &lt;RESPONDER HIT&gt; &lt;RESPONDER NAME&gt;. Notice
   that there are currently four different HITs at each machine's "dummy0"
   interface. When the responder registers to the rendezvous server, it can
   choose any one four HITs. Please make sure that you use the same HIT here as
   &lt;RESPONDER HIT&gt; as what the responder chooses to register. You can
   check which HIT is used from the messages the responders's hipdaemon prints;
   there should be a line saying: "HIT being registered to rvs: &lt;HIT&gt;"
  </para> 
  <para>
   RVS: At the rendezvous server both files,"/etc/hosts" and "/etc/hip/hosts"
   are left blank ("/etc/hosts" can of course contain the non-hiprelated
   mappings). These files are left blank because the rendezvous server
   is assumed to have no information of its clients beforehand, it just
   offers the rendezvous service, and the responder then registers its
   HIT->IP mapping to the rendezvous server.
  </para>
  <para>
   RESPONDER: Also at the responder both files,"/etc/hosts" and 
   "/etc/hip/hosts" are left blank ("/etc/hosts" can of course contain the
   non-hiprelated mappings). The responder is assumed to know the IP address
   and the HIT of the rendezvous server, but this information is given as
   commandline parameters of "hipconf" tool.
  </para>
  <para>
   Steps:
  </para>
  <para>
   1. Start HIP daemon in each host: "hipd/hipd".
  </para>
  <para>
   2. At the rendezvous server we have to indicate that we're willing to offer
   rendezvous service: "tools/hipconf add service rvs".
  </para>
  <para>
   3. At the responder we have to register to the rendezvous server:
   "tools/hipconf add rvs &lt;RVS-HIT&gt; &lt;RVS-IP&gt;". This will establish
   a HIP SA between the rendezvous server and the responder.
  </para>
  <para>
   4. At the responder start a server listening for incoming connections:
   "test/conntest-server tcp 5000"
  </para>
  <para>
   5. At the initiator start a connection:
   "test/conntest-client-gai &lt;RESPONDER-HOSTNAME&gt; tcp 5000"
  </para>
  <para>
   6. At the initiator type some text and press CTRL + d. If everything works
   ok, the typed text should be now echoed at the responder.
  </para>
  <para>
    Notes:
  </para>
  <para>
   The rendezvous server is only supposed to relay the I1 packet. Once the
   I1 packet has been successfully relayed to the responder, all other traffic
   flows directly between the initiator and the responder.
  </para>
  <para>
   The implemented mechanism is simple forwarding of I1 packet with 
   source and  destination IP addresses rewritten.
  </para>
  <para>
   No changes were  made to the REA / mm-code,  which means that, for 
   example, the double jump scenario does not work.
  </para>
  <para>
   The mechanism does not comply 100% with the RVS-05 draft.
  </para>
  <para>
   The rendezvous mechanism is not yet guaranteed to be interoperable
   with other implementations than HIPL.
  </para>
  </chapter>
  <chapter>
    <title> Using HIP BOS support</title>
    <para>
      * To generate a BOS packet (sent to the global multicast address
      on all interfaces), use the following command:
    </para>
    <para>
      &nbsp;&nbsp;hipconf hip bos
    </para>
    <para>
      &nbsp;BOS-aware hosts will record the machine's HOST ID, HIT, and IP address.
    </para>
  </chapter>
  <chapter>
    
    <title>Accessing the kernel peer list</title>
    <itemizedlist>
      <listitem>
	<para>You can access the kernel's list of known HIP peers using the native
	  getendpointinfo name resolution interface.</para>
      </listitem>
      <listitem>
	<para>By default, the interface first checks the /etc/hip/hosts file for
	  a matching host. If one is not found, the kernel is queried for its
	  list of known HIP peers and the list is examined for matches.</para>
      </listitem>
      <listitem>
	<para>To only check the kernel list, set the hints.ei_flags to 
	  AI_HIP | AI_KERNEL_LIST. This will use only the kernel list and will
	  not check the hosts file.</para>
      </listitem>
      <listitem>
	<para>To retrieve the list of known peers from the kernel, set the 
	  hints.ei_flags to AI_HIP | AI_KERNEL_LIST and the nodename to NULL.
	  This will query the kernel for the list and return the entire
	  list.</para>
	</listitem>
	</itemizedlist>
  </chapter>
  <chapter>
    <title>HIP Firewall</title>

        <para>Ip6tables must define that HIP and ESP packets are
              queued in the user-space.  These rules must be inserted
              so that they precede any other firewall rules that might
              concern the HIP and ESP packets. If ESP packet filtering
              is not necessary the ip6tables rules concerning ESP
              packets (-p 50) can be left out.</para>

        <para>ip6tables -A FORWARD -p 99 -j QUEUE</para>
        <para>ip6tables -A FORWARD -p 50 -j QUEUE</para>
        <para>ip6tables -A INPUT -p 99 -j QUEUE</para>
        <para>ip6tables -A INPUT -p 50 -j QUEUE</para>
        <para>ip6tables -A OUTPUT -p 99 -j QUEUE</para>
        <para>ip6tables -A OUTPUT -p 50 -j QUEUE</para>

        <para>ip6_queue must be loaded with: "modprobe ip6_queue"</para>

        <para>Firewall can be started with "./firewall &lt;file_name&gt;"
              "timeout value" at firewall directory, where file_name
              is path of the file containing the firewall rules and
              timeout value is the connection timeout value in
              seconds.  If connection timeout is defined as zero or
              negative, the connection timeout checking is not
              used. Rules in the file must be separated with
              newline. The firewall (currently) prints out debug
              information from rule parsing test functions and from
              filtering packets.</para>

        <para>Rules follow (loosely) the syntax of Linux Iptables with
        following syntax:</para>

        <para>Basic format of rule:</para>

        <para>HOOK [match] TARGET</para>

        <para>Here HOOK is one of the netfilter hooks: "INPUT",
              "OUTPUT", "FORWARD".  Target is either "ACCEPT" or
              "DROP", whether packet should be allowed or not.  Match
              is a combination of filtering option described below.</para>

        <para>Filtering options:</para>

        <para>-src_hit [!] &lt;hit value&gt; --hi &lt;file name&gt;</para>

        <para>Matches source HIT of packet. HI can be given with
              --hi option and by defining path to a public key
              file as an argument. This causes sender signatures to be
              verified. The file name must contain either "_rsa_" or
              "_dsa_" to define whether RSA or DSA is used as
              algorithm.</para>
 
        <para>-dst_hit [!] &lt;hit&gt;</para>

        <para>Matches destination HIT of packet.</para>

        <para>-type [!] &lt;hip packet type&gt;</para>

        <para>Matches HIP packet type. Type is one of following: 
              "I1", "R1", "I2", "R2", "CER", "UPDATE", "NOTIFY", "CLOSE",
              "CLOSE_ACK"</para>

        <para>-i [!] &lt;incoming interface&gt;</para>

        <para>Matches incoming interface. Argument contains name of
              the interface. Can not be used for rules in OUTPUT hook
              as packet has no incoming interface in that case.</para>

        <para>-o [!] &lt;outgoing interface&gt;</para>

        <para>Matches outgoing interface. Argument contains name of
              the interface. Can not be used for rules in INPUT hook
              as packet has no outgoing interface in that case.</para>

        <para>-state [!] &lt;state&gt; --verify_responder --accept_mobile</para>

        <para>Matches state of HIP association: "NEW" or
              "ESTABLISHED". ESP packets are also filtered as part of
              the connection. With "--verify_responder" option the
              firewall stores responder HI from R1 packet and uses it
              for verifying signatures in the packets. With
              --accept_mobile option, the firewall may establish state
              for existing connection when a mobile host enters the
              network protected by the firewall. In practice this
              requires bringing down the previous interface and
              bringing up a new one in the new network.</para>


        <para>Management interface:</para>

        <para>Firewall management interface contains functions for
              altering rules of running firewall. Functions are
              defined in firewall/rule_management.h and implemented in
              firewall/rule_management.c. Rule_management.c also
              contains functions for copying, comparing and freeing
              rules, etc. If any functions are needed outside the
              rule_management they can be defined in the header file.</para>

        <para>The argument "hook" in the rule is the Netfilter hook
              for which rule is intended. The hooks are defined in
              linux/netfilter_ipv6.h as NF_IP6_LOCAL_IN,
              NF_IP6_FORWARD, NF_IP6_LOCAL_OUT.</para>

        <para>The argument rule is structure describing the rule
              defined in rule_management.h. The structure contains
              pointers to options. The pointer value must be NULL,
              when option is not defined. The structures for options
              are also defined in rule_management.h. Function: rule *
              parse_rule(char * string) can be used for creating a
              rule structure from a string. This also inspects that
              the rule syntax is correct.</para>

        <para>void insert_rule(const struct rule * rule, int hook):</para>

        <para>Inserts argument rule into with the hook. Insert makes
              local copy of the argument rule.</para>

        <para>int delete_rule(const struct rule * rule, int hook):</para>

        <para>Deletes the local rule that is equal to the argument
              rule. </para>

        <para>GList * list_rules(int hook):</para>

        <para>creates a copy of the rule list and returns it. Caller
               must take care of freeing the returned list.</para>

        <para>int flush(int hook):</para>

        <para>Clears all rules.</para>
  </chapter>
  <chapter>
    <title>HIP NAT Extensions</title>
    <para>HIPL supports also initiating connections from behind a NAT. The
          basic idea is that the initiator encapsulates HIP control packets
          and ESP data packets within UDP. This way, the packets can traverse
          the NAT box. However, both the initiator and responder have to
          support NAT extensions in order to make this work. Currently, the
          responder cannot be located behind a NAT.
    </para>
    <para>The NAT traversal can be experimented in a similar way as depicted
          in earlier sections. The only difference is that you have to
          tell the initiator manually that it is behind a NAT using "hipconf
          hip nat on". After this, you can initiate the base exchange
          according to the previous instructions. The manual configuration is
          currently required because support for automatic NAT detection (STUN)
          has not been implemented yet.
    </para>
    <para>If you have problems in even getting I1 triggered using NAT code
          e.g. with conntest-client-gai (occurred on 2.6.16.5), you may have
          to specify the source HIT explicitly. The procedure to initiate a connection
	  behind NAT is as follows:
    </para>
    <para>
      &nbsp;tools/hipconf hip nat on
    </para>    
    <para>
      &nbsp;tools/hipconf add map peer_hit peer_ipv4_addr
    </para>    
    <para>
      &nbsp; ping6 -I source_hit dst_hit
    </para>    
    <para>Make sure that the source is the same as in "ip xfrm policy" output.
          We are aware of the problem (see bug id 161) and it is being solved.
          Also, it seemed like the responder could not route packets
          automatically to the NAT, so a "ip route add nat_ipv4_addr dev xx"
          was necessary at the responder (occurred on 2.6.16.5).
    </para>
    <para>
	Three cases of mobility of the initiator have been implemented for the NAT code.
    </para>
	<para>Mobility from behind NAT to behind the same NAT:
		For this case, the use the standard procedure for update after the base exchange is completed. The update would be UDP encapsulated.
	</para>
	<para>Mobility from public addressable network to behind NAT: Once a hip association is set up between two hosts, both on the public network and one of them wishes to move behind a NAT, then that node should first delete the public ip address, then turn the NAT on using hipconf and then add the ip address behind NAT along with the route to the interface. The update would be done using UDP now and future communications would be UDP encapsulated (both HIP control traffic and ESP packets). </para>
	<para>Mobility from behind NAT to publically addressable network: If a node has setup hip association from behind NAT and now wishes to move to public IP domain, then it should first delete the ip behind NAT, turn off the NAT using hipconf and then add the public IP along with the route to the interface. HIP association then would not use UDP encapsulation and the update would be done using normal HIP packets (without UDP encapsulation).</para>

  </chapter>
  <chapter>
    <title>HIP User Agent and GUI</title>
      <para>Manage HITs with graphical user interface.</para>
      <para>When new HIT is received, it and local HIT is filtered
            trough agent, which asks user for accepting the HIT pair.
            Then HIT is saved into database and accept/reject is
            returned to daemon. User can also manage HITs trough graphical
            user interface. The interface is under development,
			and is quite in alpha state yet.
		</para>
      <para>
		To compile agent and GUI atleast following packages are needed (asuming you have debian):
		1. gcc and g++ compilers, both should be at least version 4.0.
		2. Package: xbase-clients - miscellaneous X clients
		3. GTK 2.x and development files for it (Package called libgtk2.0-dev).
           If you want to use 'system tray' icon, you need atleast 2.10.0 version
		   of GTK.
		4. Automake 1.9
      </para>
	  <para>
		  In order to the agent start properly with right window and system tray icon,
		  you must first do 'make install' to install the data files in right directory.
		  System tray icon will not be shown at all, if you don't do this.
	  </para>
      <para>
		HIT database is saved and loaded on agent startup as default from
		'$HOMEDIR/.hipagentdb'-file.
      </para>
      <para>The agent executable is called "hipagent". You should run it using
            normal user (non-root) priviledges.
      </para>
  </chapter>
  <chapter>
    <title>HIP socket handler kernel module</title>
    <para>The HIP socket handler is a component of the HIPL HIP
	  implementation. It is used to intercept HIP socket
	  API calls. The hipsock kernel module is used to 
	  register a new protocol family and to handle the
	  socket system calls for this family.
    </para>
    <para>The kernel patch: 
          patches/kernel/hipmod-2.6.13.1-v2.patch has to be appiled to the running
	  kernel in order to make the socket handler module run.
    </para>
    <para>Recompile the patched kernel. Change directory to hipsock to build
          the socket handler module. The makefile assumes
          that the kernel sources are located in /usr/src/linux. Override it
          with "make LINUX=/path/to/linux/" if necessary.
    </para>
    <para>Use "insmod hipsock.ko" to activate the kernel module.
          Check dmesg for messages. Use "rmmod hipsock.ko" to 
	  remove the module from the kernel. If you get the error
          "insmod: error inserting 'hipsock/hipsock.ko': -1 Invalid module
          format", you have to specify the path of the kernel source (using
          LINUX variable) for the system in which you are going to use the
          kernel module.
     </para>
   </chapter>
  <chapter>
    <title>OpenDHT Support (Experimental!)</title>
    <para>
    &nbsp; unpack patches/misc/hip-dht-04052006.tgz
    </para>
    <para>
    &nbsp; make a link called "hipl--main--2.6/hip-dht" that points to
    the unpacked hip-dht directory
    </para>
    <para>
    &nbsp; Compile hipl--main--2.6 with ./configure --enable-opendht
    </para>
    <para>
    &nbsp; To test, just run normally conntest-server 
	and conntest-client-gai between hosts. You would see messages 
	from hipd and conntest showing DNS->HIT->IP lookups. Everything 
        should work without additional actions.
    </para>
    <para> May need a change of contact OpenDHT server, currently 
	running list is at http://www.opendht.org/servers.txt.
	For documentation, please also check 
        http://kom.aau.dk/group/05gr680/
    </para>
  </chapter>

  <chapter>
    <title>Hi3 Support (Experimental!)</title>
    <para>
    &nbsp; unpack http://i3.cs.berkeley.edu/download/i3_0_3.tar.gz
    </para>
    <para>
    &nbsp; make a link called "hipl--main--2.6/i3" that points to
    the unpacked i3_0.3/i3 directory
    </para>
    <para>
    &nbsp; Compile hipl--main--2.6 with ./configure --enable-hi3
    </para>
    <para>
    &nbsp; Not tested for a long time. To work, needs to use some set of
	i3 servers started locally from i3 distro or running on 
        PlanetLab. See e.g. http://hipl.infrahip.net/i3_status.html or 
	http://rose.cs.berkeley.edu:8080/i3_status.html
    </para>
  </chapter>
  <chapter>
    <title>Using Opportunistic mode</title>
    <para>
    &nbsp; Opportunistic mode is not compiled by default. In order to use Opportunistic mode enabled HIP, the following steps are needed:
    </para>
    <para>
    &nbsp; 1. Move to top level of HIPL
    </para>
    <para>
    &nbsp; e.g. cd hipl
    </para>
    <para>
    &nbsp; 2. Run autogen.sh
    </para>
    <para>
    &nbsp; ./autogen.sh
    </para>
    <para>
    &nbsp; 3. Run configure with flag --enable-opportunistic. See "./configure --help" for a full list of options
    </para>
    <para>
    &nbsp; ./configure --enable-opportunistic
    </para>
    <para>
    &nbsp; 4. Run make
    </para>
    <para>
    &nbsp; make
    </para>
    <para>
    &nbsp; 5. Run hip daemon on both "crash" and "oops"
    </para>
    <para>
    &nbsp; hipd/hipd
    </para>
    <para>
    &nbsp; 6. Using hipconf tool to set HIP Opportunistic mode on both hosts manually. "tools/hipconf set opp on|off" command is used to enable/disable opportunistic mode
    </para>
    <para>
    &nbsp; tools/hipconf set opp on
    </para>
    <para>
    &nbsp; Now the opportunistic mode is enabled. To test Opportunistic mode, you need to remove crash's HITs and name from /etc/hip/hosts, and then following the steps in Chapter 6. 
    </para>
  </chapter>
</book>    

