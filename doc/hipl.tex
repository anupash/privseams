% XX TODO
% - mm
% - rvs
% - bib
%   - draft versions: sync and add version nbr!
% - native API?
% - bos
%

\section{Introduction}
\label{sec:introduction}

The lack of security has been one of the main problems with
IP. Although \ac{IPsec}~\cite{rfc2401} and \ac{DNSSEC}~\cite{rfc3008}
have provided some level of security to IP layer, such as data origin
authentication, confidentiality, integrity, and so forth, the notion
of a true identity for hosts is still missing. The IP address has
typically been used both to identify the host and to provide routing
information. This has led to the misuse of IP addresses for
identification purposes in many security schemes. To overcome the
problems related to the current use of IP addresses, the \ac{HIP}
architecture adds a cryptographically based namespace, the Host
Identity, to the IP protocol.  Each host (or more specifically, its
networking kernel or stack) is assigned at least one \ac{HI}, which
can be either public or anonymous. The \ac{HI} can be used for
authentication purposes to support trust between systems, enhance
mobility and dynamic IP renumbering, aid in protocol
translation/transition and reduce denial-of-service
attacks. Furthermore, as all of the higher protocols are bound to the
\ac{HI} instead of the IP address, the IP address can now be used
solely for routing purposes.

This document describes the implementation effort of the \ac{HIPL}
project~\cite{hipl}. The implementation is based on the standard Linux
kernel and supports only IPv6 protocol. Some background knowledge is
also provided for the reader unfamiliar with \ac{HIP}.

\subsection{Related Work}
\label{sec:related_work}

There are some protocols that have similar kind of functionality as
\ac{HIP} has. Examples of these protocols are \ac{SCTP} and Mobile
IPv6.

\ac{SCTP} provides a means for each \ac{SCTP} endpoint to provide the
other endpoint (during association startup) with a list of transport
addresses (i.e., multiple IP addresses in combination with an
\ac{SCTP} port) through which that endpoint can be reached and from
which it will originate \ac{SCTP} packets. The association spans
transfers over all of the possible source/destination combinations
which may be generated from each endpoint's lists. \cite{rfc2960}

Connection setup with SCTP is similar to \ac{HIP}, a cookie exchange
mechanism is also used during the connection setup
procedure. \ac{SCTP} uses cryptographic hash functions for data
integrity checks.

Mobile IPv6 tries to make mobility transparent to applications using
higher level protocols. Mobile IPv6~\cite{rfc2002} addresses also
security issues.

\ac{HIP} is being developed in four independent projects. \ac{HIPL}
implementation is described in this document. Andrew McGregor is
developing a cross-platform version~\cite{pyhip} with Python
programming language, Ericsson Research~\cite{ericsson} is working on
a FreeBSD implementation~\cite{netbsd} and Boeing~\cite{boeing} is
developing an Linux IPv4 implementation.

\section{Background}
\label{sec:background}

\subsection{HIP Architecture}

There are two namespaces in use in the Internet today: IP addresses
and domain names.  IP addresses have been used both to identify the
network interface of the host and the routing direction vector.  The
three main problems with the current namespaces are that dynamic
readdressing cannot be directly managed, anonymity is not provided in
a consistent and trustable manner, and authentication for systems and
datagrams is not provided.

The \ac{HIP} architecture is introduced in \cite{hiparch}. \ac{HIP}
introduces a new cryptographically based namespace, the \ac{HI}, and
adds a layer between the network and the transport layer in the TCP/IP
stack.

The modification to the IP stack is depicted in
\autoref{fig:stack_model}. In the current architecture, each process
is identified by a \ac{PID}. The process may establish transport layer
connections to other hosts (or to the host itself), and the transport
layer connection is then identified using the source and destination
IP addresses as well as the source and destination ports. On the IP
layer, the IP address is used as the endpoint identifier, and on the
link layer, the hardware address of the network interface is used. In
\ac{HIP}, the transport layer is modified so that the connections are
identified using the source and destination \acp{HI} as well as the
source and destination ports. \ac{HIP} then provides a binding between
the \acp{HI} and the IP addresses, e.g. using \ac{DNS}~\cite{rfc1034}.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.7]{fig/stack_model}
\end{center}
\caption{The current IP stack and the \ac{HIP} based stack}
\label{fig:stack_model}
\end{figure}

The \ac{HI} is typically a cryptographic public key, which serves as
the endpoint identifier of the node. Each host will have at least one
\ac{HI} assigned to its networking kernel or stack. The \ac{HI} can be
either public or anonymous. Public \acp{HI} may be stored in
directories, such as \ac{DNS}, in order to allow the host to be
contacted by other hosts. A host may have several \acp{HI}, and it may
also generate temporary (anonymous) \acp{HI} on the fly for
establishing connections to other hosts. The main purpose of anonymous
\acp{HI} is to provide privacy protection to the host, should the host
not wish to use its public \acp{HI}.

The \ac{HI} is never directly used in any Internet protocol. It is
stored in a repository, and is passed in \ac{HIP}. Protocols use a
128-bit \ac{HIT}, which is a hash of the \ac{HI}.  Another
representation of the\ac{HI} is the \ac{LSI}, which has a size of 32
bits, but is local to the host. Its main purpose is to support
backwards compatibility with the IPv4 \ac{API}.

The main advantages of using \ac{HIT} in protocols instead of the
\ac{HI} is that its fixed length makes protocol coding easier and also
does not add as much overhead to the data packets as a public key
would. It also presents a consistent format to the protocol regardless
of the underlying identity technology used. \ac{HIT} functions much
like the \ac{SPI} does in \ac{IPsec}, but instead of being an
arbitrary 32-bit value that identifies the \ac{SA} for a datagram
(together with the destination IP address and security protocol),
\ac{HIT} identifies the public key that can validate the packet
authentication.

The probability that a collision will occur is extremely
small. However, should there be two public keys for one \ac{HIT}, the
\ac{HIT} acts as a hint for the correct public key to use.

The \ac{HIP} architecture basically solves the problems of dynamic
readdressing, anonymity, and authentication. As the IP address no
longer functions as an endpoint identifier, the problem of mobility
becomes trivial, as the node may easily change its HI and IP address
bindings as it moves. Anonymity is provided by temporary and anonymous
\acp{HI}. Furthermore, as the namespace is cryptographically based, it
becomes possible to perform authentication based on the \acp{HI}. In
\cite{ndss-inthip}, the concept of integrating security, mobility, and
multihoming based on \ac{HIP} is discussed further.

\subsection{Base Exchange}

\ac{HIP} is a signaling protocol between the communicating
endpoints. The main purpose of the protocol is to perform mutual
end-to-end authentication and to create \ac{IPsec}
\ac{ESP}~\cite{rfc2406} \acp{SA} to be used for integrity protection
and possibly also encryption. Furthermore, the protocol performs
reachability verification using a simple challenge-response scheme.

% todo: bex 4 + update = 5
% + cer + notify + close + close_ack = 9

\ac{HIP} provides nine message types, of which four are dedicated to
the base exchange. In \autoref{fig:base_exchange}, the base exchange
is depicted. In the first message, I1, the initiator I sends its own
\ac{HIT} and the \ac{HIT} of the responder to the responder. The
responder R replies with message R1, which contains the \acp{HI} of I
and itself as well as a puzzle based challenge for I to solve. The
purpose of the challenge is to make the protocol resistant to
denial-of-service attacks. (Puzzle based schemes have been previously
used for providing \ac{DoS} protection to both
authentication~\cite{clientpuzzle} and encryption~\cite{opportkey}
protocols.) I solves the puzzle and sends in I2 the \acp{HIT} of
itself and R as well as the solution to the puzzle, and performs the
authentication. R2 now commits itself to the communication, and
responds with the \acp{HIT} of I and itself, and performs the
authentication. After this, I and R have performed the mutual
authentication and established Security Associations for \acp{ESP},
and can now engage in secure communications. Furthermore, reachability
is verified by the fact that the protocol has more than two rounds.

\begin{figure}[htt]
\begin{center}
\includegraphics[scale=0.7]{fig/base_exchange}
\end{center}
\caption{The base exchange}
\label{fig:base_exchange}
\end{figure}

If I does not have any prior information of R, it may retrieve the
information from a repository, such as \ac{DNS}. I sends a lookup
query to the \ac{DNS} server, which replies with R's address, \ac{HI},
and \ac{HIT}.

% XX FIX: move BOS here ?

\subsection{Mobility and Multihoming Extentension}
\label{sec:mm-ext}

% XX FIX Mika:

% - update the text to cover the new mm mechism and remove old stuff
% on jo

%   - tell also the reason why there is now one SA pair / interface;
%     the reason is replay window
% menee kai impl-sektioon

There are some other message types in the \ac{HIP}. One of them is the
UPDATE packet which provides the peer system a new \ac{SPI} to use
when sending outbound data. UPDATE also provides possibly a new
\ac{DH} key to produce new keying material, and provides any
intermediate system with the mapping of the old
\ac{SPI} to the new.

\cite{hip-ietf-mm-00} provides a way for
supporting mobility and multihoming using UPDATE packets. UPDATE
packet includes then REA (contains a list of addresses of the host),
SEQ, and ACK parameters, and possibly DIFFIE\_HELLMAN parameter. If
the packet contains a NES parameter, rekeying is also performed. The
existence of these parameters depends on the desired mobility scenario
described in \cite{hip-ietf-mm-00}.

% - move the ``theory'' stuff from 3.8 to here
%   - picture
%   - explanation of the readdressing mechanism

% jaa tämä tänne vai:

A typical mobility exchange is quite simple. 

First the HIP module selects the addresses to be included in a REA
parameter. The REA parameter and a sequence number in a SEQ parameter
are added to the UPDATE packet. Then the UPDATE packet is sent to
all of the peers with which there is an existing HIP security
association.

When a peer host receives the initial UPDATE packet, it must validate
all addresses listed in the REA parameter. This is achieved by sending
a reply UPDATE packet to each of the addresses listed in the initial
UPDATE packet. This reply UPDATE packet contains ECHO\_REQUEST and SEQ
parameters.

When a reply UPDATE packet is received, it must be acknowledged with
an UPDATE packet which contains ECHO\_REPLY and ACK parameter. This is
needed to verify that there really is a host at the address where the
UPDATE was sent from. When a host receives these address verification
UPDATE packets, it can start using them when sending data to its peer.

If the reply UPDATE packet is not replied, the address corresponding
to the address tested in the REA parameter of the initial UPDATE
packet is not reachable and therefore the address is not usable for
any communication until next readdressing of the peer.

An example mobility exchange is depicted in figure
\ref{fig:mm-readdress}.

\begin{figure}[hbt]
 \centering
 \includegraphics[scale=0.8]{fig/mm-update}
 \caption{Multihoming and Mobility, readdress with mobile-initiated rekey}
 \label{fig:mm-readdress}
\end{figure}



\subsection{About the HIPL Project}

Linux was selected as the platform for implementing \ac{HIP}. It was a
natural choice because the developers were already familiar with
Linux. Documentation about kernel development was also needed because
all of the project members were unfamiliar with kernel development in
the beginning of the project. There was enough documentation about
Linux kernel development (for example
\url{http://www.kernelhacking.org/}, \cite{kernelarch},
\cite{kernellinks}, \cite{kmodguide}) that made Linux platform a
reasonable choice.

When the \ac{HIPL} project was started, the standard Linux kernel
series 2.4 did not include \ac{IPsec} functionality which is needed
for \ac{HIP}. There were two projects providing \ac{IPsec} support for
the Linux kernel: USAGI Linux~\cite{usagi} and
FreeS/WAN~\cite{freeswan}. USAGI Linux was selected because FreeS/WAN
did not support IPv6 and project members wanted to concentrate on
developing an IPv6 implementation of \ac{HIP}. Now that the
implementation was moved to kernel series 2.6, the \ac{IPsec} support is
built-in into the kernel.

The main goal of the project is to develop a \ac{HIP}
drafts~\cite{hip,hiparch,hipimpl,hip-ietf-mm-00} compliant implementation of
\ac{HIP}. The implementation does not implement IPv4 support for
\ac{HIP}. Modularity was emphasized in the design because \ac{HIP}
specifications were prone to change and hardcoding might have later
rebound on during the project. To achieve modularity, code was kept
clear and simple. Both unit testing and interoperability testing has
been used throughout the project.

% IPv4-tuen tila ?
% unit testing .. none

This project is a research project and thereby the non-goals of the
project are related to production quality code. Usability and high
performance are not in the main focus of the project.

\section{Implementation Architecture}
\label{sec:implementation_architecture}

This section describes the architecture of the implementation as it
is. A general model of operation is first discussed because it affects
the design of all components in the system. The components of the
architecture is are the explained. The section is concluded with an
practical example that shows how the components interact with each
other.

\subsection{HIP module}
\label{sec:kernel_model_architecture}

The \ac{HIP} functionality, or module, is located in the networking
stack of the Linux kernel. Since the project was originally based on
IPv6 protocol, the actual code resides in a \verb|hip| subdirectory
under the IPv6 directory.

We had to choose between a Bump-In-The-Stack model and a kernel thread
model. We chose the latter one. Most of the \ac{HIP} processing is
done by the \verb|khipd| kernel thread. The \ac{HIP} thread will sleep
in a semaphore waiting for other parts of the kernel to give it
\verb|work orders|. The implementation is a simple queue, protected by
a semaphore.

Currently all the \ac{HIP} packets coming from the network will cause
a work order to be created and passed to the kernel thread. This way
we minimize the time spent in the network receive softirq. Also the
\ac{HIP} thread can be easily controlled (niced, preempted etc.).

There are also few other cases where a work order is created. Since
user space has to have a mean to send mappings into the kernel, we
have a block device \verb|/dev/hip|.  We currently use \verb|ioctl|
calls to send information to the \ac{HIP} module. All \verb|ioctl|
information is passed to the \ac{HIP} thread by work orders. Usually
that information consists of adding/deleting mappings from the
\ac{HADB}.

\subsection{Internal data structures}

\ac{HIPL} contains a couple of global data structures. In this section
we describe their intended use and locking policies.

\subsubsection{Host Association Data Base}
\label{sec:hadb}

The \ac{HADB} maintains a collection of Host Associations (HA). Each
\ac{HA} holds necessary information to establish and maintain a
\ac{HIP} association between the two hosts. \acp{HA} consist of both
parties' \acp{HIT}, \ac{SPI} values required for \ac{ESP} traffic,
IPv6 addresses, security keys, keying material to derive new keys and
some state information.  The \acp{HA} are distinguished by peer's
\ac{HIT} and inbound \ac{SPI} values (ie. the \ac{SPI} value that appears
in \ac{ESP} encapsulated packets destined to us).  To be able to
access the \acp{HIT} efficiently, they are stored in two different
hash tables: one using peer's \ac{HIT} as the hash key, and one
SPI-HIT table which maps \ac{SPI} values to \acp{HIT}. The SPI-HIT
table is needed for multiple \ac{IPsec} \ac{SA} support.

The former is required, when either we are sending some transport
data, or due to \ac{HIP} control messages (base exchange, readdressing
etc). The latter is used only when an incoming \ac{ESP} encapsulated
arrives. We need to map it to a certain \ac{HIP} connection. At that
time, we are not aware of the \acp{HIT} involved, but only the
\ac{SPI} value. When \ac{ESP} is received, the received looks up the
corresponding \ac{HIT}, and after that the host can get the correct
\ac{HA} by using the retrieved \ac{HIT} as the hash key.

% WAAAAAAAAAAAAAS ? The \ac{HA} consists of XX.

%The \ac{HA} has internal state. This state varies between
%\verb|HIP_HASTATE_VALID|, \verb|HIP_HASTATE_SPIOK| and
%\verb|HIP_HASTATE_HITOK|, meaning that the HA is inserted in both hash
%tables, inserted in the SPI hash table and inserted in the HIT hash
%table, respectively.

The \ac{HA} has internal state. This state varies between
\verb|HIP_HASTATE_INVALID| and \verb|HIP_HASTATE_HITOK|, meaning that
\ac{HA} is not fully usable yet or it is inserted in the HIT hash table,
respectively.

% oh * .. multiple SA support breaks this
%Although there are two hash tables, there are only one set of
%\acp{HA}. This entity, that holds \acp{HA} in one or two hash tables,
%is called the \ac{HADB}.
%changed to:
The entity that holds \acp{HA} in hash tables, is called the \ac{HADB}.

There is a reference counter in every \ac{HA}. This counter must be
incremented using \verb|hip_hold_ha()| macro whenever we receive a
reference to the \ac{HA}. Obviously the reverse holds for decrementing
the counter using \verb|hip_put_ha()|. When the reference counter
reaches zero, the resources allocated for the \ac{HA} are automatically
deleted.

\subsubsection{HADB Locking}

To maintain integrity across the operations involving the \ac{HADB} or
the \acp{HA} added to the \ac{HADB}, we use a couple of techniques.

First, we guarantee that no \ac{HA} can be deleted accidentally while
some other thread/process uses it. This is accomplished by having
reference counters in each \ac{HA}. This counter must be incremented
using \verb|hip_hold_ha()| macro whenever we receive a reference to
the \ac{HA}. Obviously the reverse holds for decrementing the counter
using \verb|hip_put_ha()|. When the reference counter reaches zero,
the memory allocated for the \ac{HA} is automatically deleted.  A
reference to a \ac{HA} can only be acquired through certain \ac{HADB}
functions. These guarantee that there cannot be a situation where we
would be deleting the \ac{HA} (due to its reference counter reaching
zero), and some other thread wanting to acquire the \ac{HA}.

Second, each \ac{HA} has its own spin lock. This lock must be locked
when the information in \ac{HA} is accessed, either for reading of
writing.  The two macros (\verb|HIP_LOCK_HA| and \verb|HIP_UNLOCK_HA|)
provide the correct means to handle \acp{HA}.  These macros use
\verb|spin_lock_bh| and \verb|spin_unlock_bh|, respectively, to
acquire and release the locks and at the same time to disable and
enable bottom handlers.

Third, the two hash tables in \ac{HADB} both have a global spin
lock. Certain \ac{HADB} functions use these to isolate the critical
sections. The basic policy is to use these locks only when operating
(reading or writing) on the hash table itself. The macros that do the
job are: \verb|HIP_LOCK_HT| and \verb|HIP_UNLOCK_HT|.

% Miika: mihinköhän tämän laittaisi?

Due to the architecture of \ac{HIPL}, there are 3 different contexts,
in which the \ac{HIP} code is executed: bottom handler/softirq, kernel
thread and user context.  The softirq context is used when receiving
packet from the network. It has the highest priority. A \ac{HIP}
worker thread is operating in the kernel thread context.  Userspace
\ac{HIP} configuration tools, \ac{HIP} sockets API etc. run in user
context.  An incoming network packet will preempt every other
context. If a process/thread in a lower priority context has acquired
a lock, it will not be able to release it.



% XX TODO Kristian:
% - describe how the locks work
% - explain when we are in user mode, when in interrupt, etc
% - how does the current mode affect the locking
% - there was one special case when when use HADB without locks..
% - copy-paste from thesis?

\subsection{HIP Work Queue}
\label{sec:work_queue_architecture}

The purpose of a working queue in \ac{HIP} is to defer processing of
HIP-related messages. The main functionality is executed by a \ac{HIP}
kernel thread. Networking stack defers packets to the \ac{HIP} thread
for further processing.  Originally there were two reasons for this.
The first one was to simplify accessing the internal data structures,
and the second one to enable \ac{HIP} module to be more controllable.
For example, \ac{HIP} thread's priority can be raised or lowered,
giving it more or less \ac{CPU} time.

Currently, the data structures are accessible to everybody (and in
every context), thus the first reason does not hold anymore.

Working queue is simple linked list. At the moment it is not bounded,
but it definitely should be, if the code is ever used in a real,
production server. The list is protected by a semaphore. The worker
thread sleeps in the semaphore until (usually the networking stack)
defers some job to it.  Basically, this is a producer consumer
model. Where the networking stack and user configuration tools produce
jobs for the kernel thread to consume.  The job is usually related to
the \ac{HIP} base exchange, or other control traffic.  The normal data
transfer does not defer execution to later, so it does not use the
working queue.

% XXX Miika: Etsi tälle parempi paikka

Due to the architecture of \ac{HIPL}, there are three different
contexts, in which the \ac{HIP} code is executed: bottom
handler/softirq, kernel thread and user context.  The softirq context
is used when receiving packet from the network. It has the highest
priority. A \ac{HIP} worker thread is operating in the kernel thread
context.  Userspace \ac{HIP} configuration tools, \ac{HIP} sockets API
etc. run in the user context.

\subsection{Asymmetric Cryptography Support in the Linux Kernel}

% XX TODO: It is not a separate module anymore

A generic asymmetric cryptophic module was developed to handle HIP's
needs of the \ac{DSA} and \ac{DH} algorithms. The main reason
for this was that the implementation architecture was revised to be
more kernel orientated. The cryptographic module a ripped off version
of the GNU cryptographic library (libgcrypt) version 1.12.
\autoref{tbl:asymmetric_crypto_ops}.

\begin{table}[htb]
\centering
\begin{tabular}{|l|}\hline
Cryptographic Operation \\\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Create cookie  \\
Solve cookie \\
Validate cookie \\
Sign packet with DSA \\
Verify DSA signature \\
Create DH shared secret \\
\hline
\end{tabular}
\caption{The operations supported in the asymmetric cryptophic module}
\label{tbl:asymmetric_crypto_ops}
\end{table}

\subsection{Networking Stack}
\label{sec:networking_stack_architecture}

\ac{HIP} headers are needed to be inserted to and captured from
network traffic in any implementation of the \ac{HIP} protocol. There
were two alternatives on how to do this, and a comparison of them is
in \autoref{sec:networking_stack_design_choices}. The \ac{HIPL}
implementation is based on the ``hooks'' approach, which is described
in more detail in this section.

Some of the hooks were placed in the IPv6 part of the networking
stack. Originally the hooks were bound to the \verb|connect| system
call in \ac{TCP} layer, but they were refactored into IPv6 layer so
that \ac{UDP} and other transport layer protocols would work
transparently.

Only a single packet will be queued in the output side of the IPv6
stack during base exchange. This means that \ac{TCP} retransmissions
will be dropped during a slow \ac{HIP} base exchange, for example. A
more closer view of the implementation of the hooks is provided in the
following paragraphs.

The hooks in the output side of the IPv6 stack intercept packets that
are destined to \ac{HIT} addresses. The hooks do nothing for an
outgoing packet if the destination address is an IPv6 address. If the
destination address is a \ac{HIT}, the hooks check for an earlier base
exchange with the destination \ac{HIT}. If a base exchange has not
been yet done with the destination \ac{HIT}, the original packet is
queued and an I1 packet is sent instead of the original packet. If a
base exchange has already been done with the destination HIT, the
hooks catch the packet when it is built ready (including IPv6 and
\ac{ESP} headers). Source and destination addresses are \acp{HIT} at
this point but they will be converted to IPv6 addresses before the
IPv6 layer can transmit the packet to network.

There is no actual hook in the input side of the IPv6 stack. \ac{HIP}
is registered as a normal transport layer protocol listening for the
packets in the base exchange. When a \ac{HIP} connection is
established, a hook in the input handler of \ac{ESP} is
triggered. This hook checks the \ac{SPI} of the incoming packet. If
the incoming packet is not associated with a \ac{HIT}, the packet is
returned as normally. If the SPI belongs to a \ac{HIP} connection, the
source and destination \acp{HIT} corresponding to the \ac{SPI} are searched
from kernel database and they are copied over source and destination
IPv6 addresses. Finally control of flow returns to normal \ac{ESP}
handler.

Additional functions not directly related to sending or receiving
packets were also needed for effective \ac{HIP}. Address events are
these kind of things which needed to be modified. A host wants to know
if it has a new IPv6 address or an IPv6 address is deleted. The
function \verb|hip_handle_ipv6_dad_completed| handles \ac{DAD} events
and function \verb|hip_handle_inet6_addr_del| handles the events
caused by single address deletion.

Input and output side of the hooks are visualized in
\autoref{fig:input_hooks} and \autoref{fig:output_hooks}.
\autoref{tbl:hook_descriptions} explains each numbered point in the
figures. An interface name in code and an explanation for each point
is given in the figure. 

% XX FIX MIKA:
% - add the missing hooks (DAD, what else did you add? esp?) to the figures
%
% hip_handle_ipv6_dad_completed
% hip_handle_inet6_addr_del
% .. mutta näitä ei voi oikein laittaa kuvaan, koska ne ovat ulkoisia tapahtumia
% ->selostettu yläpuolella
% tai oikeastaan nämä kuuluvatkin tuohon Address configiin

\begin{figure}
   \begin{minipage}[b]{0.4\textwidth}
      \centering
      \includegraphics[height=0.5\textheight]{fig/input}
      \caption{Input side of networking stack}
      \label{fig:input_hooks}
   \end{minipage}%
   \hfill%
   \begin{minipage}[b]{0.9\textwidth}
      \centering
      \centering
      \includegraphics[height=0.5\textheight]{fig/output}
      \caption{Output side of networking stack}
      \label{fig:output_hooks}
   \end{minipage}%
\end{figure}

\setlongtables
\begin{longtable}{|c|p{0.2\textwidth}|p{0.6\textwidth}|}
\\\hline
\endhead
\endfoot
Point & Function Name & Operation \\\hline
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

a & \verb|hip_bypass_ipsec| &

A packet with a \ac{HIP} header is received. \ac{IPSec} processing is skipped. \\

b & \verb|hip_handle_esp| &

The packet has a SPI that belongs to \ac{HIP}. The IPv6 addresses are
replaced with the corresponding \acp{HIT} before the packet is delivered to
ESP. \\

c & \verb|hip_unknown_spi| &

A packet from an unknown SPI is received and an R1 packet must be sent
as a response.\\
% XX: must..currently not: sec:loc_hip_kernel

d & \verb|hip_inbound| &

A packet with a \ac{HIP} header is received. The \ac{HIP} module is called.\\

e & \verb|hip_get_hits| &

Kernel is about to send a packet with a HIT as destination address. A
source HIT is required before the packet can be sent.\\

f & \verb|hip_get_saddr_udp| &

A packet is being sent and destination address is a HIT. This hook is
essentially equivalent to \verb|hip_get_hits| but it is called
from the IPv6 layer. The hook handles all other packets except the
ones produced by TCP.\\

g & \verb|hip_handle_output| (x2) &

An IPv6 packet is being sent out that has a HIT as the destination
address. An IPv6 address corresponding to the HIT is searched from the
kernel database. The HIT will be replaced with the corresponding IPv6
address in the IPv6 header. \\

h & \verb|hip_get_addr| &
  
A small modification in routing and neighbor discovery is needed
because they behave in a rather odd way in Linux: transport protocols
select the routes to be used even though it should really be selected
by network layer protocols. This hook would not be needed if the
kernel routing behaved as expected. The hook is physically located in
routing handler and it is triggered by transport layer. Routing
handler receives a query for the route to the given HIT address and the
hook tells the routing handler the IPv6 address corresponding to the
HIT.\\

\hline
\caption{Descriptions for \autoref{fig:input_hooks} and
\autoref{fig:output_hooks}}
\label{tbl:hook_descriptions}
\end{longtable}

\subsection{IPsec Usage}

When the \ac{HIP} code starts, it registers two \acp{SP}, one incoming
and one outgoing. We use \verb|4000::/2| as a source and destination
IPv6 addresses. This is the range that is preallocated for \ac{HIP}
use, although it is not yet officially allocated by the Internet
Assigned Numbers Authority (IANA).  Actually there is also a ``type
2'' HIT defined as \verb|8000::/2|, but it is not in use, and we do
not support it currently.

When an ordinary\footnote{destination address belonging to the IPv6
address range approved by the \ac{IANA}} network connection is being
established, the \ac{IPsec} does not match the \ac{HIP} \ac{SP}, and
thus no \ac{HIP} action will be performed. When a \ac{HIP} network
connection is initiated, the \ac{HIP} \ac{SP} will match, and
\ac{IPsec} will query for a \ac{SA}. If there is no ready \ac{SA}
available, as is the case when we first connect to the peer, the
\ac{HIP} module will start the \ac{HIP} base exchange.

The caller process will be put to sleep until the \ac{SA} is valid, or
has timeouted.  Default timeout period is 30 seconds\footnote{This is
defined by the Linux 2.6 IPsec stack.}. The process will sleep even if
the socket is a non-blocking one.
\footnote{Perhaps we should do something to alleviate this minor
problem?}
% timeout .. in ACQ state ?

If the \ac{HIP} base exchange procedure is successful, we have 2 valid
SAs: one outgoing and one incoming. All the sleepers waiting for the
outgoing \ac{SA} will be now waked up. Now the calling process
(usually \verb|connect()|), can proceed with transport layer
connection establishment (\ac{TCP} handshake). This part will no
longer sleep, if the socket has been set to non-blocking.

\subsection{Mobility and Multihoming}
\label{sec:mobility_and_multihoming_architecture}

The implementation has some level of support for the mobility and
multihoming features defined in the draft
\cite{hip-ietf-mm-00}. Scenarios ``Mobility with single SA pair'' and
``Host multihoming'' were the main targets of the current
implementation. The rest of the scenarios are not planned to be
implemented in the near future.

%Old style support for REA, AC, and ACR packets is removed. Current
%implementation uses UPDATE packets for mobility and multihoming.

The changes needed compared to the previous version can be consireded
major. Most notable change had to be done to the \ac{HADB} (see
\ref{sec:hadb}). The previous version was designed for
\acp{HA} which know only of one simultaneous \ac{SPI} at the same
time. However, the mobility draft \cite{hip-ietf-mm-00} shows how to
use many simultaneous \ac{SPI} values. It also describes how IPv6
addresses can be bound to the \acp{SPI}. The SPI-HIT hash table (see
\ref{sec:hadb}) was needed because if the peer has many \ac{SPI}
values, the hashing values will be different and we would get
incorrect results for \ac{HA} lookup in the case if only single hash
table were used.

The current implementation implements the suggestion ``one \ac{IPsec}
\ac{SA} per one network interface'' proposed in
\cite{hip-ietf-mm-00}. If only \ac{SA} was used, the \ac{ESP} replay
window might drop incoming packets if packets arrive at many different
paths having different characteristics. Having many simultaneous
\acp{SA}, the other \acp{SA} do not affect the replay window of any
other \ac{SA}.

%\autoref{fig:rea} depicts \ac{HIP} mobility and multihoming.
The \ac{HIP} network module is notified when an IPv6 address is added
to or removed from some of its network interface(s). Another type of
events are network device events. The \ac{HIP} module is notified when
a network device goes down or comes up. Actually, the event when
network comes up is ignored, because at that time the interface
usually has no usable addresses, so the module waits for IPv6 address
addition events.

When a change occurs in an interface, the HIP module selects the
addresses within the interface and proceeds as described in
\autoref{sec:mm-ext}.

\subsection{Rendezvous Mechanism/Server}
\label{sec:rendezvous_server}

% XXX Miika: Ei kai tähän tarvita introa reiskasta?

For the rendezvous server functionality, we had to add a new hash
table, where we store the RendezVous Associations (RVA). The hash
table uses peer's HIT as a key, just like one of the HADB hash tables.

We define few terms to lessen the readibility and comprehensivity of
the rest of the subchapter.  Responder means the host that asks the
rendezvous server for the rendezvous service. Server means the
Rendezvous Server. Initiator means the host that tries to contact the
Reponder, but does not have its real IP address, but the IP address of
the Server instead.

First, the Responder needs to inform the Server, and ask for
rendezvous service. This is accomplished by adding a special control
bit (RVS\_CAPABLE) in I1 packet, as specified in \cite{rvs-00}.  To
the I2 packet, we add an optional RVA\_REQUEST parameter, \textbf{if}
and only if, the Server also used the RVS\_CAPABLE bit in R1 packet.
Otherwise, the Server signals that is not capable of providing the
rendezvous service we asked for. We then end the base exchange.

Having added the RVA\_REQUEST parameter to the I2, we proceed with the
rest steps of building the I2 packet, and send it. Then rest goes as
in the normal base exchange procedure.

On the Server's side, the process is slightly different. Always when a
Server receives I1 packet, it has to check if it is destined for
itself, or if it belongs to a \ac{HIP} node, that it is serving.

\subsection{HIP Bootstrap Support}
\label{sec:bos_architecture}

% XX FIX: MIIKA

\subsection{Sockets API}
\label{sec:api_architecture}

A typical network application makes a connection to a peer by using
the \ac{FQDN} of the peer. The \ac{FQDN} is queried from \ac{DNS} to
get the corresponding IPv6 address. The querying interface is
specified in the network socket application interface and it is
commonly known as the \verb|resolver|.

Network applications need additional support in the network socket
interface for two different reasons if \ac{HIP} is to be used. The
first reason is that a hostname query from \ac{DNS} should result in
\acp{HIT} instead of IPv6 addresses or otherwise the kernel module would
assume a connection without \ac{HIP}. This is discussed in more detail
\vpageref[below]{sec:api_architecture}. The second reason is that a
\ac{HIT} to IPv6 mapping should be sent to the kernel as a side effect
of a hostname query. Otherwise the kernel knows that it will be using
\ac{HIP} but the networking layer does not have a physical address
where to send packets to. This is further discussed
\vpageref[below]{sec:mapping_architecture}.

There are different groups of network applications from the \ac{HIP}
point of view, and they are described in more detail in
\autoref{sec:application_architecture}. Two specific groups with
different needs have been identified in our implementation
architecture: legacy applications and \ac{HIP} aware
applications. Legacy applications should be able to run \ac{HIP}
without any changes in source code. \ac{HIP} aware applications can
require or deny the use of \ac{HIP} explicitly. A motivation for the
application to require \ac{HIP} could be the end-to-end security, for
example. Performance reasons could be a reason to deny usage of
\ac{HIP}, for example, in a small device with a limited computing
capacity.

\subsubsection{Legacy Sockets API}
\label{sec:legacy_api_architecture}

% XX TODO: Miika, mention about the native HIP API

Traditional UNIX systems have a library called \verb|libc| which
contains an implementation for the BSD socket interface~\cite{stevens}
which are needed by network applications. USAGI has a separate libc
implementation for testing purposes and it is called
\verb|libinet6|. It is also used in the \ac{HIPL} project.

Network applications typically use \ac{DNS} names to address
peers. \ac{DNS} names have to be resolved to IPv6 addresses in libc
before network connections can be established with peers. The resolver
routines have been modified in the implementation so that \ac{DNS}
queries prefer \acp{HIT} to IPv6 addresses as return values. Otherwise
the kernel would just receive IPv6 addresses and assume that \ac{HIP}
will not be used.

It appeared to be sufficient to modify only one resolver function,
\verb|getaddrinfo|, for experimentation purposes. It was preferred to
the other resolver functions because it was the most generic function
of them all. Two new flags were added to the function and the flags
modify the behavior of the resolver function. The motivation behind
the flags is that some legacy systems may want to use \ac{HIP} without
no changes in application code. Some other systems may require or deny
the use of \ac{HIP} explicitly.

\textit{Transparent mode} in the \ac{API} means that \ac{DNS} queries
resolve silently to \acp{HIT} instead of IPv6 addresses. This is only
possible because \acp{HIT} are stored in the same data structures as
IPv6 addresses. \acp{HIT} and IPv6 addresses can then be distinguished
by the two upper bits in the address.

Backwards compatibility of legacy network applications is the greatest
benefit of transparent mode because no changes are required in source
files of the existing network applications to enable \ac{HIP}
connections. To be more specific about changes, applications which are
dynamically linked to \verb|libc| do not need any changes, but
statically linked applications require to be recompiled. The
recompilation of applications may even be omitted by overriding the
\verb|libc| as presented in \cite{libcoverride}.

Transparent mode is set or unset by a compile time flag in
libinet6. This means that transparent mode is system specific instead
of application specific. Transparent mode is enabled by default.

The other flag is concerned about enforcing the use of \ac{HIP}
independently of transparent mode. The name of the flag is
\verb|AI_HIP| and it is passed as a parameter to the resolver
routine. If the flag is set, the resolver returns only \acp{HIT} as the
result for query of the hostname. Effectively, this means that
connections will be established with \ac{HIP} or not at all.

A typical example of a network application that used \verb|AI_HIP|
flag would be a \ac{HIP} aware application that needs end-to-end
authentication and security or mobility features provided by
\ac{HIP}. A source code example for such an application is shown in
\autoref{tbl:ai_hip_example}. Legacy applications cannot use this
option because it is an extension to the existing network sockets API.

\begin{table}[hbt]
\begin{verbatim}
01  struct addrinfo hints;
02  struct addrinfo *res;
03  int err;
04  int fd;
05
06  hints.ai_flags = AI_HIP | AI_CANONNAME;
07  hints.ai_family = AF_INET6;
08  hints.ai_socktype = SOCK_STREAM;
09  hints.ai_protocol = 0;
10
11  err = getaddrinfo("hip.host.org", "echo", &hints, &res);
12  fd = socket(res->ai_family, res->ai_socktype, res->protocol);
13  connect(fd, res->ai_addr, res->ai_addrlen);
14  close(fd);
15  freeaddrinfo(res);
\end{verbatim}
\caption{Example use of \texttt{AI\_HIP} flag in C language.}
\label{tbl:ai_hip_example}
\end{table}

There are many address resolving routines in the network socket
\ac{API}. The implementation supports \verb|getaddrinfo|, because it
is the most generic resolver function. Supporting just one function
seemed also to be enough for experimentation purposes. The output of
\verb|getaddrinfo| with different combinations of the \verb|AI\_HIP|
flag and the transparency flag is shown in
\autoref{tbl:getaddrinfo_combo}. The table is valid only if the object
of the query is a \ac{FQDN} name, otherwise \verb|getaddrinfo| behaves
as without \ac{HIPL} modifications.

\begin{table}[htb]
\centering
\begin{tabular}{|l|l|l|l|l|} \hline
Transparent mode & \verb|AI_HIP|  & output                   \\\hline
off        & not set        & no HITs                    \\
off        & set            & only HITs                  \\
on         & set            & only HITs                  \\
on         & not set        & HITs before IPv6 addresses \\
\hline
\end{tabular}
\caption{The output of \texttt{getaddrinfo} with different combinations of
the transparent mode flag and the \texttt{AI\_HIP} flag. }
\label{tbl:getaddrinfo_combo}
\end{table}

If both transparency and \verb|AI_HIP| are not set, it is assumed that
the administrator of the system has consciously disabled \ac{HIP} in
the system. A reason for this may be that the host cannot handle the
overhead of the \ac{HIP} protocol. On the other hand, if \verb|AI_HIP|
is set, only \acp{HIT} will be returned because the application is
assumed to require \ac{HIP}. This means that the application is
\ac{HIP} aware and, for example, wants to benefit from the end-to-end
security provided by \ac{HIP}. The type of the application is assumed
to be legacy if transparency mode is off and no \verb|AI_HIP| flag is
explicitly set. Legacy applications are not \ac{HIP} aware but the
administrator of the system has enabled \ac{HIP} transparency mode so
that even legacy applications can use \ac{HIP}.

\subsubsection{Native Sockets API}
\label{sec:native_api_architecture}

% XX FIX MIIKA

\subsubsection{Mappings}
\label{sec:mapping_architecture}

This section discusses a modification in the resolver that is not
visible to network application developers and users. The modification
is about mapping of \acp{HIT} and IPv6 addresses. It is separated from
the \ac{API} discussion \vpageref[above]{sec:api_architecture} because
it is a side effect in the resolver and does not change the way
\ac{API} is used.

A typical network application commonly addresses hosts in \ac{FQDN}
form instead of using an IPv6 address directly. The \ac{FQDN} name is
mapped to a \ac{HIT} using a resolver call as discussed
\vpageref[above]{sec:api_architecture}. The mapping is communicated to
kernel during the resolver call in the implementation. The resolver is
queried for a \ac{FQDN} which is resolved to both a \ac{HIT} and an
IPv6 address. The \ac{HIT} and the IPv6 address are sent to the kernel
module as a side effect so that the kernel module knows the network
address of the peer later upon a \verb|connect| call.

There are two problems related to mapping. The first one is a local
security problem and the second one is related to establishing a
connection without a resolver call. Problem descriptions and simple
solutions for both of the problems in the implementation are described
below.

The local security problem is a consequence of sending the mappings
directly from the resolver to the kernel. In a typical Unix system,
all users are allowed to use network applications and thereby also the
resolver must be accessible to all users. The resolver is linked to
the network application and therefore the resolver is executed using
the privileges of the user of the network application. As a result of
this, the kernel module must allow incoming mapping from every user of
the local system. The core of the problem is that a local intruder
could mimic the behavior of the resolver and send a large amount
invalid mapping entries to the kernel module. The mapping table of the
kernel module would then be poisoned if the mapping table was shared
between all users. The poisoning of mapping tables would effectively
result a \ac{DoS} for \ac{HIP} applications in the system.

The security problem is solved by tagging each mapping with the
\ac{UID} of the user of the application. When kernel searches for a
mapping upon connection attempt, valid mappings and connection
initiator's mappings are preferred first. The worst thing the intruder
could then do is to poison his own mapping tables. The preference of
\acp{UID} is listed in \autoref{tbl:preference_of_mappings}.

\begin{table}[htb]
\begin{enumerate}
\item Valid mappings
\item User
\item Root
\item Other users
\end{enumerate}
\caption{Preference of mappings}
\label{tbl:preference_of_mappings}
\end{table}

A valid mapping means that a \ac{HIP} security association has once
been successfully created using the specified mapping. Therefore valid
mappings are preferred first. Mapping of the application user and the
system administrator are second and third in the preference list
because they are trusted users. It is important to leave the other
users as the last group to avoid poisoning. Other users have to have
the lowest preference because a local attacker could otherwise poison
the mapping tables of the other users.

The other problem occurs when a network application attempts to
connect directly to a \ac{HIT} without any resolver call. The resolver
call is essential for the connection to succeed because the resolver
sends the \ac{HIT} to IPv6 mappings to the kernel module as a side
effect. Otherwise the kernel just knows the \ac{HIT} of the peer but
cannot actually deliver the packet to the network because the
corresponding IPv6 address is not known. The only option to handle
this problem in the implementation is manual mapping which can be
performed using a command line tool.

\subsubsection{Userspace Network Applications}
\label{sec:application_architecture}

% XX FIX MIIKA
% - should I remove this?

New \ac{HIP} aware applications may require the use of \ac{HIP} or may
deny the use of it for performance reasons, for example. Legacy
applications should be able to use \ac{HIP} without any changes to
source code. This is not always true for legacy applications and the
restrictions are discussed in this section.

\ac{HIP} aware applications may require or deny the use of \ac{HIP}. A
reason to require \ac{HIP} would be to benefit from multihoming,
end-to-end security and mobility features of \ac{HIP}. A reason to
deny the use of \ac{HIP} would be to avoid the overhead caused by
\ac{HIP} in a device with limited computing capacity.

Typical legacy IPv6 applications should be able to use \ac{HIP} in
transparent mode just by relinking them to USAGI libinet6 with \ac{HIP}
modifications. Later on, libinet6 could be merged with standard libc,
so even the relinking would not be required.

It has not been specified earlier, what a ``typical'' network
application is from the \ac{HIP} point of view. A typical application
means an application that is willing to accept peer names in \ac{FQDN}
form. If the peer names are not mapped to \acp{HIT} through a resolver
call before attempting a connection, \ac{HIP} cannot be used in the
application even in transparent mode.  A limiting element in the
implementation is that only \verb|getaddrinfo| resolving interface is
supported in the implementation. More resolver interfaces should be
supported in the future.

Typical legacy network applications such as Telnet clients and web
browsers should work as they are in transparent \ac{HIP}
mode. \ac{NAT}, firewall~\cite{hiparch} and other raw packet handler
software may need changes in application code to support
\ac{HIP}. Network applications cannot use \ac{HIP} at all if they use
IPv6 addresses directly instead of using \ac{FQDN} identifiers. The
implementation assumes that connections are established without
\ac{HIP} intervention in such cases.

There is a special scenario that was already discussed
\vpageref{sec:mapping_architecture} but it is worth mentioning also in
here. \ac{HIP} may be used to establish connections directly to HITs
without no previous resolver call in applications. Technically this is
a correct way to use \ac{HIP} but it is still a research problem that
is discussed \vpageref[below]{sec:mapping_lessons}. The only solution
in the implementation is to set the \ac{HIT} to IPv6 mappings manually
before establishing connections.

\subsection{Collaboration of Components}
\label{sec:collaboration_of_architecture_components}

% XX TODO: we do not have any daemon anymore
% XX TODO: is responder point of view described in the example?

This section gives a summary of the collaboration of the components
using a network application example.
\autoref{fig:collaboration_architecture} visualizes the total system
architecture. The interfaces between the components are labeled with
letters for simplicity in the figure.

\begin{figure}[hbt]
 \centering
 \includegraphics[scale=0.5]{fig/collaboration}
 \caption{Collaboration of components}
 \label{fig:collaboration_architecture}
\end{figure}

Only a minimal base exchange is demonstrated in this example scenario
because it has been the main focus in the project. The scenario is
simplified, and the details can be found from
\autoref{sec:implementation_architecture}. Mobility and multihoming
are not demonstrated in this scenario.

The configuration in this example consists of two hosts with \ac{HIPL}
enabled kernels. Both of the hosts use ``legacy'' userspace
applications that are not \ac{HIP} aware. Transparent mode is enabled
in \verb|libinet6| in both of the hosts because the type of the
applications is legacy. The hosts will be referred to as initiator and
responder, depending on who starts the base exchange.

Initiator is a host installed with a web browser that is linked to
\verb|libinet6|. Responder has a \ac{HTTP} server listening for
incoming requests. A \ac{DNS} server of the domain of the responder is
configured to contain the \ac{FQDN} and the IPv6 address of the
responder. The \ac{HIT} of the responder is also stored in a \ac{DNS}
server of the domain of the responder.

The \ac{HIP} network module is loaded into the kernel and the
userspace daemon is started in both of the hosts during boot-up. The
\ac{HIP} network module in the kernel queries a \ac{HI} for the
localhost immediately after the daemon has notified the kernel module
that the daemon is available for serving requests. Interface
\textbf{a} will be used for this. The kernel module also builds up a
list of prebuilt R1 packets for quick sending. \ac{HIP} connections
can now be established.

The user of the initiator host inputs the \ac{FQDN} address of the
responder into the web browser to view the web pages in the
responder's \ac{HTTP} server. The browser sends a \ac{DNS} query for
the \ac{FQDN} using the resolver routine \verb|getaddrinfo| using
interface \textbf{c}. The resolver query is served by the modified
resolver because the browser is linked to \verb|libinet6|.

The modified resolver queries \ac{DNS} using the responder's
\ac{FQDN}. The resolver finds a matching entry: an IPv6 address and a
\ac{HIT}. Now, two things are done before the entries are returned in
a list from the resolver. First, the resolver organizes the order of
the entries before returning them. The \ac{HIT} of the responder is
placed in front of the list before the IPv6 address because
transparent mode is used in \verb|libinet6| (see
\autoref{tbl:getaddrinfo_combo}). Second, the mapping of the \ac{HIT}
to the corresponding IPv6 address is sent to the kernel using
interface \textbf{d} as described \vpageref{sec:mapping_architecture}.

Control of flow returns to the browser after the resolver call is
completed. The result of the resolver call is a list containing first
the \ac{HIT} address and then the IPv6 address of the responder. The
browser is assumed to make a straightforward choice and select the
first address from the list, which is a \ac{HIT} in this case. The
\ac{HIT} is then used in socket calls. Because the browser uses the
\ac{HTTP}~\cite{rfc2616} protocol on top of \ac{TCP}, it passes the
\ac{HIT} to the \verb|connect| call in the network socket \ac{API}
(interface \textbf{b}).

The \verb|connect| call is handled by the \ac{TCP} layer in the
kernel.  The \ac{TCP} layer begins to establish the connection by a
\ac{TCP} handshake process which sends a SYN packet to the
responder. The SYN packet is carried to the IPv6 layer to be
transmitted to network but the \ac{HIP} output hook captures the
packet before the IPv6 layer (interface \textbf{e}) because the
destination address is a \ac{HIT}. The hook finds out that there are
no earlier security associations with the peer and determines that a
base exchange needs to be done between the peers before the SYN packet
can be sent to the responder.

The initiator initializes the base exchange by sending an I1 packet
using interface \textbf{f}. R1, I2 and R2 packets are exchanged after
this. During this, the kernel module checks the validity of incoming
packets, builds up outgoing packets and sends them. The kernel module
updates its state machine during base exchange.

After the base exchange is successfully completed and handled in both
hosts, the connection is secured with \ac{ESP}. The \ac{TCP} handshake
can continue using interface \textbf{f} now and once it has been
completed, the initiator can finally view the web pages from the
\ac{HTTP} server of the responder.

The \acp{SA} that are created during the base exchange are host
specific and not connection specific. This means that packets related
to other connections between the same hosts do not require a new base
exchange.

\section{Future Work}
\label{sec:future_work}

\ac{HIPL} is still a work in progress and all features described in
this document are not yet fully implemented. The most important future
work areas in the implementation is described in this section. A more
detailed and comprehensive list of future work can be found from the
project \verb|TODO| file~\cite{hipl}.

\subsection{Kernel Model}
\label{sec:kernel_model_future_work}

Once all the cryptographic functions are ported to kernel, major
changes to the kernel model are required. Firstly, the idea is to
isolate the \ac{HIP} working thread out of the other contexts and
events. This is probably done by creating working queues for incoming,
outgoing and daemon messages.  The worker thread continuously polls
(by some means) all the queues.  The working thread's running cycle
completes when it has performed the action that the message
requires. And then the cycle begins again.

Since there will be more than one message queue, it will be
interesting to find out, how to prioritize different queues. Is
incoming packet more important than outgoing ones? Or should the
daemon messages be always handled first? What happens then if some
malicious user succeeds in constantly sending daemon messages to the
\ac{HIP} module?  We could also consider if there is a way to make
sure that the \ac{HIP} module does not consume too much processing
time.

What happens in multiprocessor machine? The initial plan is to add one
worker per processor. All workers would have separate working queues.
This way they are isolated from each other as much as possible.
Naturally there are common data structures that need to be protected.
That protection should be quite straight forward, as the worker
threads are not ran in sensitive contexts. This means that they can
sleep without causing harm to the system. The same does not if the we
would process the packets straight as they come from the network stack
in an interrupt context.

All in all, for future the kernel model provides lots of challenges to
be researched.

\subsection{Networking Stack}
\label{sec:networking_stack_future_work}

% vanha ?
Implementation work was first focused on the base exchange, but
currently there is more interest to implement \ac{HIP} mobility and
multihoming features according to the \cite{hip-ietf-mm-00} draft.

An automated unit testing framework has been created for testing the
userspace and kernelspace code. Some of the functions related to the
networking stack can be tested using the unit testing framework, but
most of the code is so dependent of the standard Linux networking
stack code that the \ac{HIP} part of the code is quite difficult to
test in isolation. Black box testing has been used instead.

% uusi ?
IPv4 support has been excluded from the project goals but it would be
an appealing feature in \ac{HIPL}. IPv4 support requires its own
hooking mechanism because IPv4 and IPv6 layer code are separated in
the kernel.

\subsection{Mobility and Multihoming}
\label{sec:future_mobility_and_multihoming}

% XX TODO MIKA:
% - update this section
% - QoS stuff could be done with RTT estimation
% - optimization of the ESP output (?) traffic (skb cache)
% - our demo apps sometimes stall (pressing enter on nc6)
% - better integration to TCP (timeouts)
% - what else?

The general problem of selecting ``the best'' destination address for
a peer is also present in the implementation. Currently, we try to use
the address which peer has advertised us to be the preferred
address. If that becomes unreachable, an another available address
belonging to the same \ac{SA} is used. When a \ac{SA} has no usable
addresses, we try to use some address from an another outbound
\ac{SA}.


%any reachable
%address is selected non-deterministically and used as the destination
%address. %This approach might result in degraded performance if an
address with low \ac{QoS} characteristics is selected for the
destination address. However, the \ac{QoS} service is issues are out
of the scope.

A forwarding agent~\cite{hiparch,hip-mm} and related packets (FAQ,
FAA) must also be implemented for gain a full support for the mobility
and multihoming features.

\subsection{Sockets API}

\subsubsection{Legacy Sockets API}

The lack of an socket \ac{API} specified for \ac{HIP} is a problem for
the \ac{API}. An official draft should be created to force the
unification of the \ac{API} of different
implementations. \cite{hipapi} serves as a first step towards such a
draft.

\ac{HIPL} specification for the \ac{API}
\vpageref{sec:api_architecture} is purely tentative and it is expected
to changed radically in \cite{hipapi}. \ac{HIPL} \ac{API} contributes
only a solution to the IPv6 address space and ignores IPv4 issues
altogether, which is a major drawback. \cite{boeing} describes also a
small interface enhancement for the IPv4 sockets.

Other resolver functions, such as \verb|gethostbyname|, should also be
modified to support \ac{HIP}. Until then, \verb|getaddrinfo| suffices
for testing purposes.

Transparent mode is controlled by a static compilation flag in
libinet6. This means that transparent mode is host specific and not
application specific. There has been some talk about a more dynamic
method to control transparent mode, such as using function
\verb|setsockopt|. This is a bit contradictory because the transparent
mode is targeted for the legacy applications and the source code in
legacy applications should not be altered.

Transparent mode may break existing applications, such as IP
integrated applications. This should be investigated and tested with
existing applications.

\subsubsection{Native Sockets API}

\subsubsection{Mapping}
\label{sec:mapping_future_work}

Mapping of \acp{HIT} to IPv6 addresses is sent to the kernel as a side
effect of resolver calls. This is not architecturally the most elegant
way to do this but it has to do until some better mechanism is
invented.

The side effect in the resolver does not solve the situation where a
connection is established directly to a \ac{HIT} without any resolver
call. Either \ac{DNS} should support searching of the \acp{HIT} or
some other \ac{HIT} capable directory should be used. \ac{DNS} is a
bit troublesome because it is hierarchical and \acp{HIT} are not
hierarchical even though there has been some discussion about
hierarchical \acp{HIT}. This issue remains to be a research problem.

\section{Conclusion}
\label{sec:conclusion}

In this document, we described the \ac{HIP} architecture, which has
been designed to overcome problems mainly with respect to security,
mobility, and privacy in the current Internet. \ac{HIP} adds a new
layer between the networking and transport layer in the IP stack, and
introduces a \ac{HI} to serve as an endpoint identifier of the
host. Typically, the \ac{HI} is represented by a public key. Each host
will have at least one \ac{HI} assigned to its networking kernel or
stack. As the \ac{HI} is used to identify the hosts, the IP addresses
are used merely for routing purposes.

The purpose of the \ac{HIP} base exchange is to perform end-to-end
authentication and to establish \ac{IPsec} \acp{SA}.

% XX FIX MIKA:
% - add to this paragraph something about the mm stuff

HIP mobility draft shows that it is possible to extend the basic HIP
functionality by introducing new parameters and adding related changes
to the packet handling without breaking the base specifications. Our
working implementation proves that HIP mobility is feasible to implement.


As part of this document, we presented our IPv6 based implementation
of \ac{HIP} for Linux. Our implementation is the only completely
kernel based \ac{HIP} implementation.  The advantage of our approach
is that the kernel can remain as intact as possible, with only minor
modifications. Furthermore, the modifications are backwards compatible
so that the host is able to do networking without \ac{HIP}. Our
implementation is based on Linux kernel 2.6 series.
