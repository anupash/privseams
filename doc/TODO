$Id: TODO,v 1.145 2003/10/30 16:48:33 mkomu Exp $

This file contains some of the things to do for the
implementation. The rest of the TODO items are scattered in source
files: mainly as a list in the beginning of the source file.
Sometimes the items are as notes elsewhere in the source file if the
there is specific line of the source code that needs fixing. Search
for the strings "XX" or "TODO" to locate the file specific TODO items.

IETF 58 action items
====================

[MIKA] Respect responder's Diffie-Hellman group.

[LATER] Host Identity Tag (draft-08)
Any conforming implementation MUST be able to deal with both types of
HITs.  When handling other than type 1 HITs, the implementation is
RECOMMENDED to explicitly learn and record the binding between the
Host Identifier and the HIT, as it may not be able generate such HITs
from Host Identifiers.

[DONE] 3.3 Security Parameter Index (draft-07)
The SPI selection SHOULD be random.  A different SPI SHOULD be used
for each HIP exchange with a particular host; this is to avoid a
replay attack.  Additionally, when a host rekeys, the SPI MUST change.
Furthermore, if a host changes over to use a different IP address, it
MAY change the SPI used.
-random SPI in I2 and R2

[MIKA] 3.5 TCP and UDP pseudoheader computation (draft-07)
When computing TCP and UDP checksums on sockets bound to HITs or LSIs,
the IPv6 pseudo-header format [10] is used.  Additionally, the HITs
MUST be used in the place of the IPv6 addresses in the IPv6
pseudoheader.  Note that the pseudo-header for actual HIP payloads is
computed differently; see Section 6.1.2.
-HIP payload checksum should be ok

[DONE] 4.1.1 HIP Cookie Mechanism (draft-07)
Note, however, that the implementations MUST NOT use the exact
implementation given in the appendix, and SHOULD include sufficient
randomness to the algorithm so that algorithm complexity attacks
become impossible

[MIKA] 4.1.3 HIP Birthday (draft-08)
The Birthday also has to be increased in accordance with the system's
SA timeout parameter. If the system has open SAs, it MUST increase its
Birthday.
-"open SAs"=? When building R1 birthday is set automatically

[LATER] 4.2 Sending data on HIP packets (draft-08)
- The OPTIONAL PAYLOAD packet (see Section 7.8) MAY be used to transfer
  data.

[LATER] 4.3 Rekey (draft-08)
- All conforming HIP implementations MUST support rekeying.

[LATER] 5.1 HIP Scenarios (draft-08)
- Verify this.

[DONE] 5.4.1 HIP States (draft-08)
- E4 HIP SA established, rekeying
- without NES

[DONE] 5.4.2 HIP State Processes (draft-08)
E0, E2: retransmissions
E3: Receive R1, process with SA and Birthday check
 if successful, send I2 with last datagram, drop old SA if successful,
 send I2, prepare to drop old SA and cycle at E3
E4: add this state WITHOUT NES

[DONE] 5.3 Reboot and SA timeout restart of HIP (draft-07)
If a host reboots or times out, it has lost its HIP state.  If the
system that lost state has a datagram to deliver to its peer, it
simply restarts the HIP exchange.  The peer sends an R1 HIP packet,
but does not reset its state until it receives the I2 HIP packet.  The
I2 packet MUST have a Birthday greater than the current SA's
-birthday is checked but it is ignored

The system receiving the R1 packet first checks to see if it has an
established and recently used SA with the party sending the R1. If
such an SA exists, the system checks the Birthday, if the Birthday is
greater than the current SA's Birthday, it processes the R1 packet and
resends the ESP packet (along with or) after the I2 packet.  The peer
system processes the I2 in the normal manner, and replies with an R2.
This will reestablish state between the two peers.
-check

[MIIKA] 6.2 HIP parameters (draft-08)
- Lengths have been changed, check the header files. Validate lengths.

[DONE] 6.2.1 TLV format (draft-08)
- The C-bit has been added.

[DONE] 6.2.2 Defining new parameters (draft-08)
- Check.

[DONE] 6.2.3 SPI_LSI (draft-08)
- type number has changed (DONE)
- check the format (DONE)
- IETF57:
  - LSI was all zeroes. Should have been 1.X.X.X where X.X.X is 24
    lowest bit of the HIT. (DONE, but we don't support LSIs yet)

[DONE] 6.2.4 BIRTHDAY_COOKIE (draft-08)
- type number has changed
- remove hash target
- check the format of the parameter
- cookie database

[DONE] 6.2.9 HOST_ID_FQDN ()
- type number has been changed
- is this really supported in the implementation?
  o nope

[DONE] 6.3.3 DIFFIE_HELLMAN (draft-07)
- check the format

[DONE] 6.3.6 HOST_ID (draft-07)
- check the format

[DONE] 6.2.11 HMAC (draft-08)
- check the "HMAC calculation and verification process"

[DONE] 6.3.9 HIP_SIGNATURE (draft-07)
- Signature calculation and verification process

[DONE] 6.2.13 HIP_SIGNATURE_2 (draft-08)
- type number has been changed

[LATER] 6.2.14 NES_INFO (draft-08)
- the type number and the format has been changed

[DONE] 6.2.15 ENCRYPTED (draft-08)
- IETF56
  -initialization vector was all zeroes, check and fix it

[LATER] 7. HIP Packets (draft-07)
An OPTIONAL upper layer payload MAY follow the HIP header. The payload
proto field in the header indicates if there is additional data
following the HIP header. The P-bit in the control field of the HIP
packet header indicates whether the sender is capable of sending and
receiving this additional data.

[MIIKA] 7.1 I1 - the HIP Initiator packet (draft-07)
- Valid control bits: None

[MIIKA] 7.2 R1 - the HIP Responder packet (draft-07)
- Valid control bits: C, A

[MIIKA] 7.3 I2 - the HIP Second Initiator packet (draft-07)
- Valid control bits: C, E, A

[MIIKA] 7.4 R2 - the HIP Second Responder packet (draft-07)
- Valid control bits: E

[DONE] 7.4 R2 (draft-08)
- add the HMAC parameter
- Initiator MUST validate both the HMAC and the signature.

[LATER] 7.5 NES - the HIP New SPI Packet (draft-08)
- The NES packet is MANDATORY.
- add the HMAC

[LATER] 7.6 BOS - the HIP Bootstrap Packet (draft-08)
- The BOS packet is OPTIONAL.

[LATER] 7.7 CER - the HIP Certificate Packet (draft-08)
- The CER packet is OPTIONAL.

[LATER] 7.8 PAYLOAD - the HIP Payload Packet (draft-08)
- The PAYLOAD packet is OPTIONAL.

[LATER] 8. Packet processing (draft-08)
- this is a totally new chapter

[DONE] 9. HIP KEYMAT (draft-08)
- check and update making and drawing keymaterial if needed

[LATER] 12. HIP Policies (draft-07)
- All HIP implementations MUST support more than one simultaneous HIs,
  at least one one of which SHOULD be reserved for anonymous usage
- Support for more than two HIs is RECOMMENDED.


diff 08-pre-Oct01 08:

[DONE] 3.3 Security Parameter Index (SPI)

- The SPI selection SHOULD be random; the rules of Section 2.1 of the
ESP specification [15] must be followed.

6.2 HIP parameters
- Any added padding bytes MUST be set zero by the sender, but their
content SHOULD NOT be checked on the receiving end.

6.2.6 HIP_TRANSFORM
- There MUST NOT be more than six (6) HIP Suite-IDs

6.2.11 HMAC
- 160 low order bits of the HMAC computed over the HIP packet,
excluding the HMAC parameter and any following HIP_SIGNATURE or
HIP_SIGNATURE2 parameters.  The checksum field MUST be set to zero and
the HIP header length in the HIP common header MUST be calculated not
to cover any excluded parameters when the HMAC is calculated.
- HMAC calculation and verification process

6.2.12 HIP_SIGNATURE
- the signature is calculated over the HIP packet, excluding the
HIP_SIGNATURE TLV field, but including the HMAC field, if present. The
checksum field MUST be set to zero and the HIP header length in the
HIP common header MUST be calculated to the beginning of the
HIP_SIGNATURE TLV when the signature is calculated.


6.2.13 HIP_SIGNATURE_2
- the signature is calculated over the R1 packet, excluding the
HIP_SIGNATURE_2 TLV field, but including the HMAC field, if
present. Initiator's HIT and Checksum field MUST be set to zero and
the HIP packet length in the HIP header MUST be calculated to the
beginning of the HIP_SIGNATURE_2 TLV when the signature is calculated.
- NES ID Initialized to zero and incremented for each NES.

6.2.15 ENCRYPTED
- see the whole section

7.5 NES - the HIP New SPI Packet
- It also contains a NES ID and HMAC to provide DoS and replay
protection.  Each system must have a NES ID counter, initialized to
zero and incremented on each NES.

8.3.2 Processing incoming ICMP Protocol Unreachable messages
- currently received, but not handled

8.5 Processing incoming R1 packets
- 14.  The system initialized the remaining variables in the
associated state, including NES ID counters.

8.6 Processing incoming I2 packets
- 18.  The system initialized the remaining variables in the
associated state, including NES ID counters.

8.8 Initiating rekeying
- 3.  The system creates a NES packet, which SHOULD contain a
Diffie-Hellman parameter.  If the NES packet contains the
Diffie-Hellman parameter, the Keymat Index in the NES_INFO parameter
MUST be zero.

8.9 Processing NES packets
- 4.  If the received NES contains a Diffie-Hellman parameter, the
received Keymat Index MUST zero.  If this test fails, the packet
SHOULD be dropped and the system SHOULD log an error message.

8.9.1 Processing an initial NES packet
- 3. If the system generated new KEYMAT in the previous step, it sets
Keymat Index to zero, independent on whether the received NES included
a Diffie-Hellman key or not.

8.9.2 Processing a reply NES packet
- 2.  If the system generated new KEYMAT in the previous step, it sets
Keymat Index to zero, independent on whether the received NES included
a Diffie-Hellman key or not.
- 5.  If the system has no data to send for 500ms, it SHOULD send an
ESP packet anyway.  The purpose of this packet is to acknowledge the
other party that the NES reply came through, and to allow the other
party to switch over to the new outgoing SA.  It is RECOMMENDED that
the system sends an empty ESP packet, i.e., one where the Next Header
field is IPPROTO_NONE (decimal 59).

11. ESP with HIP
- see chapter

11.1 Security Association Management
- REMOVED: The SA MUST include the random # I that was used when the
SA was created.  It is used for replay protection.


action items:
=============

* Mika
  * remove chained code from REA/AC/ACR
  * /proc/net/hip/sdb_peer_addr: list addresses so that the first one is the
    one that will be "active"
  * multihoming: try multiple addresses of the peer if xmit fails?
  * check TODO entries from hip.c, input.c etc (the file was split and TODO
    entries may be in wrong files.
  * hipd setuid ? (man 2 setuid, not just chmod +s hipd)
  * test signature when p = q = null 
    - p=q=null not tested yet
  * libinet6 (usagi): read and learn resolver code, write API documentation
    - HITs as AAAA to /etc/hosts:iin (RFC3363 chapter 2)
  * refactor (Pekka's comments)
  * document to crypto.txt, who does and when
    - e.g. dsa-create-key(): send(i1) (which side of the connection and
      which packet)
  * autoloading (kmod) support (not planned)
    - when/how to decide need to load hip module
  * devfs support to hip module ? (most probably not)
  * confirm /proc support, (LDD 106 multiple pages of data)
  * khexdump locking ?
  * set up BIND and a few HITs to the virtual machines
  * remove sha1 code from keymat.c!
  * global Makefile
  * random seed to files using OpenSSL (RAND_seed)

* Miika
  * remove include/net/keymat.h
  * remove hip_get_any_localhost_any and replace with select_any_id
  * clean up the state machine handling
    * xmit should be done in the uppermost handling function for better support
      of unit testing
    * the state should also be changed in the uppermost handling function
  * ip6_output.c: how should the errors from hip_handle_output be handled?
  * We don't need HIP_CALLFUNC because we need also some other code
    surrounding them? Replace them with regular function calls?
   - regular: no, because ip6_*put.c will not compile if HIP is not to be compiled
  * rename lhi to something else
  * daemon is not really needed; consider removing synch messages altogether
  * include/net/keymat.h: this should be elsewhere
  * check if hipd_msg_exchange_queue is really emptied on rmmod
  * hip.c contains still too many unrelated functions: separate to different
    files! This is also needed to clarify the docbook doc.
  * webpages
    * change public_html to www?
    * status / news pages
    * the links in the blue box on the left are highlighted incorrectly
      => use ssi?
  * fix hip/db.c: hip_built_r1 has no acquire_lock
  * removal of chained code in the kernel
  * write unit tests
    * NULL daemon request
  * support for multiple HIs in localhost
  * support for establishing connections via loopback (first attempt failed!)
  * resolver
    - files:
      - check email exchanges with Ericsson
      - no HITs to /etc/hosts: ip fqdn alias
      - /etc/hip/hosts: hit fqdn
        - this is necessary
      - /etc/hip/known_hosts: hit [keydata_in_dns_format_pem_encoded]
        - this an option; if the HIs aren't cached, this file is unnecessary
    - functionality:
      - only when:
        not(transparency=off and AI_HIP=off) and node=dns_name
      - open and read /etc/hip/hosts, grep node name (=dns_name)
      - get HIT from the grep'd line and corresponding IP for the HIT by
        grepping HIT's fqdn from /etc/hosts (in libinet6 addresses are fetched
        transparently from /etc/hosts)
      - HIT-IP-mapping is sent to the kernel
      - gai returns HITs according to the normal AI_HIP ja transparency rules
        (see table)
  * builder implementation: use offsetof() instead of
    __attribute__ ((packed)) test
  * struct hip_xx { struct hip_tlv_common; data }
  * debug
    * HIP_INFO and others: use do { stuff; } while (0)
    * join userspace and kernel debug to one common c-file?
  * global autoconfiguration file
  * [ ] HIP; make bzImage
  *  O_TARGET := hipmod.o
  * module dependencies
  * Configure.help
  * upgrade kernel to 2.6.x
  * update debug.c
    * port debug.c for kernel
    * common unit testing environment to kernel and userspace
  * check possible crash situations of hipd and hipd crash recovery in kernel
    * if hipd crashed when it has a lock down() -> error recovery
      -> up() ja down() wrappers for locks which can handle also HIP_RESTART
  * ioctl(HIP_RESTART)
  * set up BIND and a few HITs to the virtual machines
  * /etc/hip/hipd.conf and parsers
  * parsers for hipd messages (both for kernel and userspace)
    - hip_parse_msg() / hip_check_msg()
      - an idea for hip_parse_msg(): parses the message into an pointer
        array, which contains pointers to all TLVs (is this BAD?)
    - build unit test suite for the builder
    - replace code from hip.c with builder functions
    - more hip_build_param_XX() functions are needed for 2)
      (add to builder.c when needed)
  * unit tests to builder
  * poisoning of mappings is specified, but not implemented
  * keymat 1,2,3,.. (check validity in interop test with Ericsson)
  * write a draft about HIP API issues?

* Kristian
  * see "removal of chained code" in my TODO list and think if it can
    can help the implementation part of your thesis
  * read literature/code about kernel programming and crypto
  * port to kernel [from OpenSSL?]
    * almost all of the functionality implementeted in hipd/crypto.c
    * DSA: [create a new key], sign, verify
    * DH, creation of new key, computation of shared secret
    * puzzle solving (puzzle specs will be slightly changed soon)
    * [ X.509 certificates ]
  * pre-emptive support is an option in 2.5 kernel, should both modes
    be supported?
  * unit test suite for the ported crypto

* Janne:
  * xx

* unassigned/all:
  * check: HIP_DEBUG must not expand to empty string if debugging is disabled
    (if (x) HIP_DEBUG(..) may be erroneous), expand to do { } while (0); instead
  * we should have different kind of dh keys (one for each group because
    the responder effectively decides the group number)
  * the dh keys should be recreated at some time points
  * timers for base exchange and rea
  * the first packet sent is always dropped: implement one packet buffer
  * Validate state transitions and whether to send a reply or not according to the state
  * hip_sdb -> hip_hadb (hip host association database)
  * piggypacking to R2/I2
  * unify storing format (network byte order vs. host by order) of sdb
    and other kernel data structures
  * HIP_WARN macro? (hmm..no)
  * HIP header checksum: use IP addresses, not HITs
   - see drafts
  * hip.c: if null-cipher registration fails, ignore?
  * check that the kernel builds with hipmod disabled
  * IPv4 support
  * handoff
    * return routability (unspecified)
    * fine tuning (ifconfig add del etc.)
    * problem: two hosts (A, B) in the same LAN and A changes LAN => B
      probably still sends packets to wrong link address
    * answer: when a REA is received, *something* must be deallocated
     * from Sep 24: REA with 0 addresses means "delete all addresses which has this Interface ID".
       This is not in specifications, but we test this to see if it is usable workaround fix.
  * handle special and error situations in the kernel
  * check lockings in the kernel
  * #includes
    * problem when #including ip.h
    * check content of include files and file locations, reorganize ?
  * test/conntest-server-hip
  * use errno.h everywhere (do not use sysexits ?)
  * typedef sockaddr_in6 = hit (research problem)
  * snapshot patches to web (against the base kernel)
  * javadoc like C-based documentation ?
   * DocBook is used currently
  * HIP related #defines not beginning with HIP to HIP_..
  * hip module should really depend on other modules (make config, Config.in)
  * change Host Identity -> Host Identifier in source code (arch
    draft chapter 3)
  * db.c: locking issues = add to function's comment block: "if this
    function uses some database, tell if it does the locking by itself
    or does the caller need to hold the lock before calling this
    function"
  * fixed size arrays -> change to use struct list_head
  * common functions/macros for variables of type struct list_head
  * status page: collect all MUST/SHOULD/etc from drafts and see if we comply to the drafts

* Pekka's comments:

(this example code is very old, it does not seem to be compliant to
the new specs)

  - hip_handle_flowlabel extracts the SPI value from IPv6
    flowlabel.  ESP is not used.  This is a kludge.

  - if the receiver has an HIP state already with a peer
    and it receives I1 (or I2) from the peer, there are
    basically three possibilities:
    - the peer has crashed or otherwise lost its HIP state
    - somebody is trying to launch a DoS or other attack
    - the peer is faulty -- this can be considered as a DoS
      attack, since it's the peer's fault

  - consider: remove some error prosessing from I1 (and only I1).
    I1 prosessing should be as fast as possible, to minimize
    the amount of resources spend on a DoS.

        if (!spin_try_lock(XXX))
            return;  /* Drop the received I1 */
        ... /* Send R1 */
        spin_unlock(XXX);

  - a simple test-and-set lock around handling I1, then use just a
    static data structure for the R1 packet
    - malloc/free becomes unnecessary
    - just on thread at time sending R1 -> automatic rate limitation
      of I1 handling
  - consider: only three entry points to HIP code from TCP/IP side:
    - ip6_output: trigger HIP whenever sending a packet
    - ip6_input: trigger HIP through extension header handling (as now)
    - ip6_input: trigger HIP through ESP SPI handling (now uses flowlabel for
this)

  - outline for ip6_output algorithm:

     if (destination address is not HIT)
         return and allow IP to function as before

     entry = lookup_database(destination address); /* XXX: lock(entry) */

     if (there is no entry)
         return EHOSTUNREACHABLE;

     switch (entry->state) {
     case NEVER_USED:
         send_i1
         entry->state = I1_SENT;
     case I1_SENT:
     case I2_SENT:
         queue_packet_to_entry
         unlock(entry);
         return without sending the packet
     case ESTABLISHED:
         unlock(entry);
         replace destination address (HIT) with a real destination address
         return and send the packet
     }

  - outline for hip_process_r1:

     entry = lookup_database(destination HIT from R1)

     if (there is no entry)
        drop packet and return

     switch (entry->state) {
     case NEVER_USED:
        unlock(entry)
        drop packet
        return
     case I1_SENT:
        send I2 with the queued packet as piggybacked payload
        entry->state = I2_SENT:
        unlock(entry);
        return
     case I2_SENT:
        resend I2 ?????
        unlock(entry)
        return;
     case ESTABLISHED:
        XXX: consider an error message or something like that,
        anyway, potentially need to resy
     }

